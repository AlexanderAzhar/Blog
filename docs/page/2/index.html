<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/Blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/Blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/Blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/Blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/Blog/css/main.css">


<link rel="stylesheet" href="/Blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ezharjan.github.io","root":"/Blog/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="This blog is maintained by Alexander Ezharjan, in order to record some useful things in life.">
<meta property="og:type" content="website">
<meta property="og:title">
<meta property="og:url" content="https://ezharjan.github.io/Blog/page/2/index.html">
<meta property="og:site_name">
<meta property="og:description" content="This blog is maintained by Alexander Ezharjan, in order to record some useful things in life.">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Alexander Ezharjan">
<meta property="article:tag" content="Software, Lab, Engineer, Game Engine, Alexander, Ezharjan">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://ezharjan.github.io/Blog/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title></title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/Blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title"></h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Blog By Alexander</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/Blog/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/Blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ezharjan.github.io/Blog/2022/03/05/%E6%8A%80%E8%83%BD%E9%9D%A2%E8%AF%95%E8%80%83%E5%89%8D%E5%86%B2%E5%88%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="Alexander Ezharjan">
      <meta itemprop="description" content="This blog is maintained by Alexander Ezharjan, in order to record some useful things in life.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2022/03/05/%E6%8A%80%E8%83%BD%E9%9D%A2%E8%AF%95%E8%80%83%E5%89%8D%E5%86%B2%E5%88%BA/" class="post-title-link" itemprop="url">技能面试考前冲刺</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-05 22:53:32" itemprop="dateCreated datePublished" datetime="2022-03-05T22:53:32+08:00">2022-03-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-17 10:12:41" itemprop="dateModified" datetime="2022-10-17T10:12:41+08:00">2022-10-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Blog/categories/Job-Interview/" itemprop="url" rel="index"><span itemprop="name">Job Interview</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h6 align="center">编者：艾孜尔江<h6>


<hr>
<h1 id="一、编程之美"><a href="#一、编程之美" class="headerlink" title="一、编程之美"></a>一、编程之美</h1><h2 id="1-2-中国象棋将帅问题"><a href="#1-2-中国象棋将帅问题" class="headerlink" title="1.2 中国象棋将帅问题"></a>1.2 中国象棋将帅问题</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> a:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b:<span class="number">4</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i.a = <span class="number">1</span>; i.a &lt;= <span class="number">9</span>; i.a++)</span><br><span class="line">    <span class="keyword">for</span> (i.b = <span class="number">1</span>; i.b &lt;= <span class="number">9</span>; i.b++)</span><br><span class="line">        <span class="keyword">if</span> (i.a % <span class="number">3</span> != i.b % <span class="number">3</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%u:%u&quot;</span>, i.a, i.b);</span><br></pre></td></tr></table></figure>

<h2 id="1-14-连连看"><a href="#1-14-连连看" class="headerlink" title="1.14 连连看"></a>1.14 连连看</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Grid* preClick = <span class="literal">NULL</span>, * curClick = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// listen user event</span></span><br><span class="line">    <span class="keyword">if</span> (点击格子 xy 非空) &#123;</span><br><span class="line">        preClick = curClick;</span><br><span class="line">        curClick.pos = x, y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (preClick &amp;&amp; curClick &amp;&amp; findPath(preClick, curClick)) &#123;</span><br><span class="line">        显示路径</span><br><span class="line">        消去</span><br><span class="line">        preClick = curClick = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-1-2-6-LeetCode"><a href="#2-1-2-6-LeetCode" class="headerlink" title="2.1 - 2.6 LeetCode"></a>2.1 - 2.6 LeetCode</h2><h2 id="2-7-最大公约数"><a href="#2-7-最大公约数" class="headerlink" title="2.7 最大公约数"></a>2.7 最大公约数</h2><p>辗转相除法，如果一个数能够整除x,y，那么他也能够整除x,x%y。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (y == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> gcd(y, x % y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// iterative</span><br><span class="line">int gcd(int x, int y) &#123;</span><br><span class="line">    while (y) &#123;</span><br><span class="line">        int t = x;</span><br><span class="line">        x = y</span><br><span class="line">        y = t % y;</span><br><span class="line">    &#125;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">取模运算开销较大，但如下方法在y比较小时，求解次数过多，容易溢出</span><br><span class="line"></span><br><span class="line">```C</span><br><span class="line">int gcd(int x, int y) &#123;</span><br><span class="line">    if (x &lt; y)</span><br><span class="line">        return gcd(y, x);</span><br><span class="line">    if (y == 0)</span><br><span class="line">        return x;</span><br><span class="line">    return gcd(x - y, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; y)</span><br><span class="line">        <span class="keyword">return</span> gcd(y, x);</span><br><span class="line">    <span class="keyword">if</span> (y == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">if</span> (x &amp; <span class="number">0x1</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">0x1</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> gcd(x&gt;&gt;<span class="number">1</span>, y&gt;&gt;<span class="number">1</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> gcd(x &gt;&gt;<span class="number">1</span>, y);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">0x1</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> gcd(x, y&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> gcd(y, x-y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="2-8-看下讲解"><a href="#2-8-看下讲解" class="headerlink" title="2.8 看下讲解"></a>2.8 看下讲解</h2><h2 id="2-9-斐波那契数列"><a href="#2-9-斐波那契数列" class="headerlink" title="2.9 斐波那契数列"></a>2.9 斐波那契数列</h2><p>使用动态规划(Memoization)的算法不在赘述O(n)。</p>
<p>O(logn)的解法</p>
<p>通项公式</p>
<pre><code>f(n), f(n-1) = (f(n-1), f(n-2)) * A

A = |1  1|
    |1  0| 

f(n), f(n-1) = (f(n-1), f(n-2)) * A = ... = (f1, f0) * A^(n-1)
</code></pre>
<p>下面我们计算<code>A^n-1</code>，太简单了，使用<code>A^(2n) = A^n * A^n</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// pesudo code</span><br><span class="line">int fib(int n) &#123;</span><br><span class="line">    Matrix factor = matrixPow(A, n-1);</span><br><span class="line">    return f1*factor + f0*factor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Matrix matrixPow(Matrix m, int n) &#123;</span><br><span class="line">    Matrix result = Matrix::Identity;</span><br><span class="line">    while (n) &#123;</span><br><span class="line">        if (n &amp; 1)</span><br><span class="line">            result *= m;</span><br><span class="line">        m *= m;</span><br><span class="line">        n &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拓展问题，如果是前三项相加的数列呢，依然可以求出转移矩阵</p>
<h2 id="2-11-最近点对问题"><a href="#2-11-最近点对问题" class="headerlink" title="2.11 最近点对问题"></a>2.11 最近点对问题</h2><h2 id="2-12-2-14-LeetCode-2-15-Cracking-2-16-2-17-LeetCode"><a href="#2-12-2-14-LeetCode-2-15-Cracking-2-16-2-17-LeetCode" class="headerlink" title="2.12-2.14 LeetCode 2.15 Cracking 2.16 2.17 LeetCode"></a>2.12-2.14 LeetCode 2.15 Cracking 2.16 2.17 LeetCode</h2><h2 id="2-18-数组分割"><a href="#2-18-数组分割" class="headerlink" title="2.18 数组分割"></a>2.18 数组分割</h2><h2 id="2-19-LeetCode"><a href="#2-19-LeetCode" class="headerlink" title="2.19 LeetCode"></a>2.19 LeetCode</h2><h2 id="3-1-有时间可以尝试写一下"><a href="#3-1-有时间可以尝试写一下" class="headerlink" title="3.1 有时间可以尝试写一下"></a>3.1 有时间可以尝试写一下</h2><h2 id="3-2-电话号码对应英文单词"><a href="#3-2-电话号码对应英文单词" class="headerlink" title="3.2 电话号码对应英文单词"></a>3.2 电话号码对应英文单词</h2><p>递归写法</p>
<h2 id="3-3-Edit-Distance"><a href="#3-3-Edit-Distance" class="headerlink" title="3.3 Edit Distance"></a>3.3 Edit Distance</h2><h2 id="3-4-删除链表节点"><a href="#3-4-删除链表节点" class="headerlink" title="3.4 删除链表节点"></a>3.4 删除链表节点</h2><h2 id="3-5-最短摘要的生成"><a href="#3-5-最短摘要的生成" class="headerlink" title="3.5 最短摘要的生成"></a>3.5 最短摘要的生成</h2><p>问题转化为，在一个单词词组中，找出包含所有给定单词的最短区间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">abstract</span><span class="params">(vector&lt;string&gt; article, unordered_set&lt;string&gt; keywords)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>, range = INT_MAX;</span><br><span class="line">    unordered_map&lt;string, <span class="type">int</span>&gt; indecies;</span><br><span class="line">    unordered_set&lt;string&gt; having;</span><br><span class="line">    pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">while</span> (end &lt; article.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (end &lt; article.<span class="built_in">size</span>() &amp;&amp; !<span class="built_in">isContain</span>(keywords, having)) &#123;</span><br><span class="line">            indecies[articel[end]] = end;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isContain</span>(keywords, having)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (end - start + <span class="number">1</span> &lt; range) &#123;</span><br><span class="line">                range = end - start + <span class="number">1</span>;</span><br><span class="line">                result.first = start;</span><br><span class="line">                result.second = end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (indecies[aritcle[start]] == start)</span><br><span class="line">                having.erase[article[start]];</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-6-判断两个链表是否相交"><a href="#3-6-判断两个链表是否相交" class="headerlink" title="3.6 判断两个链表是否相交"></a>3.6 判断两个链表是否相交</h2><p>如果链表中有环呢？</p>
<h2 id="3-7-队列中取最大值"><a href="#3-7-队列中取最大值" class="headerlink" title="3.7 队列中取最大值"></a>3.7 队列中取最大值</h2><p>使用连个minstack模拟队列</p>
<h2 id="3-8-二叉树中两个节点之间的最远距离"><a href="#3-8-二叉树中两个节点之间的最远距离" class="headerlink" title="3.8 二叉树中两个节点之间的最远距离"></a>3.8 二叉树中两个节点之间的最远距离</h2><p>显然，对一个根节点，最远距离有两种情况：</p>
<ol>
<li>左子树或者右子树中的最远距离</li>
<li>左子树最长路径＋有子树最长路径+1</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> max_distance;</span><br><span class="line">    <span class="type">int</span> max_depth;</span><br><span class="line">&#125; <span class="type">result_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get max distance of two nodes in a tree</span></span><br><span class="line"><span class="type">result_t</span> <span class="title function_">get_max</span><span class="params">(<span class="type">tree_node_t</span>* root)</span> &#123;</span><br><span class="line">    <span class="type">result_t</span> result;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        result.max_distance = <span class="number">0</span>;</span><br><span class="line">        result.max_depth = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">result_t</span> left = get_max(root-&gt;left);</span><br><span class="line">    <span class="type">result_t</span> right = get_max(root-&gt;right);</span><br><span class="line"></span><br><span class="line">    result.max_depth = max(left.max_depth, right.max_depth) + <span class="number">1</span>;</span><br><span class="line">    result.max_distance = max(max(left.max_distance, right.max_distance), left.max_depth + right.max_depth + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于递归问题，书上的心得：</p>
<ol>
<li>在递归的实现中，往往假设后续的调用已经完成，在此基础上，才能实现递归的逻辑。</li>
<li>分析清楚递归体的逻辑。</li>
<li>考虑清楚递归退出的边界条件，也就是return的地方。</li>
</ol>
<h2 id="3-9-重建二叉树"><a href="#3-9-重建二叉树" class="headerlink" title="3.9 重建二叉树"></a>3.9 重建二叉树</h2><p>拓展问题，如何判断前序遍历和中序遍历是合理的？</p>
<p>测试用例：<br>非完全二叉树，退化的二叉树，满二叉树，普通二叉树，空树。。。</p>
<h2 id="3-10-层序遍历"><a href="#3-10-层序遍历" class="headerlink" title="3.10 层序遍历"></a>3.10 层序遍历</h2><p>注意把LeetCode上的ZigZag层序都看一遍。</p>
<p>递归的遍历需要先计算level</p>
<h2 id="3-11-注意问题"><a href="#3-11-注意问题" class="headerlink" title="3.11 注意问题"></a>3.11 注意问题</h2><p>对于询问知识点，要答得<em>正确</em>，<em>有条理</em>。最后写出来的程序已定要是<em>没有严重错误</em>，<em>完整</em>，并尝试用一些测试用例。</p>
<h2 id="4-1-金刚"><a href="#4-1-金刚" class="headerlink" title="4.1 金刚"></a>4.1 金刚</h2><p>询问李博士</p>
<h2 id="4-2-瓷砖覆盖地板"><a href="#4-2-瓷砖覆盖地板" class="headerlink" title="4.2 瓷砖覆盖地板"></a>4.2 瓷砖覆盖地板</h2><p>斐波那契额数列</p>
<p>1x2覆盖8x8？从小到大，先找出2x2有多少种，再找出4x4有多少种，再找出8x8有多少种。还有考虑好多种，注意不要有重复<br>pxq覆盖mxn？</p>
<h2 id="4-3-Catalan数"><a href="#4-3-Catalan数" class="headerlink" title="4.3  Catalan数"></a>4.3  Catalan数</h2><h2 id="4-4-点是否在三角形内部"><a href="#4-4-点是否在三角形内部" class="headerlink" title="4.4 点是否在三角形内部"></a>4.4 点是否在三角形内部</h2><p>给定 ABC，逆时针顺序，判断 D 是否在 ABC 内部</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 利用面积，如果 D 和 ABC 分别构成的三角形的面积小于 ABC 的面积，那么 D 在三角形内部</span><br><span class="line">double area(Point A, Point B, Point, C) &#123;</span><br><span class="line">    double a, b, c;</span><br><span class="line">    b = distance(A, C);</span><br><span class="line">    a = distance(B, C);</span><br><span class="line">    c = distance(A, B);</span><br><span class="line"></span><br><span class="line">    double p = (a + b + c) / 2;</span><br><span class="line">    return sqrt((p-a) * (p-b) * (p-c) * p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isInTriangle(A, B, C, D) &#123;</span><br><span class="line">    return area(A, B, D) + area(A, C, D) + area(B, C, D) &lt;= area(A, B, C);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 根据角度考虑，如果两个向量叉积为正，那么 P3 在P1P2的左边，如果一个点同时在 AB，BC，CA 的左边</span><br><span class="line">double cross(Point A, Point B, Point X) &#123;</span><br><span class="line">    return (B.x - A.x) * (X.y - A.y) - (X.x - A.x) * (B.y - A.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isInTriangle(A, B, C, D) &#123;</span><br><span class="line">    return cross(A, B, D) &gt;= 0 &amp;&amp; cross(B, C, D) &gt;= 0 &amp;&amp; cross(C, A, D) &gt;= 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-5-磁带文件存储优化"><a href="#4-5-磁带文件存储优化" class="headerlink" title="4.5 磁带文件存储优化"></a>4.5 磁带文件存储优化</h2><p>只考虑长度，按照文件长度由短到长存放。<br>只考虑访问频率，按照访问频率由高到低存放。<br>综合考虑，按照频率&#x2F;长度由高到低</p>
<h2 id="4-6-桶中取黑白球"><a href="#4-6-桶中取黑白球" class="headerlink" title="4.6 桶中取黑白球"></a>4.6 桶中取黑白球</h2><p>相当于使用 XOR，可以解任意问题</p>
<h2 id="4-7-蚂蚁爬杆"><a href="#4-7-蚂蚁爬杆" class="headerlink" title="4.7 蚂蚁爬杆"></a>4.7 蚂蚁爬杆</h2><p>相当于穿越</p>
<h2 id="4-8-三角形测试用例"><a href="#4-8-三角形测试用例" class="headerlink" title="4.8 三角形测试用例"></a>4.8 三角形测试用例</h2><p><code>int isTriangle(int a, int b, int c);</code></p>
<ol>
<li>用一个字节编码各种情况。</li>
</ol>
<p>用不同的位表示不同的结果，注意要正交</p>
<ol start="2">
<li><p>测试用例</p>
<ol>
<li><p>合法输入，各种三角形的形状，以及不是三角形的，还需要考虑交换不同边的顺序；</p>
</li>
<li><p>非法输入，负数，0，类型错误等等；</p>
</li>
<li><p>边界值，一般程序可能在<code>&lt; &lt;= &gt; &gt;=</code>上犯错误；</p>
</li>
<li><p>很大的数，很小的数，等等。</p>
</li>
</ol>
</li>
</ol>
<p>一般需要给出15-20个用例</p>
<h2 id="4-10-数字哑谜"><a href="#4-10-数字哑谜" class="headerlink" title="4.10 数字哑谜"></a>4.10 数字哑谜</h2><p>列出方程，使用深度优先搜索，注意剪枝</p>
<h2 id="4-11-扫雷游戏的概率"><a href="#4-11-扫雷游戏的概率" class="headerlink" title="4.11 扫雷游戏的概率"></a>4.11 扫雷游戏的概率</h2><br>
<br>
<br>

<h1 id="二、C-x2F-C-基本算法考点"><a href="#二、C-x2F-C-基本算法考点" class="headerlink" title="二、C&#x2F;C++基本算法考点"></a>二、C&#x2F;C++基本算法考点</h1><h2 id="1-1-确定一个字符串中所有数字是否完全不同"><a href="#1-1-确定一个字符串中所有数字是否完全不同" class="headerlink" title="1.1 确定一个字符串中所有数字是否完全不同"></a>1.1 确定一个字符串中所有数字是否完全不同</h2><p>首先应该询问面试官字符集的大小，是ASCII还是Unicode还是GBK，对于ASCII和GBK，<br>因为字符集大小有限，而且都不太大，可以使用一个数组统计，而对于Unicode，<br>显然只能使用Hash统计</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isUniqueChars</span><span class="params">(<span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() &gt; <span class="number">256</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">charSet</span><span class="params">(<span class="number">256</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : s)</span><br><span class="line">        <span class="keyword">if</span> (charSet[s])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            charSet[c] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：还可以使用位向量提高效率，但是C++的vector<bool>本身就是特质化的。</bool></p>
<h2 id="1-2-实现reverse-char-s"><a href="#1-2-实现reverse-char-s" class="headerlink" title="1.2 实现reverse(char* s)"></a>1.2 实现reverse(char* s)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!s) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">char</span>* end = s;</span><br><span class="line">    <span class="keyword">while</span> (*end++) ;</span><br><span class="line">    end--; <span class="comment">// back one</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (s &lt; end) &#123;</span><br><span class="line">        <span class="type">char</span> t = *s;</span><br><span class="line">        *s++ = *end;</span><br><span class="line">        *end-- = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-判断两个词是否是变位词-Anagram"><a href="#1-3-判断两个词是否是变位词-Anagram" class="headerlink" title="1.3 判断两个词是否是变位词(Anagram)"></a>1.3 判断两个词是否是变位词(Anagram)</h2><h2 id="1-4-编写一个方法，将字符串中的空格全部替换为-20，假设字符串结尾有足够空间"><a href="#1-4-编写一个方法，将字符串中的空格全部替换为-20，假设字符串结尾有足够空间" class="headerlink" title="1.4 编写一个方法，将字符串中的空格全部替换为%20，假设字符串结尾有足够空间"></a>1.4 编写一个方法，将字符串中的空格全部替换为<code>%20</code>，假设字符串结尾有足够空间</h2><p>对于数组操作的好多题目，尝试从尾部做起一下子就简单多了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">replaceSpaces</span><span class="params">(<span class="type">char</span>* s, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">int</span> spaceCount = <span class="number">0</span>, newLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(s[i]))</span><br><span class="line">            newLength++;</span><br><span class="line"></span><br><span class="line">    newLength = len + spaceCount * <span class="number">2</span>;</span><br><span class="line">    s[newLength] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(s[i])) &#123;</span><br><span class="line">            s[--newLength] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            s[--newLength] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">            s[--newLength] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s[--newLength] = s[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-5-压缩字符串-aabcccccaaa-gt-a2b1c5a3如果压缩后变短，返回压缩后的字符串"><a href="#1-5-压缩字符串-aabcccccaaa-gt-a2b1c5a3如果压缩后变短，返回压缩后的字符串" class="headerlink" title="1.5 压缩字符串 aabcccccaaa -&gt; a2b1c5a3如果压缩后变短，返回压缩后的字符串"></a>1.5 压缩字符串 <code>aabcccccaaa -&gt; a2b1c5a3</code>如果压缩后变短，返回压缩后的字符串</h2><p>首先要计算出新的长度，然后比较是否变短，如果变短，则执行压缩，否则返回</p>
<h2 id="1-6-给定一幅由N＊N矩阵表示的图像，顺时针旋转90度"><a href="#1-6-给定一幅由N＊N矩阵表示的图像，顺时针旋转90度" class="headerlink" title="1.6 给定一幅由N＊N矩阵表示的图像，顺时针旋转90度"></a>1.6 给定一幅由N＊N矩阵表示的图像，顺时针旋转90度</h2><h2 id="1-7-若m＊n矩阵中某个元素为0，就把这一行和这一列都清零"><a href="#1-7-若m＊n矩阵中某个元素为0，就把这一行和这一列都清零" class="headerlink" title="1.7 若m＊n矩阵中某个元素为0，就把这一行和这一列都清零"></a>1.7 若m＊n矩阵中某个元素为0，就把这一行和这一列都清零</h2><p>LeetCode 73 注意同样可以使用位向量提高效率</p>
<h2 id="1-8-给定方法isSubstring-，判断s1是不是可以由s2旋转组成"><a href="#1-8-给定方法isSubstring-，判断s1是不是可以由s2旋转组成" class="headerlink" title="1.8 给定方法isSubstring()，判断s1是不是可以由s2旋转组成"></a>1.8 给定方法isSubstring()，判断s1是不是可以由s2旋转组成</h2><p>假设s1 &#x3D; xy, s2 &#x3D; yx，yx一定是xyxy的字串，而且是中间部分。注意先判断长度，提高效率</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isRotation</span><span class="params">(string&amp; s1, string&amp; s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s1.<span class="built_in">size</span>() != s2.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    string s1s1 = s1 + s1;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isSubstring</span>(s1s1, s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-1-移除未排序列表中的重复节点"><a href="#2-1-移除未排序列表中的重复节点" class="headerlink" title="2.1 移除未排序列表中的重复节点"></a>2.1 移除未排序列表中的重复节点</h2><p>因为是无序的，所以我们还是需要记录重复节点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显然第一个节点是不可能被移除的，所以不用返回新的头部</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">removeDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; vals;</span><br><span class="line">    ListNode dummy, *p = dummy;</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vals.<span class="built_in">find</span>(p-&gt;next-&gt;val) != vals.<span class="built_in">end</span>())</span><br><span class="line">            ListNode* next = p-&gt;next;</span><br><span class="line">            p-&gt;next = next-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            vals.<span class="built_in">insert</span>(p-&gt;next-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不允许使用额外空间，那么这个功能至少需要O(N^2)实现</p>
<h2 id="2-2-实现一个算法，找出链表中倒数第K个元素"><a href="#2-2-实现一个算法，找出链表中倒数第K个元素" class="headerlink" title="2.2 实现一个算法，找出链表中倒数第K个元素"></a>2.2 实现一个算法，找出链表中倒数第K个元素</h2><h2 id="2-3-删除单向链表中的某个节点，假设你只有访问该节点的权限"><a href="#2-3-删除单向链表中的某个节点，假设你只有访问该节点的权限" class="headerlink" title="2.3 删除单向链表中的某个节点，假设你只有访问该节点的权限"></a>2.3 删除单向链表中的某个节点，假设你只有访问该节点的权限</h2><h2 id="2-4-以给定的值x分割列表，使得小于x的元素都排在x的前面"><a href="#2-4-以给定的值x分割列表，使得小于x的元素都排在x的前面" class="headerlink" title="2.4 以给定的值x分割列表，使得小于x的元素都排在x的前面"></a>2.4 以给定的值x分割列表，使得小于x的元素都排在x的前面</h2><p>LeetCode 83</p>
<h2 id="2-5-给定一个链表，每个链表节点存放一位数字，并且是反向存放的，求两个链表的和"><a href="#2-5-给定一个链表，每个链表节点存放一位数字，并且是反向存放的，求两个链表的和" class="headerlink" title="2.5 给定一个链表，每个链表节点存放一位数字，并且是反向存放的，求两个链表的和"></a>2.5 给定一个链表，每个链表节点存放一位数字，并且是反向存放的，求两个链表的和</h2><p>LeetCode 2</p>
<p>如果是正向存放的呢？</p>
<p>先求出两个列表的长度，然后用零填充一个较短的链表，然后在从前往后相加。</p>
<h2 id="2-6-给定一个有环链表，找到环的开头"><a href="#2-6-给定一个有环链表，找到环的开头" class="headerlink" title="2.6 给定一个有环链表，找到环的开头"></a>2.6 给定一个有环链表，找到环的开头</h2><p>LeetCode 141 142</p>
<h2 id="2-7-判断链表是否是回文-Palindrome"><a href="#2-7-判断链表是否是回文-Palindrome" class="headerlink" title="2.7 判断链表是否是回文(Palindrome)"></a>2.7 判断链表是否是回文(Palindrome)</h2><p>LeetCode 234</p>
<h2 id="3-1-如何用一个数组实现3个栈"><a href="#3-1-如何用一个数组实现3个栈" class="headerlink" title="3.1 如何用一个数组实现3个栈"></a>3.1 如何用一个数组实现3个栈</h2><p>如果是实现两个堆栈，可以把两头作为栈底，向中间生长。</p>
<p>解法1: 固定分割，显然这样是不能让面试官满意的。。</p>
<p>解法2: 弹性分割，并把数组看成是环状的！</p>
<h2 id="3-2-设计一个栈，支持min方法，返回栈中的最小值"><a href="#3-2-设计一个栈，支持min方法，返回栈中的最小值" class="headerlink" title="3.2 设计一个栈，支持min方法，返回栈中的最小值"></a>3.2 设计一个栈，支持min方法，返回栈中的最小值</h2><p>LeetCode 155</p>
<h2 id="3-3-实现SetOfStacks，由多个栈组成"><a href="#3-3-实现SetOfStacks，由多个栈组成" class="headerlink" title="3.3 实现SetOfStacks，由多个栈组成"></a>3.3 实现SetOfStacks，由多个栈组成</h2><p>这实际上是一道OOD(面向对象设计)的题目</p>
<h2 id="3-4-汉诺塔"><a href="#3-4-汉诺塔" class="headerlink" title="3.4 汉诺塔"></a>3.4 汉诺塔</h2><p>经典问题了，考虑 n＝2的时候，把上面1块放到中间，然后把下面一块移动完成。那么对于n，我们把n-1块移到中间即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void moveDisks(int n, tower_t origin, tower_t dest, tower_t buffer) &#123;</span><br><span class="line">    if (n &lt;= 0) return;</span><br><span class="line"></span><br><span class="line">    moveDisks(n-1, origin, buffer, dest); // 先把上面的n-1块放到中间</span><br><span class="line">    moveBottom(origin, dest) // 把最底下的盘子直接放过去</span><br><span class="line">    moveDisks(n-1, buffer, dest, origin) // 把中间的再放到最后</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-5-使用两个栈模拟一个队列"><a href="#3-5-使用两个栈模拟一个队列" class="headerlink" title="3.5 使用两个栈模拟一个队列"></a>3.5 使用两个栈模拟一个队列</h2><h2 id="3-6-对栈进行排序，额外的数据只能使用栈"><a href="#3-6-对栈进行排序，额外的数据只能使用栈" class="headerlink" title="3.6 对栈进行排序，额外的数据只能使用栈"></a>3.6 对栈进行排序，额外的数据只能使用栈</h2><p>使用简单插入排序，在一个新的栈中保存排序好的数据，从unsorted中弹出以后，不断弹出sorted为新元素找到正确位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="type">int</span>&gt; <span class="title function_">sortStack</span><span class="params">(<span class="type">const</span> <span class="built_in">stack</span>&lt;<span class="type">int</span>&gt;&amp; unsorted)</span> &#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="type">int</span>&gt; sorted;</span><br><span class="line">    <span class="keyword">while</span> (!unsorted.empty()) &#123;</span><br><span class="line">        <span class="type">int</span> temp = unsorted.top(); <span class="comment">// 待插入的新元素</span></span><br><span class="line">        unsorted.pop();</span><br><span class="line">        <span class="keyword">while</span> (!sorted.empty() &amp;&amp; sorted.top() &gt; temp) &#123; <span class="comment">// 不断弹出，找到合适位置</span></span><br><span class="line">            <span class="type">int</span> big = sorted.top(); sorted.pop();</span><br><span class="line">            unsorted.push(big);</span><br><span class="line">        &#125;</span><br><span class="line">        sorted.push(temp); <span class="comment">// 插入新元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sorted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<h2 id="4-1-检查二叉树是否平衡-任意两个节点之间的高度差不超过1"><a href="#4-1-检查二叉树是否平衡-任意两个节点之间的高度差不超过1" class="headerlink" title="4.1 检查二叉树是否平衡: 任意两个节点之间的高度差不超过1"></a>4.1 检查二叉树是否平衡: 任意两个节点之间的高度差不超过1</h2><h2 id="4-2-给定一个有向图，找出两个节点之间是否存在一条路径"><a href="#4-2-给定一个有向图，找出两个节点之间是否存在一条路径" class="headerlink" title="4.2 给定一个有向图，找出两个节点之间是否存在一条路径"></a>4.2 给定一个有向图，找出两个节点之间是否存在一条路径</h2><blockquote>
<p>碰到这类问题，有必要和面试官探讨一下DFS和BFS之间的利弊，例如，DFS实现起来比较简单，只需要简单的递归即可。BFS适合用来查找最短路径。<br>而DFS在访问临近借点之前可能会深度便利其中一个临近节点</p>
</blockquote>
<p>🌲的遍历一定要注意visited数组或者集合，因为树中可能有几个节点指向同一个节点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(Graph* graph, Node* start, Node* end)</span> </span>&#123;</span><br><span class="line">    queue&lt;Node*&gt; q;</span><br><span class="line">    unordered_set&lt;Node*&gt; visited;</span><br><span class="line"></span><br><span class="line">    q.<span class="built_in">push</span>(start);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> node = q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> adj : q.<span class="built_in">adjs</span>())</span><br><span class="line">            <span class="keyword">if</span> (visited.<span class="built_in">find</span>(adj) == visited.<span class="built_in">end</span>())</span><br><span class="line">                <span class="keyword">if</span> (adj == end)</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    q.<span class="built_in">push</span>(adj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-3-给定一个有序数组，元素各不相同且按升序排列，创建一颗高度最小的二叉查找树"><a href="#4-3-给定一个有序数组，元素各不相同且按升序排列，创建一颗高度最小的二叉查找树" class="headerlink" title="4.3 给定一个有序数组，元素各不相同且按升序排列，创建一颗高度最小的二叉查找树"></a>4.3 给定一个有序数组，元素各不相同且按升序排列，创建一颗高度最小的二叉查找树</h2><p>LeetCode 108</p>
<h2 id="4-4-给定一棵二叉树，创建层序访问的链表"><a href="#4-4-给定一棵二叉树，创建层序访问的链表" class="headerlink" title="4.4 给定一棵二叉树，创建层序访问的链表"></a>4.4 给定一棵二叉树，创建层序访问的链表</h2><p>LeetCode 102</p>
<h2 id="4-5-检查一棵二叉树是否为二叉查找树"><a href="#4-5-检查一棵二叉树是否为二叉查找树" class="headerlink" title="4.5 检查一棵二叉树是否为二叉查找树"></a>4.5 检查一棵二叉树是否为二叉查找树</h2><p>LeetCode 98</p>
<h2 id="4-6-找到二叉查找树指定节点的下一个节点-中序后继-，假设每个节点都有指向父节点的指针"><a href="#4-6-找到二叉查找树指定节点的下一个节点-中序后继-，假设每个节点都有指向父节点的指针" class="headerlink" title="4.6 找到二叉查找树指定节点的下一个节点(中序后继)，假设每个节点都有指向父节点的指针"></a>4.6 找到二叉查找树指定节点的下一个节点(中序后继)，假设每个节点都有指向父节点的指针</h2><p>按照中序遍历，左子树，当前节点，右子树，显然下一个节点应该在右边。也就是右子树中最左边的节点。<br>考虑没有右子树的情况，如果当前节点是左子节点，下一个节点应该是父节点。如果是右节点，我们继续向上，如果到达了root，显然没有更多节点了。</p>
<p>对于树这种可以分情况的最好先把各种情况想好了，在写代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">inorderSucc</span><span class="params">(TreeNode* n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (n-&gt;right) &#123;</span><br><span class="line">        TreeNode* right = n-&gt;right;</span><br><span class="line">        <span class="keyword">while</span> (right-&gt;left)</span><br><span class="line">            right = right-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        TreeNode* q = n, * parent = q.parent;</span><br><span class="line">        <span class="keyword">while</span> (parent &amp;&amp; parent-&gt;left != q) &#123; <span class="comment">// 找到当前节点可以作为左子节点的父节点</span></span><br><span class="line">            q = parent;</span><br><span class="line">            parent = parent-&gt;parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-7-查找二叉树的公共祖先"><a href="#4-7-查找二叉树的公共祖先" class="headerlink" title="4.7 查找二叉树的公共祖先"></a>4.7 查找二叉树的公共祖先</h2><p>LeetCode 236</p>
<h2 id="4-8-又两棵非常大的二叉树：T1-有几百万个节点，T2，有几百个节点。判断T2是否是T1的子树"><a href="#4-8-又两棵非常大的二叉树：T1-有几百万个节点，T2，有几百个节点。判断T2是否是T1的子树" class="headerlink" title="4.8 又两棵非常大的二叉树：T1 有几百万个节点，T2，有几百个节点。判断T2是否是T1的子树"></a>4.8 又两棵非常大的二叉树：T1 有几百万个节点，T2，有几百个节点。判断T2是否是T1的子树</h2><p>这道题并没有标准解法。值得和面试官探讨，详见树上的讲解（161页）。</p>
<h2 id="4-9-打印节点数值总和为给定值的路径，路径可以从任意节点开始，任意节点结束"><a href="#4-9-打印节点数值总和为给定值的路径，路径可以从任意节点开始，任意节点结束" class="headerlink" title="4.9 打印节点数值总和为给定值的路径，路径可以从任意节点开始，任意节点结束"></a>4.9 打印节点数值总和为给定值的路径，路径可以从任意节点开始，任意节点结束</h2><p>对于一个没有见过的问题，可以先简化，然后在推广。假设路径必须从root开始，那很简单。<br>如果路径可以从任意节点开始，那么我们需要向上检查是否得到了相符的总和，而不能假定root是起点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">findSum</span><span class="params">(TreeNode* root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">    <span class="type">int</span> depth = depth(root);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">path</span><span class="params">(depth)</span>;</span><br><span class="line">    findSum(root, sum, path, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">depth</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> max(depth(root-&gt;left), depth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">findSum</span><span class="params">(TreeNode* root, <span class="type">int</span> sum, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; path, <span class="type">int</span> level)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    path[level] = root-&gt;val;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = level, t= <span class="number">0</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        t += path[i];</span><br><span class="line">        <span class="keyword">if</span> (t == sum)</span><br><span class="line">            print(path, i ,level); <span class="comment">// printing out path from i to level</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    findSum(root-&gt;left, sum, path, level + <span class="number">1</span>);</span><br><span class="line">    findSum(root-&gt;right, sum, path, level + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-1-给定一个数n，和另一个数字m，然后给定区间-i-j-，区间保证可以大于m的二进制长度，把m的二进制表示插入到n的区间内"><a href="#5-1-给定一个数n，和另一个数字m，然后给定区间-i-j-，区间保证可以大于m的二进制长度，把m的二进制表示插入到n的区间内" class="headerlink" title="5.1 给定一个数n，和另一个数字m，然后给定区间(i, j)，区间保证可以大于m的二进制长度，把m的二进制表示插入到n的区间内"></a>5.1 给定一个数n，和另一个数字m，然后给定区间(i, j)，区间保证可以大于m的二进制长度，把m的二进制表示插入到n的区间内</h2><p>示例：n&#x3D;100&#x2F;000&#x2F;00, m &#x3D; 101, i &#x3D; 2, j &#x3D; 4 -&gt; 100&#x2F;101&#x2F;00</p>
<ol>
<li>把n中对应位置清零</li>
<li>把m移动到对应的位置</li>
<li>合并</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left_mask = ~<span class="number">0</span> &lt;&lt; (j+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> right_mask = (<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span></span><br><span class="line">    <span class="type">int</span> mask = left_mask | right_mask;</span><br><span class="line"></span><br><span class="line">    n &amp;= mask;</span><br><span class="line">    m &lt;&lt;= i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n | m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-2-给定一个0和1之间的实数，打印他的二进制表示，如果32位以内无法表示，打印error"><a href="#5-2-给定一个0和1之间的实数，打印他的二进制表示，如果32位以内无法表示，打印error" class="headerlink" title="5.2 给定一个0和1之间的实数，打印他的二进制表示，如果32位以内无法表示，打印error"></a>5.2 给定一个0和1之间的实数，打印他的二进制表示，如果32位以内无法表示，打印error</h2><p>我们知道 (0.101)2 &#x3D; 1 * 2^-1 + 0 * 2^-2 + 1 * 2^-3，我们只要让这个数字不断的乘2，然后看它是否大于1，然后就可以得到第一位是不是1了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">printBinary</span><span class="params">(<span class="type">double</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &gt;= <span class="number">1</span> || num &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line"></span><br><span class="line">    string result;</span><br><span class="line">    result += <span class="string">&quot;.&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (result.<span class="built_in">size</span>() &gt;= <span class="number">32</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">        num *= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (num &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            result += <span class="string">&quot;1&quot;</span>;</span><br><span class="line">            num -= <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result += <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-3-给定一个正整数，找出和其二进制表示中一的数字相同的数字，并且最接近，一共两个"><a href="#5-3-给定一个正整数，找出和其二进制表示中一的数字相同的数字，并且最接近，一共两个" class="headerlink" title="5.3 给定一个正整数，找出和其二进制表示中一的数字相同的数字，并且最接近，一共两个"></a>5.3 给定一个正整数，找出和其二进制表示中一的数字相同的数字，并且最接近，一共两个</h2><p>我们需要把某个0反转为1，把某个1反转为0。<br>0 -&gt; 1在1-&gt;0 左边，数字变大，在右边数字变小。<br>如果想变大，反转的0需要在1的左边。</p>
<p>把p位置1；把0到p之间请0；在添加ending1 - 1个1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getNext</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> c = n, ending0 = <span class="number">0</span>, ending1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((c &amp; <span class="number">1</span> == <span class="number">0</span>) &amp;&amp; c != <span class="number">0</span>) &#123;</span><br><span class="line">        ending0++;</span><br><span class="line">        c &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (c &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        ending1++;</span><br><span class="line">        c &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n + (<span class="number">1</span> &lt;&lt; ending0) + (<span class="number">1</span> &lt;&lt; (ending1 - <span class="number">1</span>)) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把位p值0；把位p右边的位值1，再把0到ending0-1置0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getPrev</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> c = n, ending0 = <span class="number">0</span>, ending1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (c &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        ending1++;</span><br><span class="line">        c &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((c &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; c != <span class="number">0</span>) &#123;</span><br><span class="line">        ending0++;</span><br><span class="line">        c &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n - (<span class="number">1</span> &lt;&lt; ending1) - (<span class="number">1</span> &lt;&lt; (ending0 - <span class="number">1</span>)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-4-解释n-amp-n-10-0"><a href="#5-4-解释n-amp-n-10-0" class="headerlink" title="5.4 解释n &amp; (n-10) == 0"></a>5.4 解释<code>n &amp; (n-10) == 0</code></h2><p>LeetCode 231</p>
<h2 id="5-5-A和B之间有多少位不相同-x2F-需要改变多少位，才能把A变成B"><a href="#5-5-A和B之间有多少位不相同-x2F-需要改变多少位，才能把A变成B" class="headerlink" title="5.5 A和B之间有多少位不相同&#x2F;需要改变多少位，才能把A变成B"></a>5.5 A和B之间有多少位不相同&#x2F;需要改变多少位，才能把A变成B</h2><p>使用XOR找出不同的位，然后统计1的个位数。需要注意的是不同的题目</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bitSwapRequired</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> diff = a ^ b, count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (diff) &#123;</span><br><span class="line">        diff &amp;= diff - <span class="number">1</span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-6-交换一个整数的奇数位和偶数位"><a href="#5-6-交换一个整数的奇数位和偶数位" class="headerlink" title="5.6 交换一个整数的奇数位和偶数位"></a>5.6 交换一个整数的奇数位和偶数位</h2><p>这道题很有趣，选取特殊的掩码即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 考虑32bit int</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">swapBits</span><span class="params">(<span class="type">int32_t</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int32_t</span> odd_bits = x &amp; <span class="number">0xAAAAAAAA</span>; <span class="comment">// 0xAA as 10101010</span></span><br><span class="line">    <span class="type">int32_t</span> even_bits = x &amp; <span class="number">0x55555555</span>; <span class="comment">// 0x55 as 01010101</span></span><br><span class="line">    <span class="keyword">return</span> (odd_bits &gt;&gt; <span class="number">1</span>) | (even_bits &lt;&lt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-8-单色屏幕存贮在一维字节数组中，每个字节存储八个像素，屏幕宽度为w-px，绘制从x1到达x2的水平线"><a href="#5-8-单色屏幕存贮在一维字节数组中，每个字节存储八个像素，屏幕宽度为w-px，绘制从x1到达x2的水平线" class="headerlink" title="5.8 单色屏幕存贮在一维字节数组中，每个字节存储八个像素，屏幕宽度为w px，绘制从x1到达x2的水平线"></a>5.8 单色屏幕存贮在一维字节数组中，每个字节存储八个像素，屏幕宽度为w px，绘制从x1到达x2的水平线</h2><p>显然可以逐bit设定，然而这样是拿不到offer的。更好的做法是逐字节设定。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">drawHorizentalLine</span><span class="params">(<span class="type">uint8_t</span> * screen, <span class="type">int</span> width, <span class="type">int</span> x1, <span class="type">int</span> x2, <span class="type">int</span> y)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> start_offset = x1 % <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> start_full_byte = x1 / <span class="number">8</span>; <span class="comment">// x1 所在字节</span></span><br><span class="line">    <span class="keyword">if</span> (start_offset != <span class="number">0</span>)</span><br><span class="line">        start_full_byte++;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> end_offset = x2 % <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> end_full_byte = x2 / <span class="number">8</span>; <span class="comment">// x2 所在字节</span></span><br><span class="line">    <span class="keyword">if</span> (end_offset != <span class="number">7</span>)</span><br><span class="line">        end_full_byte--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐字节设定</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start_full_byte; i &lt;= end_full_byte; i++)</span><br><span class="line">        screen[width / <span class="number">8</span> * y + i] = (<span class="type">uint8_t</span>)<span class="number">0xff</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> start_mask = (<span class="type">uint8_t</span>) (<span class="number">0xff</span> &gt;&gt; start_offset);</span><br><span class="line">    <span class="type">uint8_t</span> end_mast = (<span class="type">uint8_t</span>) ~(<span class="number">0xff</span> &gt;&gt; end_offset + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((x1 / <span class="number">8</span>) == (x2 / <span class="number">8</span>)) &#123;</span><br><span class="line">        <span class="type">uint8_t</span> mask = (<span class="type">uint8_t</span>)(start_mask &amp; end_mask);</span><br><span class="line">        screen[(width / <span class="number">8</span>) * y + x1 / <span class="number">8</span>] |= mask;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (start_offset != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> byte_number = (width / <span class="number">8</span>) * y + start_full_byte - <span class="number">1</span>;</span><br><span class="line">            screen[byte_number] |= start_mask;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end_offset != <span class="number">7</span>) &#123;</span><br><span class="line">            <span class="type">int</span> byte_number = (width / <span class="number">8</span>) * y + end_full_byte + <span class="number">1</span>;</span><br><span class="line">            screen[byte_number] |= end_mask;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="6-1-给定直角坐标系的两条线，确定他们会不会相交"><a href="#6-1-给定直角坐标系的两条线，确定他们会不会相交" class="headerlink" title="6.1 给定直角坐标系的两条线，确定他们会不会相交"></a>6.1 给定直角坐标系的两条线，确定他们会不会相交</h2><p>我们知道在二维平面上两条线的关系不外乎：平行，相交，重合。问题是两条线重合算不算相交呢，需要问清楚。<br>对于两条线如何表示，这又是面向对象设计的问题，需要讨论。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Line</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">double</span> EPSILON;</span><br><span class="line">    <span class="type">double</span> m_slope; <span class="comment">// 斜率</span></span><br><span class="line">    <span class="type">double</span> m_y_intercept; <span class="comment">// y轴交点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Line</span>(<span class="type">double</span> s, <span class="type">double</span> y): <span class="built_in">m_slope</span>(s), <span class="built_in">m_y_intercept</span>(y) &#123;&#125;;</span><br><span class="line">    <span class="comment">// 重合视作相交</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">intersect</span><span class="params">(<span class="type">const</span> Line&amp; other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(<span class="built_in">slope</span>() - other.<span class="built_in">slope</span>()) &gt; EPSILON || <span class="comment">// 斜率不同</span></span><br><span class="line">            <span class="built_in">abs</span>(<span class="built_in">y_intercept</span>() - other.<span class="built_in">y_intercept</span>()) &lt; EPSILON; <span class="comment">// y轴交点相同</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">slope</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> m_slope;&#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">y_intercept</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> m_y_intercept;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> Line::EPSILON = <span class="number">0.00001</span>;</span><br></pre></td></tr></table></figure>

<p>遇到这类问题，务必：</p>
<ol>
<li>多问，面试官可能故意模糊问题</li>
<li>仔细设计数据结构，权衡利弊，和面试官讨论</li>
<li>千万不要用＝＝判定浮点数</li>
</ol>
<h2 id="6-2-只使用加号实现减法和乘除法"><a href="#6-2-只使用加号实现减法和乘除法" class="headerlink" title="6.2 只使用加号实现减法和乘除法"></a>6.2 只使用加号实现减法和乘除法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">neg</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> d = a &lt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (a) &#123;</span><br><span class="line">        result += d;</span><br><span class="line">        a += d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">abs</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; <span class="number">0</span> ? a : neg(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">minus</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + neg(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sign = (a &gt; <span class="number">0</span>) == (b &gt; <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    a = <span class="built_in">abs</span>(a);</span><br><span class="line">    b = <span class="built_in">abs</span>(b);</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (b--)</span><br><span class="line">        result += a;</span><br><span class="line">    <span class="keyword">return</span> sign == <span class="number">1</span> ? result : neg(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">devide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="comment">// see leetcode</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-3-找出第k个丑数"><a href="#6-3-找出第k个丑数" class="headerlink" title="6.3 找出第k个丑数"></a>6.3 找出第k个丑数</h2><p>LeetCode 264</p>
<h2 id="7-1-小孩上楼梯，楼梯有n阶，小孩可以一次上1，2，3步，请问一共有多少种方法"><a href="#7-1-小孩上楼梯，楼梯有n阶，小孩可以一次上1，2，3步，请问一共有多少种方法" class="headerlink" title="7.1 小孩上楼梯，楼梯有n阶，小孩可以一次上1，2，3步，请问一共有多少种方法"></a>7.1 小孩上楼梯，楼梯有n阶，小孩可以一次上1，2，3步，请问一共有多少种方法</h2><p> 注意如果只能1或2就是斐波那契数列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countSteps</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> vector&lt;<span class="type">int</span>&gt; <span class="title">steps</span><span class="params">(<span class="number">1000</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span> &amp;&amp; steps[n] == <span class="number">1</span>)</span><br><span class="line">        steps[n] = <span class="built_in">countSteps</span>(n <span class="number">-1</span>) + <span class="built_in">countSteps</span>(n - <span class="number">2</span>) + <span class="built_in">countSteps</span>(n - <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> steps[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">countSteps</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n3 = <span class="number">1</span>; <span class="comment">// starts from n = 0</span></span><br><span class="line">    <span class="type">int</span> n2 = <span class="number">1</span>; <span class="comment">// starts from n = 1</span></span><br><span class="line">    <span class="type">int</span> n1 = <span class="number">2</span>; <span class="comment">// starts from n = 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> steps = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        steps = n3 + n2 + n1;</span><br><span class="line">        n3 = n2;</span><br><span class="line">        n2 = n1;</span><br><span class="line">        n1 = steps;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> steps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-1-设计一种算法，机器人只能向右向下移动，从-0-0-移动到-x-y-有几种走法"><a href="#8-1-设计一种算法，机器人只能向右向下移动，从-0-0-移动到-x-y-有几种走法" class="headerlink" title="8.1 设计一种算法，机器人只能向右向下移动，从(0, 0)移动到(x, y)有几种走法"></a>8.1 设计一种算法，机器人只能向右向下移动，从(0, 0)移动到(x, y)有几种走法</h2><p>LeetCode 62 63</p>
<h2 id="9-1-在有序数组A-0…n-1-中存在A-i-x3D-x3D-i，找出该数字。如果存在重复值，又该如何做"><a href="#9-1-在有序数组A-0…n-1-中存在A-i-x3D-x3D-i，找出该数字。如果存在重复值，又该如何做" class="headerlink" title="9.1 在有序数组A[0…n-1]中存在A[i] &#x3D;&#x3D; i，找出该数字。如果存在重复值，又该如何做"></a>9.1 在有序数组A[0…n-1]中存在A[i] &#x3D;&#x3D; i，找出该数字。如果存在重复值，又该如何做</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">magic</span><span class="params">(<span class="type">int</span>* A, n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>; right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (A[mid] == mid)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A[mid] &lt; mid)</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-2-返回一个集合的所有子集"><a href="#9-2-返回一个集合的所有子集" class="headerlink" title="9.2 返回一个集合的所有子集"></a>9.2 返回一个集合的所有子集</h2><p>LeetCode 78</p>
<h2 id="9-3-全排列"><a href="#9-3-全排列" class="headerlink" title="9.3 全排列"></a>9.3 全排列</h2><p>LeetCode</p>
<h2 id="9-4-生成n对括号的全部有效集合"><a href="#9-4-生成n对括号的全部有效集合" class="headerlink" title="9.4 生成n对括号的全部有效集合"></a>9.4 生成n对括号的全部有效集合</h2><p>LeetCode</p>
<h2 id="9-5-实现填充颜色功能"><a href="#9-5-实现填充颜色功能" class="headerlink" title="9.5 实现填充颜色功能"></a>9.5 实现填充颜色功能</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">paintFill</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; screen, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> color)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (screen[y][x] == color)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">paintFill</span>(screen, <span class="type">int</span> x, <span class="type">int</span> y, screen[y][x], <span class="type">int</span> color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">paintFill</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; screen, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> start, <span class="type">int</span> color)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= screen[<span class="number">0</span>].<span class="built_in">size</span>() || y &lt; <span class="number">0</span> || y &gt;= screen.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (screen[y][x] == start) &#123;</span><br><span class="line">        screen[y][x] == color;</span><br><span class="line">        <span class="built_in">paintFill</span>(screen, <span class="type">int</span> x<span class="number">-1</span>, <span class="type">int</span> y, start, color);</span><br><span class="line">        <span class="built_in">paintFill</span>(screen, x+<span class="number">1</span>, y, start, color);</span><br><span class="line">        <span class="built_in">paintFill</span>(screen, x, y+<span class="number">1</span>, start, color);</span><br><span class="line">        <span class="built_in">paintFill</span>(screen, x, y<span class="number">-1</span>, start, color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-6-给定数量不限的硬币，编写代码计算有几种表示方法"><a href="#9-6-给定数量不限的硬币，编写代码计算有几种表示方法" class="headerlink" title="9.6 给定数量不限的硬币，编写代码计算有几种表示方法"></a>9.6 给定数量不限的硬币，编写代码计算有几种表示方法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">makeChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; coins, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">solution</span><span class="params">(coins.size(), <span class="number">0</span>)</span></span><br><span class="line">    <span class="title function_">make</span><span class="params">(result, coins, solution, <span class="number">0</span>, target)</span>;</span><br><span class="line">    <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">make</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt;&amp; result, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; coins, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; solution, <span class="type">int</span> start, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (target &lt;= <span class="number">0</span> || start &gt;= coins.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>)</span><br><span class="line">            result.push_back(solution);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i *coins[start] &lt; target ; i++) &#123;</span><br><span class="line">        solution[start] = i;</span><br><span class="line">        make(result, coins, solution, start + <span class="number">1</span>, target - i * coins[start]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="9-7-N-Queen问题"><a href="#9-7-N-Queen问题" class="headerlink" title="9.7 N-Queen问题"></a>9.7 N-Queen问题</h2><p>LeetCode</p>
<h2 id="9-8-给你一堆箱子，上面的箱子的长宽高要求小于下面的箱子，实现一个方法，搭出最高的箱子"><a href="#9-8-给你一堆箱子，上面的箱子的长宽高要求小于下面的箱子，实现一个方法，搭出最高的箱子" class="headerlink" title="9.8 给你一堆箱子，上面的箱子的长宽高要求小于下面的箱子，实现一个方法，搭出最高的箱子"></a>9.8 给你一堆箱子，上面的箱子的长宽高要求小于下面的箱子，实现一个方法，搭出最高的箱子</h2><h2 id="10-1-合并两个有序数组"><a href="#10-1-合并两个有序数组" class="headerlink" title="10.1 合并两个有序数组"></a>10.1 合并两个有序数组</h2><p>LeetCode 88</p>
<h2 id="11-1-对一个字符串数组排序，把变位词-Anagram-放在一起"><a href="#11-1-对一个字符串数组排序，把变位词-Anagram-放在一起" class="headerlink" title="11.1 对一个字符串数组排序，把变位词(Anagram)放在一起"></a>11.1 对一个字符串数组排序，把变位词(Anagram)放在一起</h2><p>LeetCode 49</p>
<h2 id="11-2-在已经被旋转过的排序数组中，查找元素"><a href="#11-2-在已经被旋转过的排序数组中，查找元素" class="headerlink" title="11.2 在已经被旋转过的排序数组中，查找元素"></a>11.2 在已经被旋转过的排序数组中，查找元素</h2><p>LeetCode 81</p>
<h2 id="11-3-有一个20GB的文件，每行一个字符串，如何排序"><a href="#11-3-有一个20GB的文件，每行一个字符串，如何排序" class="headerlink" title="11.3 有一个20GB的文件，每行一个字符串，如何排序"></a>11.3 有一个20GB的文件，每行一个字符串，如何排序</h2><p>20GB暗示无法放入内存中，把文件分块后，分别载入内存中，采用归并排序</p>
<h2 id="12-1-使用-C-写个方法，打印输入文件的最后-K-行"><a href="#12-1-使用-C-写个方法，打印输入文件的最后-K-行" class="headerlink" title="12.1 使用 C++ 写个方法，打印输入文件的最后 K 行"></a>12.1 使用 C++ 写个方法，打印输入文件的最后 K 行</h2><p>使用循环数组，容量设为 K，同时记录当前的最早元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printLastKLines</span><span class="params">(<span class="type">char</span>* filename)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> K = <span class="number">10</span>;</span><br><span class="line">    <span class="function">ifstream <span class="title">file</span><span class="params">(filename)</span></span>;</span><br><span class="line">    string lines[K];</span><br><span class="line">    <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (file.<span class="built_in">good</span>())</span><br><span class="line">        <span class="built_in">getline</span>(file, lines[size++ % K];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> start = size &gt; K ? (size % K) : <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="built_in">min</span>(K, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) </span><br><span class="line">        cout &lt;&lt; lines[(start + i) % K] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="12-2-编写malloc-aligned"><a href="#12-2-编写malloc-aligned" class="headerlink" title="12.2 编写malloc_aligned"></a>12.2 编写malloc_aligned</h2><h2 id="12-3-malloc2d函数，分配二维数组，返回int-可以通过a-i-j-访问，并且尽量少调用malloc"><a href="#12-3-malloc2d函数，分配二维数组，返回int-可以通过a-i-j-访问，并且尽量少调用malloc" class="headerlink" title="12.3 malloc2d函数，分配二维数组，返回int**可以通过a[i][j]访问，并且尽量少调用malloc"></a>12.3 malloc2d函数，分配二维数组，返回int**可以通过a[i][j]访问，并且尽量少调用malloc</h2><p>前面rows大小的区域用作存储指针，后面存储数据。</p>
<pre><code>hhh|ddddd|ddddd|ddddd
</code></pre>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>** <span class="title function_">malloc2d</span><span class="params">(<span class="type">int</span> rows, <span class="type">int</span> cols)</span> &#123;</span><br><span class="line">    <span class="type">int</span> header = rows * <span class="keyword">sizeof</span>(<span class="type">void</span>*);</span><br><span class="line">    <span class="type">void</span>** ptr = (<span class="type">void</span>**)<span class="built_in">malloc</span>(header + rows * cols);</span><br><span class="line">    <span class="keyword">if</span> (!ptr)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">void</span>* buf = (<span class="type">void</span>*)(rawptr + rows);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line">         ptr[i] = buf + i * cols;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">free2d</span><span class="params">(<span class="type">void</span>** ptr)</span> &#123;</span><br><span class="line">    <span class="type">void</span>* p = <span class="type">void</span>* p;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="12-4-不用中间变量，直接交换两个数字"><a href="#12-4-不用中间变量，直接交换两个数字" class="headerlink" title="12.4 不用中间变量，直接交换两个数字"></a>12.4 不用中间变量，直接交换两个数字</h2><p>想像把 a 和 b 都放在数轴上，假设 a0，b0分别是初值，那么有 diff &#x3D; a - b。我们把<br>diff 保存在 a 中，然后 b &#x3D; b0 + diff 也就是 a0 ，而再另 a &#x3D; b - diff，也就是 b0。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    a = a - b;</span><br><span class="line">    b = b + a;</span><br><span class="line">    a = b - a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更巧妙的是，我们还可以使用异或 XOR 在解。假设 a &#x3D; a0 ^ b0，那么 b &#x3D; a ^ b0 &#x3D; a0 ^ b0 ^ b0 &#x3D; a0，然后 a &#x3D; a ^ b &#x3D; a0 ^ b0 ^ a0 &#x3D; b0。完美解决！<br>值得注意的是，因为使用异或不考虑变量的实际类型，只是粗暴地按 bit 位交换，因此适用于各种类型。不过值得注意的是千万不要用这种方法去交换变量的值，当x&#x3D;&#x3D;y的时候会有灾难性后果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">    a ^= b;</span><br><span class="line">    b ^= a;</span><br><span class="line">    a ^= b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="13-1-n-结尾有多少个零"><a href="#13-1-n-结尾有多少个零" class="headerlink" title="13.1 n! 结尾有多少个零"></a>13.1 n! 结尾有多少个零</h2><p>LeetCode 172</p>
<h2 id="13-2-找出两个数字中较大的一个，但不得使用判断语句"><a href="#13-2-找出两个数字中较大的一个，但不得使用判断语句" class="headerlink" title="13.2 找出两个数字中较大的一个，但不得使用判断语句"></a>13.2 找出两个数字中较大的一个，但不得使用判断语句</h2><p>判断a&gt;b就是判断a-b的正负号，显然我们可以使用bit运算</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">flip</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123; <span class="comment">// flip last bit</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ^ a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sign</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">flip</span>((a &gt;&gt; <span class="number">31</span>) &amp; <span class="number">0x1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="13-3-把数字转换为英文单词"><a href="#13-3-把数字转换为英文单词" class="headerlink" title="13.3 把数字转换为英文单词"></a>13.3 把数字转换为英文单词</h2><h2 id="13-4-把数字转换为汉语句子"><a href="#13-4-把数字转换为汉语句子" class="headerlink" title="13.4 把数字转换为汉语句子"></a>13.4 把数字转换为汉语句子</h2><h2 id="13-5-数组最大序列和"><a href="#13-5-数组最大序列和" class="headerlink" title="13.5 数组最大序列和"></a>13.5 数组最大序列和</h2><p>LeetCode 53</p>
<h2 id="13-6-给定产生数字概率相同的rand5-，实现一个方法rand7-，要求产生每个数字的概率相同"><a href="#13-6-给定产生数字概率相同的rand5-，实现一个方法rand7-，要求产生每个数字的概率相同" class="headerlink" title="13.6 给定产生数字概率相同的rand5()，实现一个方法rand7()，要求产生每个数字的概率相同"></a>13.6 给定产生数字概率相同的rand5()，实现一个方法rand7()，要求产生每个数字的概率相同</h2><p>扩大rand5产生随机数的范围，然后对舍去一定范围的数字，对剩下的数字取模，虽然这样会导致调用次数不固定，但实现了效果<br>对于randx，扩大范围的方法是 x * randx() + randx()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rand7</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">5</span> * rand5() + rand5();</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">21</span>)</span><br><span class="line">            <span class="keyword">return</span> num % <span class="number">7</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该问题可以拓展到对于 x &lt; y，由randx() 构造 randy()</p>
<h2 id="13-7-在数组中找到两个数字，是的他们的和为指定的数字"><a href="#13-7-在数组中找到两个数字，是的他们的和为指定的数字" class="headerlink" title="13.7 在数组中找到两个数字，是的他们的和为指定的数字"></a>13.7 在数组中找到两个数字，是的他们的和为指定的数字</h2><p>LeetCode 1</p>
<h2 id="13-8-把二叉树转化为双向链表"><a href="#13-8-把二叉树转化为双向链表" class="headerlink" title="13.8 把二叉树转化为双向链表"></a>13.8 把二叉树转化为双向链表</h2><p>先把二叉树变成一个环形链表，然后再从头部解开即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">concat</span><span class="params">(<span class="keyword">struct</span> tree_node* x, <span class="keyword">struct</span> tree_node* y)</span> &#123;</span><br><span class="line">    x-&gt;right = y;</span><br><span class="line">    y-&gt;left = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> tree_node* <span class="title function_">convert_circular</span><span class="params">(<span class="keyword">struct</span> tree_node* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tree_node</span>* <span class="title">left</span> =</span> convert_circular(root-&gt;left);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tree_node</span>* <span class="title">right</span> =</span> convert_circular(root-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!left &amp;&amp; !right) &#123;</span><br><span class="line">        root-&gt;left = root;</span><br><span class="line">        root-&gt;right = root;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tree_node</span>* <span class="title">tail_right</span> =</span> right ? right-&gt;left : <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把左边添加到根部</span></span><br><span class="line">    <span class="keyword">if</span> (!left)</span><br><span class="line">        concat(right-&gt;left, root);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        concat(left-&gt;left, root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把右边添加到根部</span></span><br><span class="line">    <span class="keyword">if</span> (!right)</span><br><span class="line">        concat(root, left);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        concat(root, right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把右边和左边链接</span></span><br><span class="line">    <span class="keyword">if</span> (left &amp;&amp; right)</span><br><span class="line">        concat(tail_right, left);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left ? left : root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> tree_node* <span class="title function_">convert</span><span class="params">(<span class="keyword">struct</span> tree_node* root)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tree_node</span>* <span class="title">head</span> =</span> convert_circular(root);</span><br><span class="line">    head-&gt;left-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    head-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="14-2-实现加法"><a href="#14-2-实现加法" class="headerlink" title="14.2 实现加法"></a>14.2 实现加法</h2><p>显然是使用位运算。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int add(int a, int b) &#123;</span><br><span class="line">    while (b) &#123;</span><br><span class="line">        int sum = a ^ b;</span><br><span class="line">        int carry = (a &amp; b) &lt;&lt; 1;</span><br><span class="line">        a = sum, b = carry;</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-2-完美洗牌，使得一副牌中任意一种排列出现的概率都相等"><a href="#15-2-完美洗牌，使得一副牌中任意一种排列出现的概率都相等" class="headerlink" title="15.2 完美洗牌，使得一副牌中任意一种排列出现的概率都相等"></a>15.2 完美洗牌，使得一副牌中任意一种排列出现的概率都相等</h2><p>显然全排列是n!个，那么我们保证每一个全排列都可能出现就好了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">shuffle</span><span class="params">(<span class="type">int</span>* A, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> k = rand(i);</span><br><span class="line">        swap(A[k], A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="16-1-从n个数组中选出m个，要求被选中概率一样"><a href="#16-1-从n个数组中选出m个，要求被选中概率一样" class="headerlink" title="16.1 从n个数组中选出m个，要求被选中概率一样"></a>16.1 从n个数组中选出m个，要求被选中概率一样</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">pink_k</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">result</span><span class="params">(k)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="16-2-小于-n-的数字中出现2的个数"><a href="#16-2-小于-n-的数字中出现2的个数" class="headerlink" title="16.2 小于 n 的数字中出现2的个数"></a>16.2 小于 n 的数字中出现2的个数</h2><h2 id="16-3-矩阵链乘法问题"><a href="#16-3-矩阵链乘法问题" class="headerlink" title="16.3 矩阵链乘法问题"></a>16.3 矩阵链乘法问题</h2><h2 id="16-4-判断是否是合法地出栈序列"><a href="#16-4-判断是否是合法地出栈序列" class="headerlink" title="16.4 判断是否是合法地出栈序列"></a>16.4 判断是否是合法地出栈序列</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/The_star_is_at/article/details/72790961">参考</a></p>
<h2 id="16-5-二叉树的非递归遍历"><a href="#16-5-二叉树的非递归遍历" class="headerlink" title="16.5 二叉树的非递归遍历"></a>16.5 二叉树的非递归遍历</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dolphin0520/archive/2011/08/25/2153720.html">参考</a></p>
<br>
<br>
<br>
<br>
<br>


<h1 id="三、树的遍历"><a href="#三、树的遍历" class="headerlink" title="三、树的遍历"></a>三、树的遍历</h1><p>树的递归遍历都非常简单，但是非递归遍历有时候不是很简单。一般做题的时候直接写递归版就行了，<br>但是对于三个基础的遍历方法，有时候会要求写迭代版本，基本就是花式用栈就行了。</p>
<h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><h3 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> [root.val, *self.preorderTraversal(root.left), *self.preorderTraversal(root.right)]</span><br></pre></td></tr></table></figure>

<h3 id="非递归版"><a href="#非递归版" class="headerlink" title="非递归版"></a>非递归版</h3><p>使用栈做了一个顺序的反转。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans = []</span><br><span class="line">        stack = []</span><br><span class="line">        stack.append(root)</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            ans.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><h3 id="递归版-1"><a href="#递归版-1" class="headerlink" title="递归版"></a>递归版</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> [*self.inorderTraversal(root.left), root.val, *self.inorderTraversal(root.right)]</span><br></pre></td></tr></table></figure>

<h3 id="非递归版-1"><a href="#非递归版-1" class="headerlink" title="非递归版"></a>非递归版</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans = []</span><br><span class="line">        stack = []</span><br><span class="line">        node = root</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> node:</span><br><span class="line">            <span class="keyword">while</span> node:</span><br><span class="line">                stack.append(node)</span><br><span class="line">                node = node.left</span><br><span class="line">            left = stack.pop()</span><br><span class="line">            ans.append(left.val)</span><br><span class="line">            <span class="keyword">if</span> left.right:</span><br><span class="line">                node = left.right</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="后续遍历"><a href="#后续遍历" class="headerlink" title="后续遍历"></a>后续遍历</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">LeetCode 145</a></p>
<h3 id="递归版-2"><a href="#递归版-2" class="headerlink" title="递归版"></a>递归版</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> [*self.postorderTraversal(root.left), *self.postorderTraversal(root.right), root.val]</span><br></pre></td></tr></table></figure>

<h3 id="非递归版-2"><a href="#非递归版-2" class="headerlink" title="非递归版"></a>非递归版</h3><p>这个方法还是有点 trick 的，类似于前序遍历，但是把左右子树反过来了，最后再翻转一遍，就变成<br>了后序遍历。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   3</span><br></pre></td></tr></table></figure>

<p>比如：前序遍历是 123, 现在这种遍历方式是 132, 在翻转一次正好是 231, 也就是后续遍历了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans = []</span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            ans.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">reversed</span>(ans))</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/leetcodesuan-fa-xiu-lian-dong-hua-yan-shi-xbian-2/">https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/leetcodesuan-fa-xiu-lian-dong-hua-yan-shi-xbian-2/</a></li>
</ol>
<br>
<br>
<br>
<br>
<br>






<h1 id="四、LeetCode-突击手册"><a href="#四、LeetCode-突击手册" class="headerlink" title="四、LeetCode 突击手册"></a>四、LeetCode 突击手册</h1><p>一共定义了几个标签，可以通过 Ctrl+F&#x2F;Cmd+F 搜索这些标签还快速浏览相同的题目。</p>
<p>标签：#hash #backtracking #slidewindow #stack #queue #pointers</p>
<h2 id="1-从数组中找出两个数字使得他们的和是给定的数字"><a href="#1-从数组中找出两个数字使得他们的和是给定的数字" class="headerlink" title="1 从数组中找出两个数字使得他们的和是给定的数字"></a>1 从数组中找出两个数字使得他们的和是给定的数字</h2><p>tags: #hash</p>
<p>使用一个散列，存储数字和他对应的索引。然后遍历数组，如果另一半在散列当中，那么返回<br>这两个数的索引，程序结束；如果不在，把当前数字加入到散列中。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="type">int</span> reminder = target - nums[i];</span><br><span class="line">        <span class="keyword">if</span> (hash.<span class="built_in">find</span>(reminder) != hash.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            result[<span class="number">0</span>] = hash[reminder] + <span class="number">1</span>;</span><br><span class="line">            result[<span class="number">1</span>] = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        hash[nums[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        seen = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> target - num <span class="keyword">in</span> seen:</span><br><span class="line">                <span class="keyword">return</span> [seen[target-num], i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                seen[num] = i</span><br><span class="line">        <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>rust 解答</summary>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">two_sum</span>(nums: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;, target: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">with_capacity</span>(nums.<span class="title function_ invoke__">len</span>());</span><br><span class="line">        <span class="title function_ invoke__">for</span> (idx, num) <span class="keyword">in</span> nums.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">            <span class="keyword">match</span> map.<span class="title function_ invoke__">get</span>(&amp;(target - num)) &#123;</span><br><span class="line">                <span class="literal">None</span> =&gt; &#123;map.<span class="title function_ invoke__">insert</span>(num, idx);&#125;,</span><br><span class="line">                <span class="title function_ invoke__">Some</span>(sub_idx) =&gt; &#123;<span class="keyword">return</span> <span class="built_in">vec!</span>[*sub_idx <span class="keyword">as</span> <span class="type">i32</span>, idx <span class="keyword">as</span> <span class="type">i32</span>]; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vec!</span> []</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>go 解答</summary>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> index, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        last_index, ok := m[num]</span><br><span class="line">        <span class="keyword">if</span> ok &#123;</span><br><span class="line">            <span class="keyword">return</span> []<span class="type">int</span>&#123;last_index, index&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            m[target - num] = index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> []<span class="type">int</span>&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>Follow up: 如果数组是已经排序的呢？</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()) <span class="comment">// 假设已经排序，只有一个结果</span></span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> s = nums[left] + nums[right];</span><br><span class="line">        <span class="keyword">if</span> (s == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">make_pair</span>(left, right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &lt; sum)</span><br><span class="line">            left++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="2-给两个列表，数字在其中按低位到高位存储，求他们的和"><a href="#2-给两个列表，数字在其中按低位到高位存储，求他们的和" class="headerlink" title="2 给两个列表，数字在其中按低位到高位存储，求他们的和"></a>2 给两个列表，数字在其中按低位到高位存储，求他们的和</h2><p>直接迭代遍历数组，考察细节操作。注意 dummy head 的使用。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">addTwoNumbers</span><span class="params">(<span class="keyword">struct</span> ListNode* l1, <span class="keyword">struct</span> ListNode* l2)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>, *<span class="title">p</span> =</span> &amp;dummy;</span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 注意最后如果有 carry 的话，需要再生成一个节点</span></span><br><span class="line">    <span class="keyword">while</span> (l1 || l2 || carry) &#123;</span><br><span class="line">        <span class="type">int</span> v1 = l1 ? l1-&gt;val: <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> v2 = l2 ? l2-&gt;val: <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> v = v1 + v2 + carry;</span><br><span class="line">        p-&gt;next = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        p-&gt;val = v % <span class="number">10</span>;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        carry = v / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        l1 = l1 ? l1-&gt;next: <span class="literal">NULL</span>;</span><br><span class="line">        l2 = l2 ? l2-&gt;next: <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">ListNode *<span class="title">addTwoNumbers</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (l1 == <span class="literal">NULL</span>) <span class="keyword">return</span> l2;</span><br><span class="line">            <span class="keyword">if</span> (l2 == <span class="literal">NULL</span>) <span class="keyword">return</span> l1;</span><br><span class="line">            <span class="type">int</span> shift = <span class="number">0</span>;</span><br><span class="line">            ListNode* result = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">            ListNode* p = result;</span><br><span class="line">            <span class="keyword">while</span> (l1 != <span class="literal">NULL</span> || l2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                ListNode* newNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">                <span class="type">int</span> v1 = l1 != <span class="literal">NULL</span> ? l1-&gt;val : <span class="number">0</span>;</span><br><span class="line">                <span class="type">int</span> v2 = l2 != <span class="literal">NULL</span> ? l2-&gt;val : <span class="number">0</span>;</span><br><span class="line">                newNode-&gt;val = v1 + v2 + shift;</span><br><span class="line">                <span class="keyword">if</span> (newNode-&gt;val &gt; <span class="number">9</span>) &#123;</span><br><span class="line">                    newNode-&gt;val -= <span class="number">10</span>;</span><br><span class="line">                    shift = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    shift = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (l1) &#123;</span><br><span class="line">                    l1 = l1-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (l2) &#123;</span><br><span class="line">                    l2 = l2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                p-&gt;next = newNode;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 注意最后多余的一个进位处理</span></span><br><span class="line">            <span class="keyword">if</span> (shift == <span class="number">1</span>) &#123;</span><br><span class="line">                p-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>rust 解答</summary>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_two_numbers</span>(l1: <span class="type">Option</span>&lt;<span class="type">Box</span>&lt;ListNode&gt;&gt;, l2: <span class="type">Option</span>&lt;<span class="type">Box</span>&lt;ListNode&gt;&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">Box</span>&lt;ListNode&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> l1, <span class="keyword">mut</span> l2) = (l1, l2);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">dummy</span> = <span class="type">Box</span>&lt;ListNode::<span class="title function_ invoke__">new</span>(<span class="number">0</span>)&gt;;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">carry</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">p</span> = dummy;</span><br><span class="line">        <span class="keyword">while</span> l1.<span class="title function_ invoke__">is_some</span>() || l2.<span class="title function_ invoke__">is_some</span>() || carry != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">match</span> l1, l2&#123;</span><br><span class="line">                <span class="title function_ invoke__">Some</span>(a), <span class="title function_ invoke__">Some</span>(b) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = a + b + carry;</span><br><span class="line">                    l1 = l1.<span class="title function_ invoke__">next</span>();</span><br><span class="line">                    l2 = l2.<span class="title function_ invoke__">next</span>();</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="title function_ invoke__">Some</span>(a), <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">                    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = a + carry;</span><br><span class="line">                    l1 = l1.<span class="title function_ invoke__">next</span>();</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="literal">None</span>, <span class="title function_ invoke__">Some</span>(b) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = b + carry;</span><br><span class="line">                    l2 = l2.<span class="title function_ invoke__">next</span>();</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="literal">None</span>, <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p.next = <span class="title function_ invoke__">Some</span>(<span class="type">Box</span>&lt;ListNode::<span class="title function_ invoke__">new</span>(v)&gt;);</span><br><span class="line">            p = p.next;</span><br><span class="line">            p.val = v % <span class="number">10</span>;</span><br><span class="line">            carry = v / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dummy.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addTwoNumbers</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        p = dummy</span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2 <span class="keyword">or</span> carry:</span><br><span class="line">            <span class="keyword">if</span> l1:</span><br><span class="line">                v1 = l1.val</span><br><span class="line">                l1 = l1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                v1 = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> l2:</span><br><span class="line">                v2 = l2.val</span><br><span class="line">                l2 = l2.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                v2 = <span class="number">0</span></span><br><span class="line">            v = v1 + v2 + carry  <span class="comment"># 别忘了这里</span></span><br><span class="line">            <span class="keyword">if</span> v &gt;= <span class="number">10</span>:</span><br><span class="line">                carry = <span class="number">1</span></span><br><span class="line">                v -= <span class="number">10</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                carry = <span class="number">0</span></span><br><span class="line">            p.<span class="built_in">next</span> = ListNode(v)</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
</details>


<h2 id="3-最长不重复子串"><a href="#3-最长不重复子串" class="headerlink" title="3 最长不重复子串"></a>3 最长不重复子串</h2><p>tags: #slidewindow</p>
<p>滑动窗口解决</p>
<p>注意，当字符有限的时候，比如限定为 ASCII 字符，可以使用一个数组代替 Hash。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> indices[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)  <span class="comment">// init the array, memset can only be used for char</span></span><br><span class="line">        indices[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> longest = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; s[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        left = max(left, indices[s[i]] + <span class="number">1</span>);   <span class="comment">// 考虑新加入字符后对左边界的影响</span></span><br><span class="line">        indices[s[i]] = i;                     <span class="comment">// 更新元素上次出现位置</span></span><br><span class="line">        longest = max(longest, i - left + <span class="number">1</span>);  <span class="comment">// 应用动态规划</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> longest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        last_seen = &#123;&#125;</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        lo = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            lo = <span class="built_in">max</span>(lo, last_seen.get(c, -<span class="number">1</span>) + <span class="number">1</span>)  <span class="comment"># 更新下边界</span></span><br><span class="line">            last_seen[c] = i</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, i - lo + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>



<h2 id="4-找到两个排序数组的中位数"><a href="#4-找到两个排序数组的中位数" class="headerlink" title="4 找到两个排序数组的中位数"></a>4 找到两个排序数组的中位数</h2><p>解法参见<a target="_blank" rel="noopener" href="https://leetcode.com/discuss/15790/share-my-o-log-min-m-n-solution-with-explanation">这里</a></p>
<p>使用两个数字 i 和 j, 分别作为 AB 的分隔元素，把 AB 分成两份，比如<br><code>A[0..i]</code>, <code>B[0..j]</code> 和 <code>A[i, m]</code>, <code>B[j, n]</code>，这样我们只需要下面两个条件就可以了：</p>
<ul>
<li><code>i+j = m-i + n-j</code>, 也就是 <code>i+j = (m+n)/2</code></li>
<li><code>B[j-1] &lt;= A[i] &amp;&amp; A[i-1] &lt;= B[j]</code>,  B 的前一半元素小于 A 的分隔符，A 的前一半元素小于 B 的分隔符</li>
</ul>
<p>这时候我们就得到了 A[i] 就是我们的中位数，或者之一。 i 的初始值在 0 到 m 之间，<br>然后我们二分搜索 <code>i = (imin + imax) / 2, j = mid - i</code>。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> max(a,b) ((a)&gt;(b)?(a):(b))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> min(a,b) ((a)&lt;(b)?(a):(b))</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>* A, <span class="type">int</span> m, <span class="type">int</span>* B, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (m &gt; n) <span class="keyword">return</span> findMedianSortedArrays(B, n, A, m);</span><br><span class="line">    <span class="type">int</span> imin = <span class="number">0</span>, imax = m, i, j, num1, mid = (m + n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, num2;</span><br><span class="line">    <span class="keyword">while</span> (imin &lt;= imax) &#123;</span><br><span class="line">        i = (imin + imax) <span class="comment">// 2;</span></span><br><span class="line">        j = mid - i;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; m &amp;&amp; j &gt; <span class="number">0</span> &amp;&amp; B[j<span class="number">-1</span>] &gt; A[i]) &#123;  <span class="comment">// B 中的数字偏大</span></span><br><span class="line">            imin = i + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j &lt; n &amp;&amp; B[j] &lt; A[i<span class="number">-1</span>]) &#123; <span class="comment">// A 中的数字偏大</span></span><br><span class="line">            imax = i - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                num1 = B[j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                num1 = A[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                num1 = max(A[i<span class="number">-1</span>],B[j<span class="number">-1</span>]);  <span class="comment">// 普通情况</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((m + n) &amp; <span class="number">0x1</span>) <span class="comment">// odd</span></span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    <span class="keyword">if</span> (i == m)</span><br><span class="line">        num2 = B[j];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (j == n)</span><br><span class="line">        num2 = A[i];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        num2 = min(A[i], B[j]); <span class="comment">// 普通情况</span></span><br><span class="line">    <span class="keyword">return</span> (num1 + num2) / <span class="number">2.0</span>; <span class="comment">// 注意整数除法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5 最长回文子串"></a>5 最长回文子串</h2><ol>
<li>以某个元素为中心，向两边展开，注意处理奇数和偶数两种情况</li>
<li>Manacher 算法，参见<a target="_blank" rel="noopener" href="http://taop.marchtea.com/01.05.html">这里</a></li>
</ol>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        ans = <span class="string">&quot;&quot;</span></span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 奇数长度回文子串</span></span><br><span class="line">            <span class="keyword">while</span> i - j &gt;= <span class="number">0</span> <span class="keyword">and</span> i + j &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[i-j] == s[i+j]:</span><br><span class="line">                <span class="keyword">if</span> j * <span class="number">2</span> + <span class="number">1</span> &gt; length:</span><br><span class="line">                    length = j * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">                    ans = s[i-j:i+j+<span class="number">1</span>]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 偶数长度回文子串</span></span><br><span class="line">            <span class="keyword">while</span> i - j &gt;= <span class="number">0</span> <span class="keyword">and</span> i + j + <span class="number">1</span> &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[i-j] == s[i+j+<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">if</span> j * <span class="number">2</span> + <span class="number">2</span> &gt; length:</span><br><span class="line">                    length = j * <span class="number">2</span> + <span class="number">2</span></span><br><span class="line">                    ans = s[i-j:i+j+<span class="number">2</span>]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">longestPalindrome</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!s) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> length = <span class="number">0</span>; <span class="comment">// length of the longest palindromic string</span></span><br><span class="line">    <span class="type">int</span> start = <span class="number">-1</span>; <span class="comment">// start of the lonest palidromic string</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 奇数长度的回文子串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; (i - j &gt;= <span class="number">0</span>) &amp;&amp; (i + j &lt; len); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i - j] != s[i + j])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (j * <span class="number">2</span> + <span class="number">1</span> &gt; length) &#123;</span><br><span class="line">                length = j * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                start = i - j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 偶数长度的回文子串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; (i - j &gt;= <span class="number">0</span>) &amp;&amp; (i + j + <span class="number">1</span> &lt; len); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i - j] != s[i + j + <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (j * <span class="number">2</span> + <span class="number">2</span> &gt; length) &#123;</span><br><span class="line">                length = j * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">                start = i - j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* result = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * length + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strncpy</span>(result, s + start, length);</span><br><span class="line">    result[length] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="6-ZigZag-字符串，把字符串掰弯，然后再按行输出"><a href="#6-ZigZag-字符串，把字符串掰弯，然后再按行输出" class="headerlink" title="6 ZigZag 字符串，把字符串掰弯，然后再按行输出"></a>6 ZigZag 字符串，把字符串掰弯，然后再按行输出</h2><p>考察数学，找出规律，所以实际上并不是 Z 子形，而是由 V 组成的，然后组合按行号重构后的字符串即可。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法不容易理解，建议看 Python 的</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">convert</span><span class="params">(<span class="type">char</span>* s, <span class="type">int</span> numRows)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (!s || numRows &lt;= <span class="number">1</span> || len &lt; numRows) <span class="keyword">return</span> s; <span class="comment">// no need to convert</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* zigzag = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (len + <span class="number">1</span>));</span><br><span class="line">    <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; len; j += <span class="number">2</span> * (numRows - <span class="number">1</span>)) &#123; <span class="comment">// 每个 v 字型长度</span></span><br><span class="line">            zigzag[cur++] = s[j];</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; i != numRows - <span class="number">1</span>) &#123; <span class="comment">// 中间行有斜线</span></span><br><span class="line">                <span class="type">int</span> t = j + <span class="number">2</span> * (numRows - <span class="number">1</span>) - <span class="number">2</span> * i; <span class="comment">// V 的第二笔</span></span><br><span class="line">                <span class="keyword">if</span> (t &lt; len)</span><br><span class="line">                    zigzag[cur++] = s[t];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    zigzag[cur] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> zigzag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">convert</span>(<span class="params">self, s: <span class="built_in">str</span>, numRows: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">if</span> numRows &lt;= <span class="number">1</span> <span class="keyword">or</span> <span class="built_in">len</span>(s) &lt;= numRows:  <span class="comment"># 没有这个条件会超时</span></span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        interval = <span class="number">2</span> * numRows - <span class="number">2</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="comment"># 第一行</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            ans.append(s[j])</span><br><span class="line">            j += interval</span><br><span class="line">        <span class="comment"># 中间行</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, numRows-<span class="number">1</span>):</span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(s):</span><br><span class="line">                <span class="keyword">if</span> i + j &lt; <span class="built_in">len</span>(s):</span><br><span class="line">                    ans.append(s[i+j])</span><br><span class="line">                <span class="keyword">if</span> interval - i + j &lt; <span class="built_in">len</span>(s):  <span class="comment"># 一定要注意这里的索引</span></span><br><span class="line">                    ans.append(s[interval - i + j])</span><br><span class="line">                j += interval</span><br><span class="line">        <span class="comment"># 最后一行</span></span><br><span class="line">        j = numRows - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            ans.append(s[j])</span><br><span class="line">            j += interval</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(ans)</span><br></pre></td></tr></table></figure>
</details>


<h2 id="7-翻转数字，溢出返回-0"><a href="#7-翻转数字，溢出返回-0" class="headerlink" title="7 翻转数字，溢出返回 0"></a>7 翻转数字，溢出返回 0</h2><p>注意溢出</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == INT_MIN) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">return</span> -reverse(-x);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        result = result * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result &gt; INT_MAX ? <span class="number">0</span> : result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        sign = <span class="number">1</span> <span class="keyword">if</span> x &gt;= <span class="number">0</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        x *= sign</span><br><span class="line">        y = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> x &gt; <span class="number">0</span>:</span><br><span class="line">            y = y * <span class="number">10</span> + x % <span class="number">10</span></span><br><span class="line">            x //= <span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> y &gt; <span class="number">2</span>**<span class="number">31</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> y * sign</span><br></pre></td></tr></table></figure>
</details>


<h2 id="8-实现-atoi"><a href="#8-实现-atoi" class="headerlink" title="8 实现 atoi"></a>8 实现 atoi</h2><p>这道题考察各种细节，注意各种特殊情况：</p>
<ol>
<li>首先过滤空格</li>
<li>判定符号，符号只能出现一次</li>
<li>是否溢出，溢出返回 <code>INT_MAX</code> 或者 <code>INT_MIN</code></li>
</ol>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">myAtoi</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        s = s.lstrip()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        sign = <span class="number">1</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&quot;-&quot;</span>:</span><br><span class="line">            sign = -<span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> s[i] == <span class="string">&quot;+&quot;</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[i].isdigit():</span><br><span class="line">            ans = ans * <span class="number">10</span> + <span class="built_in">ord</span>(s[i]) - <span class="built_in">ord</span>(<span class="string">&quot;0&quot;</span>)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        ans *= sign</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">min</span>(ans, <span class="number">2</span>**<span class="number">31</span>-<span class="number">1</span>), - <span class="number">2</span> ** <span class="number">31</span>)</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">myAtoi</span><span class="params">(<span class="type">char</span>* str)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!str) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// discarding spaces</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isspace</span>(*str))</span><br><span class="line">        str++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// determining sign</span></span><br><span class="line">    <span class="keyword">if</span> (*str == <span class="string">&#x27;-&#x27;</span> || *str == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*str == <span class="string">&#x27;-&#x27;</span>) sign = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (*str == <span class="string">&#x27;+&#x27;</span>) sign = <span class="number">1</span>;</span><br><span class="line">        str++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructing integer</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(*str)) &#123;</span><br><span class="line">        <span class="comment">// handling overflow</span></span><br><span class="line">        <span class="keyword">if</span> (result &gt; INT_MAX / <span class="number">10</span> || result == INT_MAX / <span class="number">10</span> &amp;&amp; *str - <span class="string">&#x27;0&#x27;</span> &gt; INT_MAX % <span class="number">10</span>)</span><br><span class="line">            <span class="keyword">return</span> sign &gt; <span class="number">0</span> ? INT_MAX : INT_MIN;</span><br><span class="line">        result = *str - <span class="string">&#x27;0&#x27;</span> + result * <span class="number">10</span>;</span><br><span class="line">        str++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result * sign;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="9-是否是回文数字"><a href="#9-是否是回文数字" class="headerlink" title="9 是否是回文数字"></a>9 是否是回文数字</h2><p>限定不能用额外空间，所以直接把 x 取余得到的数字作为一个反向作为一个新的数字</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPalindrome</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> x != <span class="number">0</span> <span class="keyword">and</span> x % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        y = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 回文走到一半就行了，没必要完全翻转过来</span></span><br><span class="line">        <span class="keyword">while</span> x &gt; y:</span><br><span class="line">            y = y * <span class="number">10</span> + x % <span class="number">10</span></span><br><span class="line">            x //= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> x == y <span class="keyword">or</span> x == y // <span class="number">10</span></span><br></pre></td></tr></table></figure>
</details>




<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tricky here, for x == k * 10^j</span></span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &amp;&amp; (x % <span class="number">10</span> == <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &gt; y) &#123;</span><br><span class="line">        y = y * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x == y || x == y / <span class="number">10</span>; <span class="comment">// 注意 x 可能是奇数长度也可能是偶数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="10-正则表达式"><a href="#10-正则表达式" class="headerlink" title="10 正则表达式"></a>10 正则表达式</h2><p>实现正则表达式，只需要实现<code>.</code>代表任意字符，<code>*</code>代表任意重复。只需要特殊处理<code>*</code>，<br>如果遇到了<code>*</code>，贪婪地向后匹配。和通配符的不同之处在于，正则表达式需要两个字母<br>组成模式，<code>*</code>是对前一个字母的修饰。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isMatch</span><span class="params">(<span class="type">char</span>* s, <span class="type">char</span>* p)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c = *p; c != <span class="number">0</span>; s++, c = *p) &#123;</span><br><span class="line">        <span class="comment">// if next char in pattern is not *</span></span><br><span class="line">        <span class="keyword">if</span> (*(p+<span class="number">1</span>) != <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">            p++;</span><br><span class="line">        <span class="comment">// if we got an *, check if we can skip `.*` or `x*`</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (isMatch(s, p + <span class="number">2</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s ends or p and s differs</span></span><br><span class="line">        <span class="keyword">if</span> (*s == <span class="number">0</span> || c != <span class="string">&#x27;.&#x27;</span> &amp;&amp; c != *s)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *s == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11 盛最多水的容器"></a>11 盛最多水的容器</h2><p>从左右向中间逼近，如果有更大的就更新。简单的一道双指针题目，别想太多。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        water = <span class="built_in">min</span>(height[left], height[right]) * (right - left)</span><br><span class="line">        result = <span class="built_in">max</span>(result, water);</span><br><span class="line">        <span class="keyword">if</span> (height[left] &lt; height[right])</span><br><span class="line">            left++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxArea</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        lo = <span class="number">0</span></span><br><span class="line">        hi = <span class="built_in">len</span>(height) - <span class="number">1</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            water = <span class="built_in">min</span>(height[lo], height[hi]) * (hi - lo)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, water)</span><br><span class="line">            <span class="keyword">if</span> height[lo] &lt; height[hi]:</span><br><span class="line">                lo += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hi -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>



<h2 id="12-十进制转换为罗马数字"><a href="#12-十进制转换为罗马数字" class="headerlink" title="12 十进制转换为罗马数字"></a>12 十进制转换为罗马数字</h2><p>直接按每位把罗马数字转换出来在拼接就好了，使用 C 的话，拼接字符串很麻烦。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intToRoman</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        thousands = [<span class="string">&quot;&quot;</span>, <span class="string">&quot;M&quot;</span>, <span class="string">&quot;MM&quot;</span>, <span class="string">&quot;MMM&quot;</span>]</span><br><span class="line">        hundreds = [<span class="string">&quot;&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;CC&quot;</span>, <span class="string">&quot;CCC&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;DC&quot;</span>, <span class="string">&quot;DCC&quot;</span>, <span class="string">&quot;DCCC&quot;</span>, <span class="string">&quot;CM&quot;</span>]</span><br><span class="line">        tens = [<span class="string">&quot;&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;XX&quot;</span>, <span class="string">&quot;XXX&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;LX&quot;</span>, <span class="string">&quot;LXX&quot;</span>, <span class="string">&quot;LXXX&quot;</span>, <span class="string">&quot;XC&quot;</span>]</span><br><span class="line">        ones = [<span class="string">&quot;&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="string">&quot;II&quot;</span>, <span class="string">&quot;III&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;VI&quot;</span>, <span class="string">&quot;VII&quot;</span>, <span class="string">&quot;VIII&quot;</span>, <span class="string">&quot;IX&quot;</span>]</span><br><span class="line">        <span class="keyword">return</span> thousands[x//<span class="number">1000</span>] + hundreds[x%<span class="number">1000</span>//<span class="number">100</span>] + tens[x%<span class="number">100</span>//<span class="number">10</span>] + ones[x%<span class="number">10</span>]</span><br></pre></td></tr></table></figure>
</details>




<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// note, the leading empty string is the trick here</span></span><br><span class="line">    string thousands[] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;M&quot;</span>, <span class="string">&quot;MM&quot;</span>, <span class="string">&quot;MMM&quot;</span>&#125;;</span><br><span class="line">    string handreds[] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;CC&quot;</span>, <span class="string">&quot;CCC&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;DC&quot;</span>, <span class="string">&quot;DCC&quot;</span>, <span class="string">&quot;DCCC&quot;</span>, <span class="string">&quot;CM&quot;</span>&#125;;</span><br><span class="line">    string tens[] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;XX&quot;</span>, <span class="string">&quot;XXX&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;LX&quot;</span>, <span class="string">&quot;LXX&quot;</span>, <span class="string">&quot;LXXX&quot;</span>, <span class="string">&quot;XC&quot;</span>&#125;;</span><br><span class="line">    string ones[] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="string">&quot;II&quot;</span>, <span class="string">&quot;III&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;VI&quot;</span>, <span class="string">&quot;VII&quot;</span>, <span class="string">&quot;VIII&quot;</span>, <span class="string">&quot;IX&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> thousands[num / <span class="number">1000</span>] + handreds[num % <span class="number">1000</span> / <span class="number">100</span>] + tens[num % <span class="number">100</span> / <span class="number">10</span>] + ones[num % <span class="number">10</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="type">int</span> digits[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span>* romans = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    <span class="type">char</span>* cursor = romans;</span><br><span class="line">    <span class="comment">// if num = 1234, then</span></span><br><span class="line">    <span class="comment">// digits = &#123;1, 2, 3, 4&#125;;</span></span><br><span class="line">    <span class="type">int</span> base = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        digits[i] = num / base;</span><br><span class="line">        num = num % base;</span><br><span class="line">        base /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    doRoman(digits[<span class="number">0</span>], <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, &amp;cursor); <span class="comment">// &#x27;_&#x27; can be anything</span></span><br><span class="line">    doRoman(digits[<span class="number">1</span>], <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, &amp;cursor);</span><br><span class="line">    doRoman(digits[<span class="number">2</span>], <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, &amp;cursor);</span><br><span class="line">    doRoman(digits[<span class="number">3</span>], <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, &amp;cursor);</span><br><span class="line">    *cursor = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> romans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">doRoman</span><span class="params">(<span class="type">int</span> number, <span class="type">char</span> ten, <span class="type">char</span> five, <span class="type">char</span> one, <span class="type">char</span>** str)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (number) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            (*str)[<span class="number">0</span>] = one;</span><br><span class="line">            (*str)[<span class="number">1</span>] = ten;</span><br><span class="line">            (*str) += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            (*str)[<span class="number">0</span>] = five;</span><br><span class="line">            (*str)[<span class="number">1</span>] = one;</span><br><span class="line">            (*str)[<span class="number">2</span>] = one;</span><br><span class="line">            (*str)[<span class="number">3</span>] = one;</span><br><span class="line">            (*str) += <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            (*str)[<span class="number">0</span>] = five;</span><br><span class="line">            (*str)[<span class="number">1</span>] = one;</span><br><span class="line">            (*str)[<span class="number">2</span>] = one;</span><br><span class="line">            (*str) += <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            (*str)[<span class="number">0</span>] = five;</span><br><span class="line">            (*str)[<span class="number">1</span>] = one;</span><br><span class="line">            (*str) += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            (*str)[<span class="number">0</span>] = five;</span><br><span class="line">            (*str) += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            (*str)[<span class="number">0</span>] = one;</span><br><span class="line">            (*str)[<span class="number">1</span>] = five;</span><br><span class="line">            (*str) += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            (*str)[<span class="number">0</span>] = one;</span><br><span class="line">            (*str)[<span class="number">1</span>] = one;</span><br><span class="line">            (*str)[<span class="number">2</span>] = one;</span><br><span class="line">            (*str) += <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            (*str)[<span class="number">0</span>] = one;</span><br><span class="line">            (*str)[<span class="number">1</span>] = one;</span><br><span class="line">            (*str) += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            (*str)[<span class="number">0</span>] = one;</span><br><span class="line">            (*str) += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="13-罗马数字转为十进制"><a href="#13-罗马数字转为十进制" class="headerlink" title="13 罗马数字转为十进制"></a>13 罗马数字转为十进制</h2><p>主要是当前一个数字小于后一个数字的时候，需要添加的是后一个数和前一个数字的差。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">romanToInt</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        vals = &#123;</span><br><span class="line">            <span class="string">&quot;I&quot;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="string">&quot;V&quot;</span>: <span class="number">5</span>,</span><br><span class="line">            <span class="string">&quot;X&quot;</span>: <span class="number">10</span>,</span><br><span class="line">            <span class="string">&quot;L&quot;</span>: <span class="number">50</span>,</span><br><span class="line">            <span class="string">&quot;C&quot;</span>: <span class="number">100</span>,</span><br><span class="line">            <span class="string">&quot;D&quot;</span>: <span class="number">500</span>,</span><br><span class="line">            <span class="string">&quot;M&quot;</span>: <span class="number">1000</span></span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">if</span> i+<span class="number">1</span>&lt;<span class="built_in">len</span>(s) <span class="keyword">and</span> vals[s[i]] &lt; vals[s[i+<span class="number">1</span>]]:</span><br><span class="line">                ans += vals[s[i+<span class="number">1</span>]] - vals[s[i]]</span><br><span class="line">                i += <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans += vals[s[i]]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>




<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// acts like a dict or map</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getVal</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>: <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>: <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>: <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>: <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>: <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>: <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>: <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">romanToInt</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; s[i] != <span class="number">0</span>; ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (getVal(s[i]) &lt; getVal(s[i+<span class="number">1</span>]))</span><br><span class="line">            result += getVal(s[i+<span class="number">1</span>]) - getVal(s[i]), i += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            result += getVal(s[i]), i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14 最长公共前缀"></a>14 最长公共前缀</h2><p>纵向扫描，从头到尾，如果不一致，返回当前子串即可。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestCommonPrefix</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> strs:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(strs) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> strs[<span class="number">0</span>]</span><br><span class="line">        minlen = <span class="built_in">min</span>([<span class="built_in">len</span>(<span class="built_in">str</span>) <span class="keyword">for</span> <span class="built_in">str</span> <span class="keyword">in</span> strs])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(minlen):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(strs)):</span><br><span class="line">                <span class="keyword">if</span> strs[j][i] != strs[<span class="number">0</span>][i]:</span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>][:i]</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>][:minlen]</span><br></pre></td></tr></table></figure>
</details>




<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 纵向扫描</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">longestCommonPrefix</span><span class="params">(<span class="type">char</span>** strs, <span class="type">int</span> strsSize)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!strs || !strs[<span class="number">0</span>]) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (strsSize == <span class="number">1</span>) <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(strs[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; strsSize; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strs[j][i] != strs[<span class="number">0</span>][i]) &#123;</span><br><span class="line">                strs[<span class="number">0</span>][i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="15-从数组中找出三个数使得他们的和是-0"><a href="#15-从数组中找出三个数使得他们的和是-0" class="headerlink" title="15 从数组中找出三个数使得他们的和是 0"></a>15 从数组中找出三个数使得他们的和是 0</h2><p>首先把数组排序，然后使用类似 two sum 的方法做就好了。做这种数组题的套路就是实在不行排个<br>序。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        nums.sort()</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            k = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">            j = i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; k:</span><br><span class="line">                <span class="built_in">sum</span> = nums[i] + nums[j] + nums[k]</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">sum</span> &gt; <span class="number">0</span>:</span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> <span class="built_in">sum</span> &lt; <span class="number">0</span>:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans.append([nums[i], nums[j], nums[k]])</span><br><span class="line">                    <span class="keyword">while</span> j &lt; k <span class="keyword">and</span> nums[j] == nums[j+<span class="number">1</span>]:</span><br><span class="line">                        j += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> j &lt; k <span class="keyword">and</span> nums[k] == nums[k-<span class="number">1</span>]:</span><br><span class="line">                        k -= <span class="number">1</span></span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>




<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] &gt; <span class="number">0</span>)</span><br><span class="line">                k--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] &lt; <span class="number">0</span>)</span><br><span class="line">                j++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(&#123;nums[i], nums[j], nums[k]&#125;);</span><br><span class="line">                <span class="comment">// skipping duplicates</span></span><br><span class="line">                <span class="keyword">while</span> (j &lt; k &amp;&amp; nums[k] == nums[k - <span class="number">1</span>])</span><br><span class="line">                    k--;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; k &amp;&amp; nums[j] == nums[j + <span class="number">1</span>])</span><br><span class="line">                    j++;</span><br><span class="line">                k--; <span class="comment">// 别忘了这里，还要继续寻找下一组</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="16-在数组中找到三个数字使得他们得和尽可能的接近给定数字，假设结果唯一"><a href="#16-在数组中找到三个数字使得他们得和尽可能的接近给定数字，假设结果唯一" class="headerlink" title="16 在数组中找到三个数字使得他们得和尽可能的接近给定数字，假设结果唯一"></a>16 在数组中找到三个数字使得他们得和尽可能的接近给定数字，假设结果唯一</h2><p>和上一题解法类似，在 <a target="_blank" rel="noopener" href="http://stackoverflow.com/q/2070359">http://stackoverflow.com/q/2070359</a> 有详尽解释</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSumClosest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        nums.sort()</span><br><span class="line">        ans = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            j = i + <span class="number">1</span></span><br><span class="line">            k = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; k:</span><br><span class="line">                <span class="built_in">sum</span> = nums[i] + nums[j] + nums[k]</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">sum</span> == target:</span><br><span class="line">                    <span class="keyword">return</span> target</span><br><span class="line">                <span class="keyword">elif</span> <span class="built_in">abs</span>(target-<span class="built_in">sum</span>) &lt; <span class="built_in">abs</span>(target-ans):</span><br><span class="line">                    ans = <span class="built_in">sum</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">sum</span> &gt; target:</span><br><span class="line">                        k -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>





<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *a - *b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">threeSumClosest</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize &lt;= <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line">    qsort(nums, numsSize, <span class="keyword">sizeof</span>(<span class="type">int</span>), cmp);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] +nums[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        <span class="type">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> k = numsSize - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">            <span class="type">int</span> sum = nums[i] + nums[j] + nums[k];</span><br><span class="line">            <span class="keyword">if</span> (sum == target)</span><br><span class="line">                <span class="keyword">return</span> target;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(target - sum) &lt; <span class="built_in">abs</span>(target - result))</span><br><span class="line">                result = sum;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; target)</span><br><span class="line">                k--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="17-生成电话键盘按键数字对应的所有可能的字符串，不限制返回结果的顺序"><a href="#17-生成电话键盘按键数字对应的所有可能的字符串，不限制返回结果的顺序" class="headerlink" title="17 生成电话键盘按键数字对应的所有可能的字符串，不限制返回结果的顺序"></a>17 生成电话键盘按键数字对应的所有可能的字符串，不限制返回结果的顺序</h2><p>tags: #backtracking</p>
<p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png" alt="键盘"></p>
<p>递归：</p>
<p>这道题是一道典型的，最简单的深度优先遍历，生成所有可能解的问题。</p>
<p>迭代：</p>
<p>遍历数字，设当前结果为<code>&#123;a, b, c&#125;</code>, 下一个数字是<code>3</code>, 找出对应的字母<code>&#123;d, e, f&#125;</code>, 则新的结果是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; a + &#123;def&#125;, b + &#123;def&#125;, c + &#123;def&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>然后把新获得的数组作为下一轮的初始数组。最开始时，使用空数组开始。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">letterCombinations</span>(<span class="params">self, digits: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        c2n = &#123;</span><br><span class="line">            <span class="string">&quot;2&quot;</span>: <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">            <span class="string">&quot;3&quot;</span>: <span class="string">&quot;def&quot;</span>,</span><br><span class="line">            <span class="string">&quot;4&quot;</span>: <span class="string">&quot;ghi&quot;</span>,</span><br><span class="line">            <span class="string">&quot;5&quot;</span>: <span class="string">&quot;jkl&quot;</span>,</span><br><span class="line">            <span class="string">&quot;6&quot;</span>: <span class="string">&quot;mno&quot;</span>,</span><br><span class="line">            <span class="string">&quot;7&quot;</span>: <span class="string">&quot;pqrs&quot;</span>,</span><br><span class="line">            <span class="string">&quot;8&quot;</span>: <span class="string">&quot;tuv&quot;</span>,</span><br><span class="line">            <span class="string">&quot;9&quot;</span>: <span class="string">&quot;wxyz&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">combination, next_digits</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> next_digits:</span><br><span class="line">                ans.append(combination)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> char <span class="keyword">in</span> c2n[next_digits[<span class="number">0</span>]]:</span><br><span class="line">                dfs(combination + char, next_digits[<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans = []</span><br><span class="line">        dfs(<span class="string">&quot;&quot;</span>, digits)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>




<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iterative</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (digits.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> vector&lt;string&gt; &#123;&#125;;</span><br><span class="line">    string mapping[] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">combinations</span><span class="params">(<span class="number">1</span>, <span class="string">&quot;&quot;</span>)</span></span>; <span class="comment">// 注意使用空字符串作为种子</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; digits.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> digit = digits[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (mapping[digit].<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vector&lt;string&gt; temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : mapping[digit])</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; combination : combinations)</span><br><span class="line">                temp.<span class="built_in">push_back</span>(combination + c);</span><br><span class="line">        <span class="built_in">swap</span>(combinations, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> combinations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>还可以使用深度优先的搜索方法</p>
<p>追问：如何通过用户按的数字来查找是否有对应的单词呢</p>
<ol>
<li>通过把所有的单词计算出来，然后查询哪个是合法的，查询可以使用 Trie</li>
<li>通过把已经有的单词字典转换为数字字典，然后通过数字序列查询可能的单词组合。</li>
</ol>
<h2 id="18-4Sum"><a href="#18-4Sum" class="headerlink" title="18 4Sum"></a>18 4Sum</h2><p>tags: #backtracking</p>
<p>其实可以用 深度优先搜索的方式直接解答 nSum</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fourSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">return</span> self.nSum(nums, target, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nSum</span>(<span class="params">self, nums, target, n</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">pos: <span class="built_in">int</span>, cur: <span class="type">List</span>[<span class="built_in">int</span>], n: <span class="built_in">int</span>, target: <span class="built_in">int</span></span>):</span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">                j = pos</span><br><span class="line">                k = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> j &lt; k:</span><br><span class="line">                    <span class="built_in">sum</span> = nums[j] + nums[k]</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">sum</span> &lt; target:</span><br><span class="line">                        j += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> <span class="built_in">sum</span> &gt; target:</span><br><span class="line">                        k -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        solution = cur[:] + [nums[j], nums[k]]</span><br><span class="line">                        ans.append(solution)</span><br><span class="line">                        <span class="keyword">while</span> j &lt; k <span class="keyword">and</span> nums[j] == nums[j+<span class="number">1</span>]:</span><br><span class="line">                            j += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> j &lt; k <span class="keyword">and</span> nums[k] == nums[k-<span class="number">1</span>]:</span><br><span class="line">                            k -= <span class="number">1</span></span><br><span class="line">                        j += <span class="number">1</span></span><br><span class="line">                        k -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            i = pos</span><br><span class="line">            <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(nums) - n + <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 剪枝的一种情况</span></span><br><span class="line">                <span class="keyword">if</span> nums[i] * n &gt; target <span class="keyword">or</span> nums[-<span class="number">1</span>] * n &lt; target:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="comment"># 排除重复数字</span></span><br><span class="line">                <span class="keyword">if</span> i &gt; pos <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                cur.append(nums[i])</span><br><span class="line">                dfs(i+<span class="number">1</span>, cur, n-<span class="number">1</span>, target-nums[i])</span><br><span class="line">                cur.pop()</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        ans = []</span><br><span class="line">        nums.sort()</span><br><span class="line">        dfs(<span class="number">0</span>, [], n, target)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>



<p>下面的 C++ 解法是一个传统解法</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">4</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; hash;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            hash[nums[i]+nums[j]].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(i,j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> re = target - nums[i] - nums[j];</span><br><span class="line">            <span class="keyword">if</span> (hash.<span class="built_in">find</span>(re) != hash.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> match : hash[re]) &#123;</span><br><span class="line">                    <span class="type">int</span> k = match.first, l = match.second;</span><br><span class="line">                    <span class="keyword">if</span> (k &gt; j) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!result.<span class="built_in">empty</span>()</span><br><span class="line">                            &amp;&amp; result.<span class="built_in">back</span>()[<span class="number">0</span>] == nums[i] &amp;&amp; result.<span class="built_in">back</span>()[<span class="number">1</span>] == nums[j]</span><br><span class="line">                            &amp;&amp; result.<span class="built_in">back</span>()[<span class="number">2</span>] == nums[k] &amp;&amp; result.<span class="built_in">back</span>()[<span class="number">3</span>] == nums[l])</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                        result.<span class="built_in">push_back</span>(&#123;nums[i], nums[j], nums[k], nums[l]&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="19-删除链表中倒数第-k-的节点"><a href="#19-删除链表中倒数第-k-的节点" class="headerlink" title="19 删除链表中倒数第 k 的节点"></a>19 删除链表中倒数第 k 的节点</h2><p>tags: #pointers</p>
<p>双指针经典题目，一个快指针先走 k 步，另一个慢指针再出发，注意链表长度小于 k 时。</p>
<p>注意：LeetCode 给定的 n 都是有效地，但要求返回头指针，如果头指针被删除需要额外注意，因此采用 dummy head</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeNthFromEnd</span>(<span class="params">self, head: ListNode, n: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy.<span class="built_in">next</span> = head</span><br><span class="line">        p = dummy</span><br><span class="line">        <span class="keyword">while</span> n &gt;= <span class="number">0</span>:</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">        q = dummy</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            q = q.<span class="built_in">next</span></span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        q.<span class="built_in">next</span> = q.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">removeNthFromEnd</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>, *<span class="title">fast</span>, *<span class="title">slow</span>;</span></span><br><span class="line">    dummy.next = fast = head;</span><br><span class="line">    slow = &amp;dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (fast) &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span> =</span> slow-&gt;next;</span><br><span class="line">    slow-&gt;next = next-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(next); <span class="comment">// remeber to free memory</span></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<h2 id="20-判定给定的字符串是否是合法的括号序列，可能包括大中小三类"><a href="#20-判定给定的字符串是否是合法的括号序列，可能包括大中小三类" class="headerlink" title="20 判定给定的字符串是否是合法的括号序列，可能包括大中小三类"></a>20 判定给定的字符串是否是合法的括号序列，可能包括大中小三类</h2><p>tags: #stack</p>
<p>使用栈的基础题，注意逻辑简化</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        valid = <span class="literal">True</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">match</span> = &#123;<span class="string">&quot;)&quot;</span>: <span class="string">&quot;(&quot;</span>, <span class="string">&quot;]&quot;</span>: <span class="string">&quot;[&quot;</span>, <span class="string">&quot;&#125;&quot;</span>: <span class="string">&quot;&#123;&quot;</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> (<span class="string">&quot;(&quot;</span>, <span class="string">&quot;[&quot;</span>, <span class="string">&quot;&#123;&quot;</span>):</span><br><span class="line">                stack.append(c)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">if</span> stack[-<span class="number">1</span>] != <span class="keyword">match</span>[c]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                stack.pop()</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> stack</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="title function_">opposite</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span> : <span class="keyword">return</span> <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span> : <span class="keyword">return</span> <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span> : <span class="keyword">return</span> <span class="string">&#x27;&#123;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> &#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="type">char</span>&gt; stk;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">            stk.push(c);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!stk.empty() &amp;&amp; stk.top() == opposite(c))</span><br><span class="line">            stk.pop();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stk.empty(); <span class="comment">// 注意为空的条件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>Rust 解答</summary>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">is_valid</span>(s: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">stack</span> = <span class="built_in">vec!</span>[];</span><br><span class="line">        <span class="comment">// let map =</span></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">ch</span> <span class="keyword">in</span> s.<span class="title function_ invoke__">chars</span>() &#123;</span><br><span class="line">            <span class="keyword">match</span> ch &#123;</span><br><span class="line">                <span class="string">&#x27;(&#x27;</span> | <span class="string">&#x27;&#123;&#x27;</span> | <span class="string">&#x27;[&#x27;</span> =&gt; stack.<span class="title function_ invoke__">push</span>(ch),</span><br><span class="line">                <span class="string">&#x27;)&#x27;</span> =&gt; <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="string">&#x27;(&#x27;</span>) = stack.<span class="title function_ invoke__">pop</span>() &#123;&#125; <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;,</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span> =&gt; <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="string">&#x27;&#123;&#x27;</span>) = stack.<span class="title function_ invoke__">pop</span>() &#123;&#125; <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;,</span><br><span class="line">                <span class="string">&#x27;]&#x27;</span> =&gt; <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="string">&#x27;[&#x27;</span>) = stack.<span class="title function_ invoke__">pop</span>() &#123;&#125; <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;,</span><br><span class="line">                _ =&gt; <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.<span class="title function_ invoke__">len</span>() == <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="21-合并两个已经排序的链表"><a href="#21-合并两个已经排序的链表" class="headerlink" title="21 合并两个已经排序的链表"></a>21 合并两个已经排序的链表</h2><p>tags: #pointers</p>
<p>考察链表的基本操作，很简单</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTwoLists</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        p = dummy</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">                p.<span class="built_in">next</span> = l1</span><br><span class="line">                l1 = l1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p.<span class="built_in">next</span> = l2</span><br><span class="line">                l2 = l2.<span class="built_in">next</span></span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> l1:</span><br><span class="line">            p.<span class="built_in">next</span> = l1</span><br><span class="line">        <span class="keyword">if</span> l2:</span><br><span class="line">            p.<span class="built_in">next</span> = l2</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">mergeTwoLists</span><span class="params">(<span class="keyword">struct</span> ListNode* l1, <span class="keyword">struct</span> ListNode* l2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">NULL</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="literal">NULL</span>) <span class="keyword">return</span> l1;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>;</span></span><br><span class="line">    dummy.next == <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">p</span> =</span> &amp;dummy;</span><br><span class="line">    <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            p-&gt;next = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p-&gt;next = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l1)</span><br><span class="line">        p-&gt;next = l1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l2)</span><br><span class="line">        p-&gt;next = l2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="22-给定数字-n-生成所有合法的-n-个括号组成的序列"><a href="#22-给定数字-n-生成所有合法的-n-个括号组成的序列" class="headerlink" title="22 给定数字 n, 生成所有合法的 n 个括号组成的序列"></a>22 给定数字 n, 生成所有合法的 n 个括号组成的序列</h2><p>tags: #backtracking</p>
<p>一道典型的深度优先搜索题目</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateParenthesis</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">s, lefts, rights</span>):</span><br><span class="line">            <span class="keyword">if</span> lefts == <span class="number">0</span> <span class="keyword">and</span> rights == <span class="number">0</span>:</span><br><span class="line">                ans.append(s)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> lefts &gt; <span class="number">0</span>:</span><br><span class="line">                dfs(s+<span class="string">&quot;(&quot;</span>, lefts-<span class="number">1</span>, rights)</span><br><span class="line">            <span class="keyword">if</span> (lefts &lt; rights):</span><br><span class="line">                dfs(s+<span class="string">&quot;)&quot;</span>, lefts, rights-<span class="number">1</span>)</span><br><span class="line">        ans = []</span><br><span class="line">        dfs(<span class="string">&quot;&quot;</span>, n, n)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="built_in">gen</span>(result, <span class="string">&quot;&quot;</span>, n, n);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// left 剩下的左括号，right 剩下的右括号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gen</span><span class="params">(vector&lt;string&gt;&amp; result, string s, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">gen</span>(result, s + <span class="string">&#x27;(&#x27;</span>, left - <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right)</span><br><span class="line">        <span class="built_in">gen</span>(result, s + <span class="string">&#x27;)&#x27;</span>, left, right - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="23-合并-K-个排序的列表"><a href="#23-合并-K-个排序的列表" class="headerlink" title="23 合并 K 个排序的列表"></a>23 合并 K 个排序的列表</h2><p>使用优先级队列，复杂度最小。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">&lt;/details&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">把列表看做一个队列，每次拿出两个列表，合并他们后放回到列表中，每次遍历列表的一半，这样每次遍历完一遍，</span><br><span class="line">列表的长度都会减半，直到列表的长度为 <span class="number">1</span>,  合并函数使用 <span class="number">21</span> 题中的合并两个列表的函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;details&gt;</span><br><span class="line">    &lt;summary&gt;C 解答&lt;/summary&gt;</span><br><span class="line"></span><br><span class="line">```C</span><br><span class="line">struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) &#123;</span><br><span class="line">    // see above</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct ListNode* mergeKLists(struct ListNode** lists, <span class="built_in">int</span> listsSize) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!lists || listsSize &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (listsSize &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        // listsize <span class="keyword">is</span> halfed</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; listsSize / <span class="number">2</span>; i++)</span><br><span class="line">            // merge i <span class="keyword">and</span> last i <span class="built_in">list</span></span><br><span class="line">            lists[i] = mergeTwoLists(lists[i], lists[listsSize-<span class="number">1</span>-i]);</span><br><span class="line">        listsSize = (listsSize + <span class="number">1</span>) / <span class="number">2</span>; // 注意这里！</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="24-给定一个链表，交换两个相邻节点的值"><a href="#24-给定一个链表，交换两个相邻节点的值" class="headerlink" title="24 给定一个链表，交换两个相邻节点的值"></a>24 给定一个链表，交换两个相邻节点的值</h2><p>最简单的做法显然是直接把前后两个节点的值交换，但是 LeetCode 规定不能改变节点的值。<br>主要考察链表的指针操作，注意各种细节，一定要在纸上先把链表画出来。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">swapPairs</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy.<span class="built_in">next</span> = head</span><br><span class="line">        p = dummy</span><br><span class="line">        <span class="keyword">while</span> p.<span class="built_in">next</span> <span class="keyword">and</span> p.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">            t = p.<span class="built_in">next</span></span><br><span class="line">            p.<span class="built_in">next</span> = t.<span class="built_in">next</span></span><br><span class="line">            t.<span class="built_in">next</span> = p.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            p.<span class="built_in">next</span>.<span class="built_in">next</span> = t</span><br><span class="line">            p = p.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">swapPairs</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>, *<span class="title">temp</span>, *<span class="title">pnext</span>, *<span class="title">p</span> =</span> &amp;dummy;</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next &amp;&amp; p-&gt;next-&gt;next) &#123;</span><br><span class="line">        temp = p-&gt;next;</span><br><span class="line">        p-&gt;next = temp-&gt;next;</span><br><span class="line">        temp-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">        p-&gt;next-&gt;next = temp;</span><br><span class="line">        p = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="25-给定一个链表，把相邻的-k-个节点反转"><a href="#25-给定一个链表，把相邻的-k-个节点反转" class="headerlink" title="25 给定一个链表，把相邻的 k 个节点反转"></a>25 给定一个链表，把相邻的 k 个节点反转</h2><p>和上题一样，同样禁止改变节点的值。比较简单地解法是浪费一点空间，使用 Stack, 实现<br>逆转 k 个节点，注意如果 k 较大的话，这种方法是不合适的。另一种方法是直接翻转，空间是<br>O(1) 的，但是时间复杂度是 2N。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head</span>):</span><br><span class="line">        prev = <span class="literal">None</span></span><br><span class="line">        curr = head</span><br><span class="line">        <span class="keyword">while</span> curr:</span><br><span class="line">            <span class="built_in">next</span> = curr.<span class="built_in">next</span></span><br><span class="line">            curr.<span class="built_in">next</span> = prev</span><br><span class="line">            prev = curr</span><br><span class="line">            curr = <span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> prev</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseKGroup</span>(<span class="params">self, head: ListNode, k: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy.<span class="built_in">next</span> = head</span><br><span class="line">        p = dummy</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> p.<span class="built_in">next</span>:</span><br><span class="line">            n = k</span><br><span class="line">            q = p</span><br><span class="line">            <span class="comment"># 找到下一组接点的头</span></span><br><span class="line">            <span class="keyword">while</span> n &gt; <span class="number">0</span> <span class="keyword">and</span> q.<span class="built_in">next</span>:</span><br><span class="line">                q = q.<span class="built_in">next</span></span><br><span class="line">                n -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 如果节点不够了直接退出</span></span><br><span class="line">            <span class="keyword">if</span> n &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 把这段链表先截下来</span></span><br><span class="line">            <span class="built_in">next</span> = q.<span class="built_in">next</span></span><br><span class="line">            q.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">            tail = p.<span class="built_in">next</span></span><br><span class="line">            p.<span class="built_in">next</span> = self.reverseList(p.<span class="built_in">next</span>)</span><br><span class="line">            p = tail</span><br><span class="line">            p.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
</details>


<p>使用 Stack 的 C++ 解法</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    stack&lt;ListNode*&gt; stk;</span><br><span class="line">    <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">-1</span>)</span>, *p </span>= &amp;dummy, *pp;</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        pp = p;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pp-&gt;next) &#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(pp-&gt;next);</span><br><span class="line">                pp = pp-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stk.<span class="built_in">size</span>() &lt; k) <span class="comment">// 剩下的节点不够 k 个了</span></span><br><span class="line">            <span class="keyword">return</span> dummy.next;</span><br><span class="line"></span><br><span class="line">        pp = stk.<span class="built_in">top</span>()-&gt;next; <span class="comment">// 下一组中的第一个</span></span><br><span class="line">        <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            p-&gt;next = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p-&gt;next = pp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26 删除排序数组中的重复项"></a>26 删除排序数组中的重复项</h2><p>tags: #naive</p>
<p>in-place 的删除重复元素，使用两个指针，一个遍历，一个指向当前的结尾。</p>
<p>PS：这个基础题竟然做了半个小时才做对，⊙﹏⊙b 汗，要加强基础啊！</p>
<p>这类数组中去除中间元素的题写的时候还是很容易出错，重点是使用一个 length 变量，<br>然后还是要遍历整个数组。不要想什么双指针了。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 处理 i == 0 的情况也是需要注意的</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> nums[i] != nums[length-<span class="number">1</span>]:</span><br><span class="line">                nums[length] = nums[i]</span><br><span class="line">                length += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> length</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize &lt;= <span class="number">1</span>) <span class="keyword">return</span> numsSize;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> || nums[i] != nums[len - <span class="number">1</span>])</span><br><span class="line">            nums[len++] = nums[i];</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="27-删除元素"><a href="#27-删除元素" class="headerlink" title="27 删除元素"></a>27 删除元素</h2><p>和上一题类似，注意细节</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != val:</span><br><span class="line">                nums[length] = nums[i]</span><br><span class="line">                length += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> length</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!nums || numsSize == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != val)</span><br><span class="line">            nums[len++] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="28-实现-strstr-函数，即查找子串"><a href="#28-实现-strstr-函数，即查找子串" class="headerlink" title="28 实现 strstr 函数，即查找子串"></a>28 实现 strstr 函数，即查找子串</h2><p>使用暴力算法，时间复杂度 O(n)。也可以用 kmp 算法。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kmp 算法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">strStr</span>(<span class="params">self, haystack: <span class="built_in">str</span>, needle: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> needle:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="built_in">next</span> = [<span class="number">0</span>]</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 特别注意这里的 1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(needle)):</span><br><span class="line">            <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> needle[i] != needle[j]:</span><br><span class="line">                j = <span class="built_in">next</span>[j-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> needle[i] == needle[j]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="built_in">next</span>.append(j)</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(haystack)):</span><br><span class="line">            <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> haystack[i] != needle[j]:</span><br><span class="line">                j = <span class="built_in">next</span>[j-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> haystack[i] == needle[j]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j == <span class="built_in">len</span>(needle):</span><br><span class="line">                <span class="keyword">return</span> i - j + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Brute Force</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">strStr</span><span class="params">(<span class="type">char</span>* haystack, <span class="type">char</span>* needle)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h = <span class="built_in">strlen</span>(haystack);</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(needle);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// note h - n + 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; h - n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (needle[j] != haystack[i+j])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (j == n - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<h2 id="29-给定连个整数，不使用乘法和除法计算除法。"><a href="#29-给定连个整数，不使用乘法和除法计算除法。" class="headerlink" title="29 给定连个整数，不使用乘法和除法计算除法。"></a>29 给定连个整数，不使用乘法和除法计算除法。</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/discuss/38997/detailed-explained-8ms-c-solution">这里</a> 有一个非常好的算法</p>
<p>计算可以从被除数中减去除数的次数</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> dividend, <span class="type">int</span> divisor)</span> &#123;</span><br><span class="line">    <span class="comment">// abs(INT_MIN) == INT_MAX + 1</span></span><br><span class="line">    <span class="keyword">if</span> (divisor == <span class="number">0</span> || (dividend == INT_MIN &amp;&amp; divisor == <span class="number">-1</span>))</span><br><span class="line">        <span class="keyword">return</span> INT_MAX;</span><br><span class="line">    <span class="type">int</span> sign = (dividend &gt; <span class="number">0</span>) == (divisor &gt; <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> n = <span class="built_in">labs</span>(dividend);</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> d = <span class="built_in">labs</span>(divisor);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt;= d) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> temp = d;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> multi = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt;= (temp &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">            temp &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            multi &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n -= temp;</span><br><span class="line">        result += multi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sign * result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="30-包串联所有单词的子串"><a href="#30-包串联所有单词的子串" class="headerlink" title="30 包串联所有单词的子串"></a>30 包串联所有单词的子串</h2><p>tags: #slidewindow</p>
<p>一道诡异的滑动窗口的题目，对这类问题还是不很熟啊。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">&lt;/details&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;details&gt;</span><br><span class="line">    &lt;summary&gt;C++ 解答&lt;/summary&gt;</span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line">vector&lt;<span class="built_in">int</span>&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) &#123;</span><br><span class="line">    unordered_map&lt;string, <span class="built_in">int</span>&gt; counts;</span><br><span class="line">    <span class="keyword">for</span> (string word : words)</span><br><span class="line">        counts[word]++;</span><br><span class="line">    <span class="built_in">int</span> n = s.length(), num = words.size(), <span class="built_in">len</span> = words[<span class="number">0</span>].size();</span><br><span class="line">    vector&lt;<span class="built_in">int</span>&gt; indexes;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n - num * <span class="built_in">len</span> + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        unordered_map&lt;string, <span class="built_in">int</span>&gt; seen;</span><br><span class="line">        <span class="built_in">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; j &lt; num; j++) &#123;</span><br><span class="line">            string word = s.substr(i + j * <span class="built_in">len</span>, <span class="built_in">len</span>);</span><br><span class="line">            <span class="keyword">if</span> (counts.find(word) != counts.end()) &#123;</span><br><span class="line">                seen[word]++;</span><br><span class="line">                <span class="keyword">if</span> (seen[word] &gt; counts[word])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == num)</span><br><span class="line">            indexes.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> indexes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="31-全排列，下一个"><a href="#31-全排列，下一个" class="headerlink" title="31 全排列，下一个"></a>31 全排列，下一个</h2><p>首先，对于所有的组合，最小的一个一定是按照升序排序的，最大的一定是倒过来，因此</p>
<ol>
<li>如果我们发现是完全倒序的，直接翻转就好了；</li>
<li>如果是一般情况，从后向前遍历，找到逆序的数字的边界，假设是 k。那么后边这段已经是完全<br>逆序的，无法变小了，为了保证生成的数字变大，我们再从后向前找到第一个比 k 大的数字，交<br>换这两个数字，再把后续的逆序数组翻转。</li>
</ol>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextPermutation</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 前后都是闭区间</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">nums, lo, hi</span>):</span><br><span class="line">            <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">                nums[lo], nums[hi] = nums[hi], nums[lo]</span><br><span class="line">                lo += <span class="number">1</span></span><br><span class="line">                hi -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        k = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; nums[i + <span class="number">1</span>]:</span><br><span class="line">                k = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> k == -<span class="number">1</span>:</span><br><span class="line">            reverse(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        l = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>, k, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[k]:</span><br><span class="line">                l = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        nums[l], nums[k] = nums[k], nums[l]</span><br><span class="line">        reverse(nums, k+<span class="number">1</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">-1</span>; <span class="comment">// 升序排列的最后一个数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            k = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 完全是逆序的，直接返回第一个，也就是升序排列</span></span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">-1</span>; <span class="comment">// 逆序数字中比 k 大的最小的数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt; k; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[k]) &#123;</span><br><span class="line">            l = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(nums[k], nums[l]); <span class="comment">// 保证变大</span></span><br><span class="line">    <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + k + <span class="number">1</span>, nums.<span class="built_in">end</span>()); <span class="comment">// 保证是下一个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="32-从一个括号构成的字符串中找出最长的合法括号序列"><a href="#32-从一个括号构成的字符串中找出最长的合法括号序列" class="headerlink" title="32 从一个括号构成的字符串中找出最长的合法括号序列"></a>32 从一个括号构成的字符串中找出最长的合法括号序列</h2><p>动态规划的基础题目。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestValidParentheses</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">0</span>] * <span class="built_in">len</span>(s)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">&quot;)&quot;</span>:</span><br><span class="line">                <span class="keyword">if</span> s[i-<span class="number">1</span>] == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                    <span class="keyword">if</span> i &gt;= <span class="number">2</span>:</span><br><span class="line">                        dp[i] = dp[i-<span class="number">2</span>] + <span class="number">2</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i] = <span class="number">2</span></span><br><span class="line">                <span class="keyword">elif</span> i - dp[i-<span class="number">1</span>] &gt; <span class="number">0</span> <span class="keyword">and</span> s[i-dp[i-<span class="number">1</span>]-<span class="number">1</span>] == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                    <span class="keyword">if</span> i - dp[i-<span class="number">1</span>] &gt;= <span class="number">2</span>:</span><br><span class="line">                        dp[i] = dp[i-<span class="number">1</span>] + dp[i-dp[i-<span class="number">1</span>]-<span class="number">2</span>] + <span class="number">2</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i] = dp[i-<span class="number">1</span>] + <span class="number">2</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, dp[i])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>


<p>也可以使用栈来解。但是这种方法非常 tricky, 因为要考虑到 <code>()()</code> 的情况。</p>
<h2 id="33-在排序后又被反转的数组中搜索"><a href="#33-在排序后又被反转的数组中搜索" class="headerlink" title="33 在排序后又被反转的数组中搜索"></a>33 在排序后又被反转的数组中搜索</h2><p>既然是部分有序的，自然还是使用二分搜索了，注意终止条件。<br>不同于普通二分搜索的两种情况，我们有了四种情况：</p>
<ol>
<li>前半部分有序，并且在前半部分当中，</li>
<li>前半部分有序，但是不在前半部分</li>
<li>后半部分有序，并且在后半部分</li>
<li>后半部分有序，但是不在后半部分</li>
</ol>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        lo = <span class="number">0</span></span><br><span class="line">        hi = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> lo &lt;= hi:</span><br><span class="line">            mi = lo + (hi - lo) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mi] == target:</span><br><span class="line">                <span class="keyword">return</span> mi</span><br><span class="line">            <span class="comment"># 这里为什么要包含等于号呢</span></span><br><span class="line">            <span class="keyword">if</span> nums[lo] &lt;= nums[mi]:</span><br><span class="line">                <span class="keyword">if</span> nums[lo] &lt;= target &lt; nums[mi]:</span><br><span class="line">                    hi = mi - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    lo = mi + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[mi] &lt; target &lt;= nums[hi]:</span><br><span class="line">                    lo = mi + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    hi = mi - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = numsSize - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// left half is sorted</span></span><br><span class="line">        <span class="keyword">if</span> (nums[left] &lt;= nums[mid]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid])</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// right half is sorted</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right])</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34 在排序数组中查找元素的第一个和最后一个位置"></a>34 在排序数组中查找元素的第一个和最后一个位置</h2><p>在 C++ 的标准库中包含了这两个函数，分别是<code>std::lower_bound</code>和<code>std::upper_bound</code>.</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="function">def <span class="title">searchRange</span><span class="params">(self, nums: List[<span class="type">int</span>], target: <span class="type">int</span>)</span> -&gt; List[<span class="type">int</span>]:</span></span><br><span class="line"><span class="function">        if not nums:</span></span><br><span class="line"><span class="function">            return [<span class="number">-1</span>, <span class="number">-1</span>]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        lo =</span> <span class="number">0</span></span><br><span class="line">        hi = <span class="built_in">len</span>(nums)</span><br><span class="line">        lower = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            mi = lo + (hi - lo) <span class="comment">// 2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mi] &lt; target:</span><br><span class="line">                lo = mi + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hi = mi</span><br><span class="line">        <span class="keyword">if</span> lo &lt; <span class="built_in">len</span>(nums) <span class="keyword">and</span> nums[lo] == target:</span><br><span class="line">            lower = lo</span><br><span class="line"></span><br><span class="line">        lo = <span class="number">0</span></span><br><span class="line">        hi = <span class="built_in">len</span>(nums)</span><br><span class="line">        upper = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            mi = lo + (hi - lo) <span class="comment">// 2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mi] &lt;= target:</span><br><span class="line">                lo = mi + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hi = mi</span><br><span class="line">        <span class="keyword">if</span> nums[lo<span class="number">-1</span>] == target:</span><br><span class="line">            upper = lo - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [lower, upper]</span><br></pre></td></tr></table></figure>
</details>


<h2 id="35-二分查找数字，如果没有找到，返回应该插入的位置"><a href="#35-二分查找数字，如果没有找到，返回应该插入的位置" class="headerlink" title="35 二分查找数字，如果没有找到，返回应该插入的位置"></a>35 二分查找数字，如果没有找到，返回应该插入的位置</h2><p>就是最基础的二分查找</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchInsert</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        lo = <span class="number">0</span></span><br><span class="line">        hi = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            mi = lo + (hi - lo) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mi] == target:</span><br><span class="line">                <span class="keyword">return</span> mi</span><br><span class="line">            <span class="keyword">elif</span> nums[mi] &lt; target:</span><br><span class="line">                lo = mi + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hi = mi</span><br><span class="line">        <span class="keyword">return</span> lo</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = numsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="36-合法数独，给定一个数独表，判定当前是否合法"><a href="#36-合法数独，给定一个数独表，判定当前是否合法" class="headerlink" title="36 合法数独，给定一个数独表，判定当前是否合法"></a>36 合法数独，给定一个数独表，判定当前是否合法</h2><details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValidSudoku</span>(<span class="params">self, board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        这道题的关键就在于小格子也是可以用 i 和 j 来计算的：</span></span><br><span class="line"><span class="string">        box_index = (row / 3) * 3 + columns / 3</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 特别注意浅拷贝的问题</span></span><br><span class="line">        used_i = [[<span class="number">0</span>] * <span class="number">9</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span><br><span class="line">        used_j = [[<span class="number">0</span>] * <span class="number">9</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span><br><span class="line">        used_k = [[<span class="number">0</span>] * <span class="number">9</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">                piece = board[i][j]</span><br><span class="line">                <span class="keyword">if</span> piece == <span class="string">&quot;.&quot;</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                n = <span class="built_in">int</span>(piece) - <span class="number">1</span></span><br><span class="line">                k = i // <span class="number">3</span> * <span class="number">3</span> + j // <span class="number">3</span></span><br><span class="line">                <span class="keyword">if</span> used_i[i][n] <span class="keyword">or</span> used_j[j][n] <span class="keyword">or</span> used_k[k][n]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                used_i[i][n] = used_j[j][n] = used_k[k][n] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有点浪费空间</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isValidSudoku</span><span class="params">(<span class="type">char</span>** board, <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">    <span class="type">bool</span> used_row[<span class="number">9</span>][<span class="number">9</span>] = &#123;<span class="literal">false</span>&#125;, used_col[<span class="number">9</span>][<span class="number">9</span>] = &#123;<span class="literal">false</span>&#125;, used_box[<span class="number">9</span>][<span class="number">9</span>] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> num = board[i][j] - <span class="string">&#x27;0&#x27;</span> - <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> k = i / <span class="number">3</span> * <span class="number">3</span> + j / <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">if</span> (used_row[i][num] || used_col[j][num] || used_box[k][num])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                used_row[i][num] = used_col[j][num] = used_box[k][num] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="37-求解数独"><a href="#37-求解数独" class="headerlink" title="37 求解数独"></a>37 求解数独</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solveSudoku</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>(board, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">int</span> ind)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ind==<span class="number">81</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> i=ind/<span class="number">9</span>, j=ind%<span class="number">9</span>;</span><br><span class="line">    <span class="keyword">if</span>(board[i][j]!=<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">solve</span>(board, ind+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> f = <span class="string">&#x27;1&#x27;</span>; f &lt;= <span class="string">&#x27;9&#x27;</span>; f++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isValidFill</span>(board, i, j, f)) &#123;</span><br><span class="line">                board[i][j]= f;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">solve</span>(board, ind+<span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                board[i][j]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValidFill</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">char</span> fill)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;<span class="number">9</span>; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(board[i][k]==fill) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//check the row</span></span><br><span class="line">        <span class="keyword">if</span>(board[k][j]==fill) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//check the column</span></span><br><span class="line">        <span class="type">int</span> r= i/<span class="number">3</span>*<span class="number">3</span>+j/<span class="number">3</span>;   <span class="comment">//select the block</span></span><br><span class="line">        <span class="keyword">if</span>(board[r/<span class="number">3</span>*<span class="number">3</span>+k/<span class="number">3</span>][r%<span class="number">3</span>*<span class="number">3</span>+k%<span class="number">3</span>]==fill) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//check the block</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="38-数数并说出来"><a href="#38-数数并说出来" class="headerlink" title="38 数数并说出来"></a>38 数数并说出来</h2><p>不太理解这道题有什么意义，直接暴力做出来了</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">countAndSay</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    string result = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n <span class="number">-1</span>; i++) &#123;</span><br><span class="line">        string temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; result.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j + <span class="number">1</span> &lt; result.<span class="built_in">size</span>() &amp;&amp; result[j+<span class="number">1</span>] == result[j]) &#123;</span><br><span class="line">                j++; count++;</span><br><span class="line">            &#125;</span><br><span class="line">            temp += count + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            temp += result[j];</span><br><span class="line">        &#125;</span><br><span class="line">        result = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="39-给定一个集合，在集合中找出和为-target-的数字，数字可以使用多次，集合中没有重复数字"><a href="#39-给定一个集合，在集合中找出和为-target-的数字，数字可以使用多次，集合中没有重复数字" class="headerlink" title="39 给定一个集合，在集合中找出和为 target 的数字，数字可以使用多次，集合中没有重复数字"></a>39 给定一个集合，在集合中找出和为 target 的数字，数字可以使用多次，集合中没有重复数字</h2><p>典型的深度优先搜索</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">dfs</span>(result, candidates, &#123;&#125;, target);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result, vector&lt;<span class="type">int</span>&gt;&amp; candidates, vector&lt;<span class="type">int</span>&gt; comb, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(comb);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : candidates) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c &gt; target) <span class="keyword">continue</span>; <span class="comment">// 数字太大了</span></span><br><span class="line">        <span class="keyword">if</span> (!comb.<span class="built_in">empty</span>() &amp;&amp; c &lt; comb.<span class="built_in">back</span>()) <span class="keyword">continue</span>; <span class="comment">// 保证不重复且升序</span></span><br><span class="line">        comb.<span class="built_in">push_back</span>(c);</span><br><span class="line">        <span class="built_in">dfs</span>(result, candidates, comb, target - c);</span><br><span class="line">        comb.<span class="built_in">pop_back</span>(); <span class="comment">// 注意此处还需要弹出，因为需要循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="40-同上题一样，但是集合中的数字只能使用一次，并且集合中有重复数字"><a href="#40-同上题一样，但是集合中的数字只能使用一次，并且集合中有重复数字" class="headerlink" title="40 同上题一样，但是集合中的数字只能使用一次，并且集合中有重复数字"></a>40 同上题一样，但是集合中的数字只能使用一次，并且集合中有重复数字</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">dfs</span>(result, candidates, &#123;&#125;, target, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result, vector&lt;<span class="type">int</span>&gt;&amp; candidates, vector&lt;<span class="type">int</span>&gt; comb, <span class="type">int</span> target, <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(comb);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; candidates.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (candidates[i] &gt; target)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (i != start &amp;&amp; candidates[i] == candidates[i<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        comb.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">        <span class="built_in">dfs</span>(result, candidates, comb, target - candidates[i], i + <span class="number">1</span>);</span><br><span class="line">        comb.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="41-给定一个数组，找到第一个缺失的正数"><a href="#41-给定一个数组，找到第一个缺失的正数" class="headerlink" title="41 给定一个数组，找到第一个缺失的正数"></a>41 给定一个数组，找到第一个缺失的正数</h2><p>显然，结果的范围是 [1..n+1]. 而数组的长度为 n 我们把每个位置都放上 i+1,<br>这样如果有位置不是 i+1, 则找到了结果，如果都相等则是 n+1.</p>
<details>
    <summary>c 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> t = *a; *a = *b; *b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">firstMissingPositive</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">        <span class="comment">// 注意此处的 while</span></span><br><span class="line">        <span class="keyword">while</span> (nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= numsSize &amp;&amp; nums[i] != nums[nums[i] - <span class="number">1</span>])</span><br><span class="line">            swap(&amp;nums[i], &amp;nums[nums[i] - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> numsSize + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="42-给定一个数组表示柱子的高度，求能存贮的雨水的总量"><a href="#42-给定一个数组表示柱子的高度，求能存贮的雨水的总量" class="headerlink" title="42 给定一个数组表示柱子的高度，求能存贮的雨水的总量"></a>42 给定一个数组表示柱子的高度，求能存贮的雨水的总量</h2><p>从两边向中间收拢</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>* height, <span class="type">int</span> heightSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = heightSize - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> water = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> max_left = <span class="number">0</span>, max_right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从两侧向中间缩小，可以算作是两个指针吧</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (height[left] &lt;= height[right]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (height[left] &gt;= max_left)</span><br><span class="line">                max_left = height[left];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                water += max_left - height[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (height[right] &gt;= max_right)</span><br><span class="line">                max_right = height[right];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                water += max_right - height[right];</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> water;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>Rust 解答</summary>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">trap</span>(height: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> height.<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">left</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">right</span> = height.<span class="title function_ invoke__">len</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">water</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">max_left</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">max_right</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right &#123;</span><br><span class="line">            <span class="keyword">if</span> height[left] &lt;= height[right] &#123;</span><br><span class="line">                <span class="keyword">if</span> height[left] &gt;= max_left &#123;</span><br><span class="line">                    max_left = height[left];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    water += max_left - height[left];</span><br><span class="line">                &#125;</span><br><span class="line">                left += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> height[right] &gt;= max_right &#123;</span><br><span class="line">                    max_right = height[right];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    water += max_right - height[right];</span><br><span class="line">                &#125;</span><br><span class="line">                right -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        water</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
t

<h2 id="43-给定两个任意长的字符串，返回一个字符串，代表他们相乘的结果"><a href="#43-给定两个任意长的字符串，返回一个字符串，代表他们相乘的结果" class="headerlink" title="43 给定两个任意长的字符串，返回一个字符串，代表他们相乘的结果"></a>43 给定两个任意长的字符串，返回一个字符串，代表他们相乘的结果</h2><p>按整数除法运算即可，重点是下标的表示</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> tonum(c) (c - <span class="string">&#x27;0&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tochar(i) (i + <span class="string">&#x27;0&#x27;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">multiply</span><span class="params">(<span class="type">char</span>* num1, <span class="type">char</span>* num2)</span> &#123;</span><br><span class="line">    <span class="comment">// 结果的长度不会超过 m+n,</span></span><br><span class="line">    <span class="comment">// 假设某个数是 n 位的 9, 则结果比另一个数结尾加上 n 个 0 还小</span></span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(num1), m = <span class="built_in">strlen</span>(num2);</span><br><span class="line">    <span class="type">int</span> len = m+n;</span><br><span class="line">    <span class="type">char</span>* result = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (len + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        result[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    result[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="type">int</span> v = tonum(result[i+j+<span class="number">1</span>]) +  tonum(num1[i]) * tonum(num2[j]) + carry;</span><br><span class="line">            result[i+j+<span class="number">1</span>] = tochar(v % <span class="number">10</span>);</span><br><span class="line">            carry = v / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result[i] += carry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        <span class="keyword">if</span> (result[i] != <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> result+i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="44-通配符匹配，-代表任意一个字符，-代表任意一个或多个字符"><a href="#44-通配符匹配，-代表任意一个字符，-代表任意一个或多个字符" class="headerlink" title="44 通配符匹配，? 代表任意一个字符，*代表任意一个或多个字符"></a>44 通配符匹配，<code>?</code> 代表任意一个字符，<code>*</code>代表任意一个或多个字符</h2><p>注意和正则表达式的区别，要求完全匹配。这道题的关键在于对星号的处理，如果出现星号的时候，我们记录当时的 p 和 s 的值，如果发生了不匹配的话，我们尝试回到该位置的下一个位置开始匹配</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isMatch</span><span class="params">(<span class="type">char</span>* s, <span class="type">char</span>* p)</span> &#123;</span><br><span class="line">    <span class="type">char</span>* star = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span>* revert = s;</span><br><span class="line">    <span class="keyword">while</span> (*s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*s == *p || *p == <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">            s++, p++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*p == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">            star = p++, revert = s;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (star)</span><br><span class="line">            p = star + <span class="number">1</span>, s = ++revert;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果剩下了 p, 那应该全都是*才对</span></span><br><span class="line">    <span class="keyword">while</span> (*p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*p++ != <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="45-跳跃游戏，给定一个数组，每个数字是在该位置可以向前移动的距离，返回最少需要多少次才能到达终点"><a href="#45-跳跃游戏，给定一个数组，每个数字是在该位置可以向前移动的距离，返回最少需要多少次才能到达终点" class="headerlink" title="45 跳跃游戏，给定一个数组，每个数字是在该位置可以向前移动的距离，返回最少需要多少次才能到达终点"></a>45 跳跃游戏，给定一个数组，每个数字是在该位置可以向前移动的距离，返回最少需要多少次才能到达终点</h2><p>比较简单，看注释吧</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> steps = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> last = <span class="number">0</span>; <span class="comment">// last range</span></span><br><span class="line">    <span class="type">int</span> cur = <span class="number">0</span>; <span class="comment">// current range</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        <span class="comment">// beyond range, make another jump</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; last)</span><br><span class="line">            last = cur, steps++;</span><br><span class="line">        <span class="comment">// if we could reach longer?</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] + i &gt; cur)</span><br><span class="line">            cur = nums[i] + i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> steps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="46-生成全排列"><a href="#46-生成全排列" class="headerlink" title="46 生成全排列"></a>46 生成全排列</h2><p>Cracking 上给出了一种解法，通过不断的添加下一个元素到上一组元素的不同位置来生成全排列，这样固然可以，但是大规模的拼接数组或者字符串是很耗费资源的。</p>
<p>在已经有了字符串（或者数组）的初始排列以后，可以通过不断交换的方法生成每一组全排列。<br>比如对于 xyz，我们有全排列为</p>
<pre><code>x + per(yx)
y + per(xz)
z + per(xy)
</code></pre>
<p>那么我们通过把每个元素交换到第一个位置，就把问题规模缩小了，知道把问题规模缩小为 1.</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">per</span>(result, nums, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">per</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result, vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> begin)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (begin &gt;= nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(nums);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = begin; i &lt; nums.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 注意是从 begin 开始，这样未改变的才能加入进来</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[begin], nums[i]);</span><br><span class="line">        <span class="built_in">per</span>(result, nums, begin + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">swap</span>(nums[begin], nums[i]); <span class="comment">// 注意因为参数中是传引用，这里需要复原</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>Rust 解答</summary>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">permute</span>(nums: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;<span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">result</span>: <span class="type">Vec</span>&lt;<span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;&gt; = <span class="built_in">vec!</span>[];</span><br><span class="line">        <span class="keyword">Self</span>::<span class="title function_ invoke__">per</span>(&amp;<span class="keyword">mut</span> result, nums, <span class="number">0</span>);</span><br><span class="line">        result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">per</span>(result: &amp;<span class="keyword">mut</span> <span class="type">Vec</span>&lt;<span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;&gt;, nums: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;, begin: <span class="type">usize</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> begin &gt;= nums.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">            result.<span class="title function_ invoke__">push</span>(nums);</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> begin..nums.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">nums</span> = nums.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">            nums.<span class="title function_ invoke__">swap</span>(begin, i);</span><br><span class="line">            <span class="keyword">Self</span>::<span class="title function_ invoke__">per</span>(result, nums, begin + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="47-全排列，数组中有重复元素"><a href="#47-全排列，数组中有重复元素" class="headerlink" title="47 全排列，数组中有重复元素"></a>47 全排列，数组中有重复元素</h2><p>和上一题基本是一样的，注意跳过重复元素就好了</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">per</span>(result, nums, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">per</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result, vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(nums);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (start != i &amp;&amp; nums[start] == nums[i])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">swap</span>(nums[start], nums[i]);</span><br><span class="line">        <span class="built_in">per</span>(result, nums, start + <span class="number">1</span>); <span class="comment">// 事实证明，传引用反倒会超时</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="48-给定一个n-n的图像旋转图像，顺时针旋转-90-度"><a href="#48-给定一个n-n的图像旋转图像，顺时针旋转-90-度" class="headerlink" title="48 给定一个n*n的图像旋转图像，顺时针旋转 90 度"></a>48 给定一个<code>n*n</code>的图像旋转图像，顺时针旋转 90 度</h2><p>做法显然是从里到外，一层一层的旋转，这道题主要考察下标的操作</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>** matrix, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> layer = <span class="number">0</span>; layer &lt; n / <span class="number">2</span>; layer++) &#123;</span><br><span class="line">        <span class="type">int</span> first  = layer;</span><br><span class="line">        <span class="type">int</span> last = n - <span class="number">1</span> - layer;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = first; i &lt; last; i++) &#123;</span><br><span class="line">            <span class="type">int</span> offset = i - first;</span><br><span class="line">            <span class="type">int</span> top = matrix[first][i];</span><br><span class="line">            <span class="comment">// up &lt;- left</span></span><br><span class="line">            matrix[first][i] = matrix[last-offset][first];</span><br><span class="line">            <span class="comment">// left &lt;- down</span></span><br><span class="line">            matrix[last-offset][first] = matrix[last][last-offset];</span><br><span class="line">            <span class="comment">// down &lt;- right</span></span><br><span class="line">            matrix[last][last-offset] = matrix[i][last];</span><br><span class="line">            <span class="comment">// right &lt;- up</span></span><br><span class="line">            matrix[i][last] = top;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="49-给定字符数组，把他们按照-Anagram-分组"><a href="#49-给定字符数组，把他们按照-Anagram-分组" class="headerlink" title="49 给定字符数组，把他们按照 Anagram 分组"></a>49 给定字符数组，把他们按照 Anagram 分组</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Anagram 分组</span></span><br><span class="line"><span class="comment">// 这道题没什么可做的，只需要统计</span></span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line">    string temp;</span><br><span class="line">    unordered_map&lt;string, vector&lt;string&gt;&gt; records;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; strs.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        temp = strs[i];</span><br><span class="line">        <span class="built_in">sort</span>(temp.<span class="built_in">begin</span>(), temp.<span class="built_in">end</span>());</span><br><span class="line">        records[temp].<span class="built_in">push_back</span>(strs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; record : records) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(record.second.<span class="built_in">begin</span>(), record.second.<span class="built_in">end</span>());</span><br><span class="line">        result.<span class="built_in">push_back</span>(record.second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="50-实现-pow-x-n"><a href="#50-实现-pow-x-n" class="headerlink" title="50 实现 pow(x, n)"></a>50 实现 pow(x, n)</h2><p>显然不能直接阶乘过去，分治法</p>
<p>递归做法</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// recursive</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == INT_MIN) <span class="keyword">return</span> myPow(x, n - <span class="number">1</span>) * x;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span> / myPow(x, -n);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="type">double</span> y = myPow(x, n / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (n &amp; <span class="number">0x1</span>)</span><br><span class="line">        <span class="keyword">return</span> y * y * x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> y * y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>迭代做法</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iteratively</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">long</span> p)</span> &#123;</span><br><span class="line">    <span class="type">double</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p &lt; <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span> / myPow(x, -p);</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">            result *= x;</span><br><span class="line">        x *= x;</span><br><span class="line">        p /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="51-N-皇后问题"><a href="#51-N-皇后问题" class="headerlink" title="51 N 皇后问题"></a>51 N 皇后问题</h2><p>需要大幅度修改</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// N 皇后问题，皇后不能再一条直线，一条竖线，一条斜线上</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用深度优先求解，对于 dfs 问题，我们首先把算法的框架写下来，然后确定这个问题的限制条件</span></span><br><span class="line"><span class="comment">// 对于这个问题，限制条件当前行的元素不能在以前的列中出现过，也不能在对角线中出现过</span></span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) <span class="keyword">return</span> result;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">x</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, x, n);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> t, vector&lt;<span class="type">int</span>&gt;&amp; x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当新添加一个 Q 到当前解的时候</span></span><br><span class="line">    <span class="keyword">if</span> (t &gt;= n) &#123;</span><br><span class="line">        <span class="comment">// result.push_back(make_solution(x));</span></span><br><span class="line">        <span class="comment">// return;</span></span><br><span class="line">        vector&lt;string&gt; solution;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="function">string <span class="title">line</span><span class="params">(n, <span class="string">&#x27;.&#x27;</span>)</span></span>;</span><br><span class="line">            line[x[i]] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            solution.<span class="built_in">push_back</span>(line);</span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="built_in">push_back</span>(solution);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">bool</span> skip = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; t; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x[j] == i || <span class="built_in">abs</span>(i - x[j]) == <span class="built_in">abs</span>(t - j)) &#123;</span><br><span class="line">                    skip = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (skip) <span class="keyword">continue</span>;</span><br><span class="line">            x[t] = i;</span><br><span class="line">            <span class="built_in">dfs</span>(t+<span class="number">1</span>, x, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="52-N-皇后一共有多少个解"><a href="#52-N-皇后一共有多少个解" class="headerlink" title="52 N 皇后一共有多少个解"></a>52 N 皇后一共有多少个解</h2><p>不要直接把皇后放好，而是把占用的都记录下来，然后继续深度优先搜索</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; cols, digs1, digs2;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">total</span>(<span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">total</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> count, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cols.<span class="built_in">find</span>(col) != cols.<span class="built_in">end</span>()</span><br><span class="line">                || digs1.<span class="built_in">find</span>(row - col) != digs1.<span class="built_in">end</span>()</span><br><span class="line">                || digs2.<span class="built_in">find</span>(row + col) != digs2.<span class="built_in">end</span>())</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (row == n<span class="number">-1</span>)</span><br><span class="line">                count++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cols.<span class="built_in">insert</span>(col);</span><br><span class="line">                digs1.<span class="built_in">insert</span>(row-col);</span><br><span class="line">                digs2.<span class="built_in">insert</span>(row+col);</span><br><span class="line">                count = <span class="built_in">total</span>(row+<span class="number">1</span>, count, n);</span><br><span class="line">                cols.<span class="built_in">erase</span>(col);</span><br><span class="line">                digs1.<span class="built_in">erase</span>(row-col);</span><br><span class="line">                digs2.<span class="built_in">erase</span>(row+col);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="53-最大子序列和"><a href="#53-最大子序列和" class="headerlink" title="53 最大子序列和"></a>53 最大子序列和</h2><p>动态规划经典题目，遍历数组，如果已经当前子序列已经小于 0 了，抛弃并置 sum &#x3D; 0<br>如果比当前和更大，更新。对于一个子序列，要么使得序列和增大，要么减小。</p>
<p><code>dp[n+1] = max(dp[n], dp[n] + A[n+1])</code></p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> m = INT_MIN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">0</span>; i&lt; numsSize; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; m)</span><br><span class="line">            m = sum;</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; <span class="number">0</span>)</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        current_sum = <span class="number">0</span></span><br><span class="line">        max_value = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            current_sum += i</span><br><span class="line">            max_value = <span class="built_in">max</span>(max_value, current_sum)</span><br><span class="line">            current_sum = <span class="built_in">max</span>(<span class="number">0</span>, current_sum)</span><br><span class="line">        <span class="keyword">return</span> max_value</span><br></pre></td></tr></table></figure>
</details>


<h2 id="54-顺时针螺旋打印矩阵"><a href="#54-顺时针螺旋打印矩阵" class="headerlink" title="54 顺时针螺旋打印矩阵"></a>54 顺时针螺旋打印矩阵</h2><p>一圈一圈地打印就好了</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>** matrix, <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (row == <span class="number">0</span> || col == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>, right = col - <span class="number">1</span>, down = row - <span class="number">1</span>, left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>* result = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * row * col);</span><br><span class="line">    <span class="keyword">while</span> (top &lt;= down &amp;&amp; left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt;= right; i++)</span><br><span class="line">            result[index++] = matrix[top][i];</span><br><span class="line">        top++; <span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = top; i &lt;= down; i++)</span><br><span class="line">            result[index++] = matrix[i][right];</span><br><span class="line">        right--; <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 注意这个 if 语句</span></span><br><span class="line">        <span class="keyword">if</span> (top &lt;= down)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = right; i &gt;= left; i--)</span><br><span class="line">                result[index++] = matrix[down][i];</span><br><span class="line">        down--; <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 注意这个 if 语句</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt;= right)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = down; i &gt;= top; i--)</span><br><span class="line">                result[index++] = matrix[i][left];</span><br><span class="line">        left++; <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="55-给定一个数组，每个数字表示在当前步可以移动的距离，返回是不是能够到达终点"><a href="#55-给定一个数组，每个数字表示在当前步可以移动的距离，返回是不是能够到达终点" class="headerlink" title="55 给定一个数组，每个数字表示在当前步可以移动的距离，返回是不是能够到达终点"></a>55 给定一个数组，每个数字表示在当前步可以移动的距离，返回是不是能够到达终点</h2><p>使用动态规划求解，如果当前距离大于最远距离，更新最远距离，如果已经超过了最远距离，跳出</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> reach = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize &amp;&amp; i &lt;= reach; i++)</span><br><span class="line">            reach = max(reach, nums[i] + i);</span><br><span class="line">    <span class="keyword">return</span> i == numsSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="56-合并序列，给定一组序列，把其中重叠的序列合并"><a href="#56-合并序列，给定一组序列，把其中重叠的序列合并" class="headerlink" title="56 合并序列，给定一组序列，把其中重叠的序列合并"></a>56 合并序列，给定一组序列，把其中重叠的序列合并</h2><p>这道题用 Python 做竟然比用 C++ 还要快</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">class Interval(object):</span></span><br><span class="line"><span class="string">    def __init__(self, start=0, end=0):</span></span><br><span class="line"><span class="string">        self.start = start</span></span><br><span class="line"><span class="string">        self.end= end</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">intervals</span>):</span><br><span class="line">    intervals.sort(key=<span class="keyword">lambda</span> x: x.start)</span><br><span class="line">    combined = []</span><br><span class="line">    <span class="keyword">for</span> interval <span class="keyword">in</span> intervals:</span><br><span class="line">        <span class="keyword">if</span> combined <span class="keyword">and</span> interval.start &lt;= combined[-<span class="number">1</span>].end:</span><br><span class="line">            combined[-<span class="number">1</span>].end = <span class="built_in">max</span>(combined[-<span class="number">1</span>].end, interval.end)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            combined.append(interval)</span><br><span class="line">    <span class="keyword">return</span> combined</span><br></pre></td></tr></table></figure>
</details>


<h2 id="57-添加序列，给定一组已经排序的序列，向其中插入一个序列，需要合并的合并"><a href="#57-添加序列，给定一组已经排序的序列，向其中插入一个序列，需要合并的合并" class="headerlink" title="57 添加序列，给定一组已经排序的序列，向其中插入一个序列，需要合并的合并"></a>57 添加序列，给定一组已经排序的序列，向其中插入一个序列，需要合并的合并</h2><p>把剩余的部分都拷贝过来也不失为一种机智的做法。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, intervals, newInterval</span>):</span><br><span class="line">        ans = []</span><br><span class="line">        start, end = newInterval</span><br><span class="line">        remainder = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="comment"># 未重叠</span></span><br><span class="line">            <span class="keyword">if</span> start &gt; y:</span><br><span class="line">                ans.append([x, y])</span><br><span class="line">            <span class="comment"># 进入重叠状态</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> end &lt; x:  <span class="comment"># 当前区间已经不重叠了</span></span><br><span class="line">                    <span class="keyword">break</span>  <span class="comment"># 找到了结尾了</span></span><br><span class="line">                start = <span class="built_in">min</span>(start, x)</span><br><span class="line">                end = <span class="built_in">max</span>(end, y)</span><br><span class="line">            remainder += <span class="number">1</span></span><br><span class="line">        ans.append([start, end])</span><br><span class="line">        ans += intervals[remainder:]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>



<h2 id="58-给定一个字符串，求其中最后一个单词的长度"><a href="#58-给定一个字符串，求其中最后一个单词的长度" class="headerlink" title="58 给定一个字符串，求其中最后一个单词的长度"></a>58 给定一个字符串，求其中最后一个单词的长度</h2><p>显然这道题可以用 strlen 求出长度然后从后往前数，但是，这样相当于多遍历了一次<br>直接从后往前可以保证只遍历一次</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lengthOfLastWord</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> inWord = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (*s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(*s)) &#123;</span><br><span class="line">            inWord = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!inWord) &#123;</span><br><span class="line">                len = <span class="number">1</span>;</span><br><span class="line">                inWord = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="59-给定-n，把-1-2-3-…-螺旋打印到矩阵中"><a href="#59-给定-n，把-1-2-3-…-螺旋打印到矩阵中" class="headerlink" title="59 给定 n，把 1, 2, 3 … 螺旋打印到矩阵中"></a>59 给定 n，把 1, 2, 3 … 螺旋打印到矩阵中</h2><p>和上一个完全一样的思路，只是这次是打印罢了</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return an array of arrays.</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span>** <span class="title function_">generateMatrix</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span>** matrix = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>*) * n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        matrix[i] = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>, left = <span class="number">0</span>, down = n - <span class="number">1</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (top &lt;= down &amp;&amp; left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt;=right; i++)</span><br><span class="line">            matrix[top][i] = a++;</span><br><span class="line">        top++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = top; i &lt;= down; i++) &#123;</span><br><span class="line">            matrix[i][right] = a++;</span><br><span class="line">        &#125;</span><br><span class="line">        right--;</span><br><span class="line">        <span class="keyword">if</span> (top &lt;= down)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = right; i &gt;= left; i--)</span><br><span class="line">                matrix[down][i] = a++;</span><br><span class="line">        down--;</span><br><span class="line">        <span class="keyword">if</span> (left &lt;= right)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = down; i &gt;= top; i--)</span><br><span class="line">                matrix[i][left] = a++;</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="60-给定-n-个数字，找出第-k-个-Permutation"><a href="#60-给定-n-个数字，找出第-k-个-Permutation" class="headerlink" title="60 给定 n 个数字，找出第 k 个 Permutation"></a>60 给定 n 个数字，找出第 k 个 Permutation</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*The logic is as follows:</span></span><br><span class="line"><span class="comment">    for n numbers the permutations can be divided to (n-1)! groups,</span></span><br><span class="line"><span class="comment">    thus k/(n-1)! indicates the index of current number,</span></span><br><span class="line"><span class="comment">    and k%(n-1)! denotes remaining sequence (to the right).</span></span><br><span class="line"><span class="comment">    We keep doing this until n reaches 0, then we get n numbers permutations that is kth.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">string <span class="title">getPermutation</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> f = <span class="number">1</span>;</span><br><span class="line">        <span class="function">string <span class="title">s</span><span class="params">(n, <span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            f *= i;</span><br><span class="line">            s[i<span class="number">-1</span>] = i + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 给定 n, 一共有 n! 个序列，f == n!</span></span><br><span class="line"></span><br><span class="line">        k--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            f /= n - i; <span class="comment">// f /= n, f /= n - 1 ...</span></span><br><span class="line">            <span class="type">int</span> j = i + k / f;</span><br><span class="line">            <span class="type">char</span> c= s[j];</span><br><span class="line">            <span class="keyword">for</span> (;j &gt; i; j--) <span class="comment">// shift space to put `c`, actually we could use swap</span></span><br><span class="line">                s[j] = s[j<span class="number">-1</span>];</span><br><span class="line">            s[i] = c;</span><br><span class="line">            k %= f;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="61-把列表旋转到倒数第-k-位"><a href="#61-把列表旋转到倒数第-k-位" class="headerlink" title="61 把列表旋转到倒数第 k 位"></a>61 把列表旋转到倒数第 k 位</h2><p>需要注意的是 k 大于列表长度的情况，这时候需要取余</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">rotateRight</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || k &lt;= <span class="number">0</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">n</span> =</span> head;</span><br><span class="line">    <span class="keyword">while</span> (n-&gt;next) &#123;</span><br><span class="line">        n = n-&gt;next;</span><br><span class="line">        l++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// n is now the tail!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (k &gt;= l) k %= l;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>, *<span class="title">p</span> =</span> &amp;dummy;</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="type">int</span> i = l - k;</span><br><span class="line">    <span class="keyword">while</span> (i--)</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line"></span><br><span class="line">    dummy.next = p-&gt;next;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    n-&gt;next = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="62-给定一个m-n的矩阵，有多少种方法从左上角移动到右下角"><a href="#62-给定一个m-n的矩阵，有多少种方法从左上角移动到右下角" class="headerlink" title="62 给定一个m*n的矩阵，有多少种方法从左上角移动到右下角"></a>62 给定一个<code>m*n</code>的矩阵，有多少种方法从左上角移动到右下角</h2><p>显然可以使用组合数学直接求出来解，但是容易溢出。而且这是一道经典的动态规划题目，对于<br>每个格子，可以从他的上部或者左面移动过来。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">grid</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            grid[i][j] = grid[i - <span class="number">1</span>][j] + grid[i][j - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> grid[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="63-同上题，区别是在一些位置是有障碍物的"><a href="#63-同上题，区别是在一些位置是有障碍物的" class="headerlink" title="63 同上题，区别是在一些位置是有障碍物的"></a>63 同上题，区别是在一些位置是有障碍物的</h2><p>经过分析可知，递推关系是一样的，只需要把有障碍格子的到达方法设定为 0。这个主要是实现上的一些技巧，<br>见注释。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = obstacleGrid.<span class="built_in">size</span>(), n = obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 注意设定长宽均 +1，但是初始化为 0，边界就成了障碍</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathes</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    pathes[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 给定一个入口</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m + <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n + <span class="number">1</span>; j++)</span><br><span class="line">            <span class="comment">// 注意此处的偏移</span></span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i<span class="number">-1</span>][j<span class="number">-1</span>] == <span class="number">1</span>)</span><br><span class="line">                pathes[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pathes[i][j] = pathes[i<span class="number">-1</span>][j] + pathes[i][j<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> pathes[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="64-给定一个m-n矩阵，每个数字代表经过该处的耗费，找出一条耗费最小的路径"><a href="#64-给定一个m-n矩阵，每个数字代表经过该处的耗费，找出一条耗费最小的路径" class="headerlink" title="64 给定一个m*n矩阵，每个数字代表经过该处的耗费，找出一条耗费最小的路径"></a>64 给定一个<code>m*n</code>矩阵，每个数字代表经过该处的耗费，找出一条耗费最小的路径</h2><p>依然是动态规划</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if modifying the grid is disallowed, copy it</span></span><br><span class="line">    <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j != <span class="number">0</span>)</span><br><span class="line">                grid[i][j] += grid[i][j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                grid[i][j] += grid[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                grid[i][j] += <span class="built_in">min</span>(grid[i<span class="number">-1</span>][j], grid[i][j<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">return</span> grid[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="65-判定一个字符串是否是合法的数字，包括了正负号，小数点，e等"><a href="#65-判定一个字符串是否是合法的数字，包括了正负号，小数点，e等" class="headerlink" title="65 判定一个字符串是否是合法的数字，包括了正负号，小数点，e等"></a>65 判定一个字符串是否是合法的数字，包括了正负号，小数点，<code>e</code>等</h2><p>一些例子：</p>
<pre><code>&quot;0&quot; =&gt; true
&quot; 0.1 &quot; =&gt; true
&quot;abc&quot; =&gt; false
&quot;1 a&quot; =&gt; false
&quot;2e10&quot; =&gt; true
</code></pre>
<p>这道题就是细节题，用 C 处理字符串太蛋疼了，直接上 Python 了</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isNumber</span>(<span class="params">self, s</span>):</span><br><span class="line">    BEFORE = <span class="number">0</span> <span class="comment"># before dot</span></span><br><span class="line">    AFTER = <span class="number">1</span> <span class="comment"># after dot</span></span><br><span class="line">    EXP = <span class="number">2</span> <span class="comment"># after e</span></span><br><span class="line">    phase = BEFORE</span><br><span class="line">    allow_sign = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    s = s.strip()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">any</span>([c.isdigit() <span class="keyword">for</span> c <span class="keyword">in</span> s]):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">&#x27;&#x27;</span> <span class="keyword">or</span> s[<span class="number">0</span>] == <span class="string">&#x27;e&#x27;</span> <span class="keyword">or</span> s[-<span class="number">1</span>] == <span class="string">&#x27;e&#x27;</span> <span class="keyword">or</span> s == <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span> <span class="keyword">and</span> s[<span class="number">1</span>] == <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span> <span class="keyword">and</span> s[<span class="number">1</span>] == <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;0&#x27;</span> &lt;= c &lt;= <span class="string">&#x27;9&#x27;</span>:</span><br><span class="line">            allow_sign = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> c == <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">            allow_sign = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> phase == EXP <span class="keyword">or</span> phase == AFTER:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                phase = AFTER</span><br><span class="line">        <span class="keyword">elif</span> c == <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> phase == EXP:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            allow_sign = <span class="literal">True</span></span><br><span class="line">            phase = EXP</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> c == <span class="string">&#x27;-&#x27;</span> <span class="keyword">or</span> c == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> allow_sign:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            allow_sign = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> phase == EXP:</span><br><span class="line">        <span class="keyword">return</span> s[-<span class="number">1</span>].isdigit()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</details>


<h2 id="66-给定一个字符串代表的数字，返回加-1-后的数字"><a href="#66-给定一个字符串代表的数字，返回加-1-后的数字" class="headerlink" title="66 给定一个字符串代表的数字，返回加 1 后的数字"></a>66 给定一个字符串代表的数字，返回加 1 后的数字</h2><p>乍一看如果需要进位的话，可能需要拷贝整个数组。实际上并不需要，我们知道只有当数字是 999…999 的时候，才会使得数字的长度 +1 变为 1000…000。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">plusOne</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = digits.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (digits[i] == <span class="number">9</span>) &#123;</span><br><span class="line">            digits[i] = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            digits[i]++;</span><br><span class="line">            <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// trick here, we know that the number is 999...999</span></span><br><span class="line">    digits[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    digits.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> digits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>Rust 解答</summary>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">plus_one</span>(<span class="keyword">mut</span> digits: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> (<span class="number">0</span>..digits.<span class="title function_ invoke__">len</span>()).<span class="title function_ invoke__">rev</span>() &#123;</span><br><span class="line">            <span class="keyword">match</span> digits[i] &#123;</span><br><span class="line">                <span class="number">9</span> =&gt; digits[i] = <span class="number">0</span>,</span><br><span class="line">                _ =&gt; &#123;digits[i] += <span class="number">1</span>; <span class="keyword">return</span> digits&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        digits[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        digits.<span class="title function_ invoke__">push</span>(<span class="number">0</span>);</span><br><span class="line">        digits</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="67-给定两个字符串代表的二进制数字，返回他们相加的和"><a href="#67-给定两个字符串代表的二进制数字，返回他们相加的和" class="headerlink" title="67 给定两个字符串代表的二进制数字，返回他们相加的和"></a>67 给定两个字符串代表的二进制数字，返回他们相加的和</h2><p>和上一题一样，按照加法定义做就好了</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> tonum(c) (c - <span class="string">&#x27;0&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tochar(i) (i + <span class="string">&#x27;0&#x27;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">addBinary</span><span class="params">(<span class="type">char</span>* a, <span class="type">char</span>* b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> m = <span class="built_in">strlen</span>(a), n = <span class="built_in">strlen</span>(b);</span><br><span class="line">    <span class="type">int</span> len = (m &gt; n ? m : n) + <span class="number">1</span>; <span class="comment">// strlen(c)</span></span><br><span class="line">    <span class="type">char</span>* c = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * len + <span class="number">1</span>); <span class="comment">// with ending null</span></span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="string">&#x27;0&#x27;</span>, len+<span class="number">1</span>);</span><br><span class="line">    c[len] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">         c[len-i] = tochar((i &lt;= m ? tonum(a[m-i]) : <span class="number">0</span>) ^ (i &lt;= n ? tonum(b[n-i]) : <span class="number">0</span>) ^ carry);</span><br><span class="line">         carry = ((i &lt;= m ? tonum(a[m-i]) : <span class="number">0</span>) + (i &lt;= n ? tonum(b[n-i]) : <span class="number">0</span>) + carry) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span> ? c+<span class="number">1</span> : c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="68-文字对齐"><a href="#68-文字对齐" class="headerlink" title="68 文字对齐"></a>68 文字对齐</h2><p>待研究</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">fullJustify</span><span class="params">(vector&lt;string&gt;&amp; words, <span class="type">int</span> L)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, k, l; i &lt; words.<span class="built_in">size</span>(); i += k) &#123;</span><br><span class="line">        <span class="keyword">for</span>(k = l = <span class="number">0</span>; i + k &lt; words.<span class="built_in">size</span>() <span class="keyword">and</span> l + words[i+k].<span class="built_in">size</span>() &lt;= L - k; k++) &#123;</span><br><span class="line">            l += words[i+k].<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        string tmp = words[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; k - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i + k &gt;= words.<span class="built_in">size</span>()) tmp += <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> tmp += <span class="built_in">string</span>((L - l) / (k - <span class="number">1</span>) + (j &lt; (L - l) % (k - <span class="number">1</span>)), <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            tmp += words[i+j+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        tmp += <span class="built_in">string</span>(L - tmp.<span class="built_in">size</span>(), <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="69-给定整数-x，求-sqrt-x"><a href="#69-给定整数-x，求-sqrt-x" class="headerlink" title="69 给定整数 x，求 sqrt(x)"></a>69 给定整数 x，求 sqrt(x)</h2><p>比较坑的是 LeetCode 要求的是 <code>y*y &lt; x</code> 的最大整数</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> EPS = x * <span class="number">0.0001</span>;</span><br><span class="line">    <span class="type">double</span> y = x / <span class="number">2</span>; <span class="comment">// initial guess</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fabs</span>(y * y - x) &gt; EPS) &#123;</span><br><span class="line">        y = (y + x / y) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> z = (<span class="type">long</span>) y;</span><br><span class="line">    <span class="keyword">while</span> (z * z &gt; x) z--;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="70-爬梯子，一次可以爬一步或者两步，有几种方法爬完梯子"><a href="#70-爬梯子，一次可以爬一步或者两步，有几种方法爬完梯子" class="headerlink" title="70 爬梯子，一次可以爬一步或者两步，有几种方法爬完梯子"></a>70 爬梯子，一次可以爬一步或者两步，有几种方法爬完梯子</h2><p>斐波那契数列，也可以理解为动态规划</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        t = b, b += a, a = t;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="71-简化-Unix-路径，需要处理-和多个斜杠等情况"><a href="#71-简化-Unix-路径，需要处理-和多个斜杠等情况" class="headerlink" title="71 简化 Unix 路径，需要处理., .. 和多个斜杠等情况"></a>71 简化 Unix 路径，需要处理<code>.</code>, <code>..</code> 和多个斜杠等情况</h2><p>没有什么需要注意的，主要是使用 stringstream 用作 string.split</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">simplifyPath</span><span class="params">(string&amp; path)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; dirs;</span><br><span class="line">    <span class="function">stringstream <span class="title">ss</span><span class="params">(path)</span></span>;</span><br><span class="line">    string dir;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(ss, dir, <span class="string">&#x27;/&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dir == <span class="string">&quot;.&quot;</span> || dir == <span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (dir == <span class="string">&quot;..&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dirs.<span class="built_in">empty</span>())</span><br><span class="line">            dirs.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            dirs.<span class="built_in">push_back</span>(dir);</span><br><span class="line">    &#125;</span><br><span class="line">    string result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; dir : dirs)</span><br><span class="line">        <span class="keyword">if</span> (!dir.<span class="built_in">empty</span>())</span><br><span class="line">            result += <span class="string">&quot;/&quot;</span> + dir;</span><br><span class="line">    <span class="keyword">return</span> result.<span class="built_in">size</span>() ? result : <span class="string">&quot;/&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="72-编辑距离，允许替换，删除，插入三种操作"><a href="#72-编辑距离，允许替换，删除，插入三种操作" class="headerlink" title="72 编辑距离，允许替换，删除，插入三种操作"></a>72 编辑距离，允许替换，删除，插入三种操作</h2><p>对于两个字符串比较，往往要使用二维的动态规划。<br>使用 f[i][j] 表示 word1[1..i] 和 word2[1..j] 之间的距离。<br>see <a target="_blank" rel="noopener" href="https://leetcode.com/discuss/43398/20ms-detailed-explained-c-solutions-o-n-space">here</a></p>
<p>那么：</p>
<ol>
<li><p>相等 f[i][j] &#x3D; f[i-1][j-1];</p>
</li>
<li><p>不相等</p>
<ol>
<li>替换：f[i][j] &#x3D; f[i-1][j-1] + 1;  都向前一步</li>
<li>添加：f[i][j] &#x3D; f[i][j-1] + 1; word2 向前一步</li>
<li>删除：f[i][j] &#x3D; f[i-1][j] + 1; word1 向前一步</li>
</ol>
</li>
</ol>
<p>另外使用一维数组表示二维数组还需要了解</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// unoptimized code</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = word1.<span class="built_in">length</span>(), n = word2.<span class="built_in">length</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        dp[<span class="number">0</span>][j] = j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>])</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>, <span class="built_in">min</span>(dp[i][j - <span class="number">1</span>] + <span class="number">1</span>, dp[i - <span class="number">1</span>][j] + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// optimized</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = word1.<span class="built_in">length</span>(), n = word2.<span class="built_in">length</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cur</span><span class="params">(m + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 把剩余的字符删掉的距离</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        cur[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="type">int</span> pre = cur[<span class="number">0</span>];</span><br><span class="line">        cur[<span class="number">0</span>] = j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="type">int</span> temp = cur[i];</span><br><span class="line">            <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>])</span><br><span class="line">                cur[i] = pre;</span><br><span class="line">            <span class="keyword">else</span> cur[i] = <span class="built_in">min</span>(pre + <span class="number">1</span>, <span class="built_in">min</span>(cur[i] + <span class="number">1</span>, cur[i - <span class="number">1</span>] + <span class="number">1</span>));</span><br><span class="line">            pre = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur[m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// recursive code from beauty of programming</span></span><br><span class="line"><span class="comment">// TLE on LeetCode</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">minDistance</span>(&amp;word1.<span class="built_in">front</span>(), &amp;word1.<span class="built_in">back</span>(), &amp;word2.<span class="built_in">front</span>(), &amp;word2.<span class="built_in">back</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="built_in">minDistance</span>(<span class="type">char</span>* start1, <span class="type">char</span>* end1, <span class="type">char</span>* start2, <span class="type">char</span>* end2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (start1 &gt; end1)</span><br><span class="line">        <span class="keyword">return</span> start2 &gt; end2 ? <span class="number">0</span> : end2 - start2 + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (start2 &gt; end2)</span><br><span class="line">        <span class="keyword">return</span> start1 &gt; end1 ? <span class="number">0</span> : end1 - start1 + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*start1 == *start2)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">minDistance</span>(start1 + <span class="number">1</span>, end1, start2 + <span class="number">1</span>, end2);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> t1 = <span class="built_in">minDistance</span>(start1 + <span class="number">1</span>, end1, start2 + <span class="number">1</span>, end2);</span><br><span class="line">        <span class="type">int</span> t2 = <span class="built_in">minDistance</span>(start1 + <span class="number">1</span>, end1, start2, end2);</span><br><span class="line">        <span class="type">int</span> t3 = <span class="built_in">minDistance</span>(start1, end1, start2 + <span class="number">1</span>, end2);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(t1, <span class="built_in">min</span>(t2, t3)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="73-给定一个矩阵，如果某个元素为零，把所在的行和所在的列都设为零"><a href="#73-给定一个矩阵，如果某个元素为零，把所在的行和所在的列都设为零" class="headerlink" title="73 给定一个矩阵，如果某个元素为零，把所在的行和所在的列都设为零"></a>73 给定一个矩阵，如果某个元素为零，把所在的行和所在的列都设为零</h2><p>一种可以接受的方法是使用 O(m+n) 的空间，记录哪行哪列需要设为零</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setZeroes</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">row</span><span class="params">(m)</span>, <span class="title">column</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>)</span><br><span class="line">                row[i] = <span class="literal">true</span>, column[j] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            <span class="keyword">if</span> (row[i] || column[j])</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="74-搜索矩阵，矩阵每行从左到右依次增大，每行都比上一行大"><a href="#74-搜索矩阵，矩阵每行从左到右依次增大，每行都比上一行大" class="headerlink" title="74 搜索矩阵，矩阵每行从左到右依次增大，每行都比上一行大"></a>74 搜索矩阵，矩阵每行从左到右依次增大，每行都比上一行大</h2><p>当做数组直接二分搜索就可以了</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="type">int</span>** matrix, <span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = row * col - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (matrix[mid/col][mid%col] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (matrix[mid/col][mid%col] == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="75-颜色排序，每个物体有颜色属性，把他们按照-RGB-的顺序排序-🇳🇱国旗问题）"><a href="#75-颜色排序，每个物体有颜色属性，把他们按照-RGB-的顺序排序-🇳🇱国旗问题）" class="headerlink" title="75 颜色排序，每个物体有颜色属性，把他们按照 RGB 的顺序排序 (🇳🇱国旗问题）"></a>75 颜色排序，每个物体有颜色属性，把他们按照 RGB 的顺序排序 (🇳🇱国旗问题）</h2><p>一种方法是简单地 2 pass 解法，遍历一遍计数再输出。另一种方法是把红色往前交换，蓝色往后交换</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> t = *a; *a = *b; *b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sortColors</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> RED = <span class="number">0</span>, GREEN = <span class="number">1</span>, BLUE = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> reds = <span class="number">0</span>,  blues = numsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= blues; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (nums[i] == BLUE &amp;&amp; i &lt; blues) swap(&amp;nums[i], &amp;nums[blues--]);</span><br><span class="line">        <span class="keyword">while</span> (nums[i] == RED &amp;&amp; i &gt; reds) swap(&amp;nums[i], &amp;nums[reds++]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>76 跳过</p>
<h2 id="77-给定数字-n-和-k，生成从-n-中取出-k-个数字的所有情况"><a href="#77-给定数字-n-和-k，生成从-n-中取出-k-个数字的所有情况" class="headerlink" title="77 给定数字 n 和 k，生成从 n 中取出 k 个数字的所有情况"></a>77 给定数字 n 和 k，生成从 n 中取出 k 个数字的所有情况</h2><p>数学上的组合，使用回溯来做，对状态空间进行深度搜索。</p>
<p>回溯方法通常适合对状态空间树的深度优先搜索相结合的，当一个解已经不满足条件时，剪枝；<br>如果满足条件，直到找到完全解未知。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组合是不要求顺序的</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; k)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(<span class="number">0</span>, k)</span></span>;</span><br><span class="line">    <span class="built_in">combine</span>(result, temp, <span class="number">0</span>, <span class="number">0</span>, n, k);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">combine</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result, vector&lt;<span class="type">int</span>&gt;&amp; temp, <span class="type">int</span> start, <span class="type">int</span> count, <span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 回溯条件，找到了一个解</span></span><br><span class="line">    <span class="keyword">if</span> (count == k) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 深度优先搜索</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; n; i++) &#123;</span><br><span class="line">        temp.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 只搜索比 i 大的即可</span></span><br><span class="line">        <span class="built_in">combine</span>(result, temp, i+ <span class="number">1</span>, count+<span class="number">1</span>, n, k);</span><br><span class="line">        temp.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="78-给定一个集合，找到它的所有子集"><a href="#78-给定一个集合，找到它的所有子集" class="headerlink" title="78 给定一个集合，找到它的所有子集"></a>78 给定一个集合，找到它的所有子集</h2><p>这道题至少有 3 种解法：</p>
<ol>
<li>DFS，我们知道对于 n 个元素的集合，有 2^n 个子集，通过每个元素在不在子集中构造一个状态空间树</li>
<li>类似于电话键盘生成字母，迭代</li>
<li>巧妙的利用 1..2^n 对应</li>
</ol>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// use backtracking and do a dfs search</span></span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> result;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">    <span class="built_in">subsets</span>(nums, result, temp, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for each solution, the can be divided into two sub solutions: in or out</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">subsets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result, vector&lt;<span class="type">int</span>&gt; temp, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; t = temp;</span><br><span class="line">    <span class="built_in">subsets</span>(nums, result, temp, i + <span class="number">1</span>);</span><br><span class="line">    temp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">    <span class="built_in">subsets</span>(nums, result, temp, i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iterative</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    result.<span class="built_in">push_back</span>(&#123;&#125;);</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    result.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>, nums[<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> size = result.<span class="built_in">size</span>(); <span class="comment">// notice the cached size</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> new_subset = result[j];</span><br><span class="line">            new_subset.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">sort</span>(new_subset.<span class="built_in">begin</span>(), new_subset.<span class="built_in">end</span>());</span><br><span class="line">            result.<span class="built_in">push_back</span>(new_subset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tricky</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="type">int</span> size = (<span class="number">1</span> &lt;&lt; nums.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; subset;</span><br><span class="line">        <span class="type">int</span> k = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k &amp; <span class="number">0x1</span>)</span><br><span class="line">                subset.<span class="built_in">push_back</span>(nums[j]);</span><br><span class="line">            k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(subset.<span class="built_in">begin</span>(), subset.<span class="built_in">end</span>());</span><br><span class="line">        result.<span class="built_in">push_back</span>(subset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="79-给定一个二维字符数组，查找一个单词是否能够有连续的字母构成，不能交叉"><a href="#79-给定一个二维字符数组，查找一个单词是否能够有连续的字母构成，不能交叉" class="headerlink" title="79 给定一个二维字符数组，查找一个单词是否能够有连续的字母构成，不能交叉"></a>79 给定一个二维字符数组，查找一个单词是否能够有连续的字母构成，不能交叉</h2><p>也是深度优先的做法，首先找到开始的字母，然后依次向上下左右查找，注意还需要统计有没有访问过</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> row = board.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> col = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(row, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt; (col, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == word[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">findNext</span>(board, word, visited, i, j, <span class="number">0</span>))</span><br><span class="line">                    found = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">findNext</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string&amp; word, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == word.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (m &gt;= board.<span class="built_in">size</span>() || n &gt;= board[<span class="number">0</span>].<span class="built_in">size</span>() || m &lt; <span class="number">0</span> || n &lt; <span class="number">0</span>|| visited[m][n] || board[m][n] != word[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">char</span> temp = board[m][n];</span><br><span class="line">    board[m][n] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> exist = <span class="built_in">findNext</span>(board, word, visited, m + <span class="number">1</span>, n, i+<span class="number">1</span>) ||</span><br><span class="line">        <span class="built_in">findNext</span>(board, word, visited, m - <span class="number">1</span>, n, i+<span class="number">1</span>) ||</span><br><span class="line">        <span class="built_in">findNext</span>(board, word, visited, m, n+<span class="number">1</span>, i+<span class="number">1</span>) ||</span><br><span class="line">        <span class="built_in">findNext</span>(board, word, visited, m, n<span class="number">-1</span>, i+<span class="number">1</span>);</span><br><span class="line">    board[m][n] = temp;</span><br><span class="line">    <span class="keyword">return</span> exist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="80-从排序数组中删除重复元素，但是允许一个元素重复出现两次"><a href="#80-从排序数组中删除重复元素，但是允许一个元素重复出现两次" class="headerlink" title="80 从排序数组中删除重复元素，但是允许一个元素重复出现两次"></a>80 从排序数组中删除重复元素，但是允许一个元素重复出现两次</h2><p>巧妙地解法，和<code>i-2</code>的元素对比</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!nums || numsSize &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>, counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span> || nums[i] != nums[len<span class="number">-2</span>])</span><br><span class="line">            nums[len++] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="81-在被翻转的数组中查找元素，可能包含重复元素"><a href="#81-在被翻转的数组中查找元素，可能包含重复元素" class="headerlink" title="81 在被翻转的数组中查找元素，可能包含重复元素"></a>81 在被翻转的数组中查找元素，可能包含重复元素</h2><p>经典题目，还是一个二分查找问题，只是要分很多种情况</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (A[mid] == key)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//return m in Search in Rotated Array I</span></span><br><span class="line">        <span class="keyword">if</span> (A[left] &lt; A[mid]) &#123; <span class="comment">//left half is sorted</span></span><br><span class="line">            <span class="keyword">if</span> (A[left] &lt;= key &amp;&amp; key &lt; A[mid])</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (A[left] &gt; A[mid]) &#123; <span class="comment">//right half is sorted</span></span><br><span class="line">            <span class="keyword">if</span> (A[mid] &lt; key &amp;&amp; key &lt;= A[right])</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// A[left] == A[mid]</span></span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="82-从已经排序的链表中删除所有重复过的元素，只留下只出现一次的元素"><a href="#82-从已经排序的链表中删除所有重复过的元素，只留下只出现一次的元素" class="headerlink" title="82 从已经排序的链表中删除所有重复过的元素，只留下只出现一次的元素"></a>82 从已经排序的链表中删除所有重复过的元素，只留下只出现一次的元素</h2><p>考察链表操作</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">deleteDuplicates</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>, *<span class="title">p</span> =</span> &amp;dummy;</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; p-&gt;next &amp;&amp; p-&gt;next-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next-&gt;val == p-&gt;next-&gt;next-&gt;val) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">distinct</span> =</span> p-&gt;next;</span><br><span class="line">            <span class="type">int</span> dup = p-&gt;next-&gt;val;</span><br><span class="line">            <span class="keyword">while</span> (distinct &amp;&amp; distinct-&gt;val == dup) &#123;</span><br><span class="line">                distinct = distinct-&gt;next; <span class="comment">// <span class="doctag">TODO:</span> fix mem leak</span></span><br><span class="line">            &#125;</span><br><span class="line">            p-&gt;next = distinct;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="83-从已经排序的链表中删除所有重复过的元素，但是重复过的也留下一个，即，使新链表不重复"><a href="#83-从已经排序的链表中删除所有重复过的元素，但是重复过的也留下一个，即，使新链表不重复" class="headerlink" title="83 从已经排序的链表中删除所有重复过的元素，但是重复过的也留下一个，即，使新链表不重复"></a>83 从已经排序的链表中删除所有重复过的元素，但是重复过的也留下一个，即，使新链表不重复</h2><p>同样是考察链表基本操作</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">deleteDuplicates</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>, *<span class="title">p</span> =</span> &amp;dummy; dummy.next = head; dummy.val = head-&gt;val + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; p-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val == p-&gt;next-&gt;val) &#123;</span><br><span class="line">            <span class="type">int</span> dup = p-&gt;val;</span><br><span class="line">            <span class="keyword">while</span> (p-&gt;next &amp;&amp; p-&gt;next-&gt;val == dup)</span><br><span class="line">                p-&gt;next = p-&gt;next-&gt;next; <span class="comment">// <span class="doctag">TODO:</span> fix mem leak</span></span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="84-在柱状图中查找最大的矩形"><a href="#84-在柱状图中查找最大的矩形" class="headerlink" title="84 在柱状图中查找最大的矩形"></a>84 在柱状图中查找最大的矩形</h2><p>见注释</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    height.<span class="built_in">push_back</span>(<span class="number">0</span>); <span class="comment">// dummy end</span></span><br><span class="line">    <span class="type">int</span> result  =<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 总结，对于需要查找上一次最大元素的问题，可以考虑使用栈存储</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; height.<span class="built_in">size</span>(); ) &#123;</span><br><span class="line">        <span class="comment">// 当遇到更高的柱子时候，先存入堆栈</span></span><br><span class="line">        <span class="keyword">if</span> (stk.<span class="built_in">empty</span>() || height[i] &gt; height[stk.<span class="built_in">top</span>()]) <span class="comment">// meet higher</span></span><br><span class="line">            stk.<span class="built_in">push</span>(i++);</span><br><span class="line">        <span class="comment">// 当遇到低一些的柱子时候，计算这些柱子到上一个更矮的柱子之间的最大举行，如果已经清空，说明之前所有柱子都更低</span></span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// lower</span></span><br><span class="line">            <span class="type">int</span> h = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            result = <span class="built_in">max</span>(result, height[h] * (stk.<span class="built_in">empty</span>() ? i : i - stk.<span class="built_in">top</span>() <span class="number">-1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="85-最大的长方形"><a href="#85-最大的长方形" class="headerlink" title="85 最大的长方形"></a>85 最大的长方形</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">maximalRectangle</span><span class="params">(<span class="type">char</span>** matrix, <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!matrix) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left[col], right[col], height[col];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; col; i++)</span><br><span class="line">        left[i] = <span class="number">0</span>, right[i] = col, height[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="type">int</span> cur_left = <span class="number">0</span>, cur_right = col;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>)  <span class="comment">// 在第 j 列的高度</span></span><br><span class="line">                height[j]++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                height[j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                left[j] = max(left[j], cur_left);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left[j] = <span class="number">0</span>, cur_left = j + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = col - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                right[j] = min(right[j], cur_right);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right[j] = col, cur_right = j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">            area = max(area, (right[j] - left[j]) * height[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="86-链表分区，要求把小于某个值得元素全都放到前面"><a href="#86-链表分区，要求把小于某个值得元素全都放到前面" class="headerlink" title="86 链表分区，要求把小于某个值得元素全都放到前面"></a>86 链表分区，要求把小于某个值得元素全都放到前面</h2><p>对于链表这道题很简单，分两个列表在合并就好了，问题是当我们处理类似的数组问题时，也有一种巧妙地 O(n) 的解法</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">partition</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">small</span>, *<span class="title">psmall</span> =</span> &amp;small; <span class="comment">// double dummy head</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">big</span>, *<span class="title">pbig</span> =</span> &amp;big;</span><br><span class="line">    psmall-&gt;next = pbig-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;val &lt; x) &#123;</span><br><span class="line">            psmall-&gt;next = head;</span><br><span class="line">            psmall = psmall-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pbig-&gt;next = head;</span><br><span class="line">            pbig = pbig-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    psmall-&gt;next = big.next;</span><br><span class="line">    pbig-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> small.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="87-把字符串分区后，交换得到的字符串"><a href="#87-把字符串分区后，交换得到的字符串" class="headerlink" title="87 把字符串分区后，交换得到的字符串"></a>87 把字符串分区后，交换得到的字符串</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isScramble</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s1==s2)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先判断字符是否一致</span></span><br><span class="line">    <span class="type">int</span> len = s1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> count[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">        count[s1[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        count[s2[i]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">        <span class="keyword">if</span>(count[i]!=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">isScramble</span>(s1.<span class="built_in">substr</span>(<span class="number">0</span>,i), s2.<span class="built_in">substr</span>(<span class="number">0</span>,i)) &amp;&amp; <span class="built_in">isScramble</span>(s1.<span class="built_in">substr</span>(i), s2.<span class="built_in">substr</span>(i)))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">isScramble</span>(s1.<span class="built_in">substr</span>(<span class="number">0</span>,i), s2.<span class="built_in">substr</span>(len-i)) &amp;&amp; <span class="built_in">isScramble</span>(s1.<span class="built_in">substr</span>(i), s2.<span class="built_in">substr</span>(<span class="number">0</span>,len-i)))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="88-合并已排序数组，要求合并到其中一个空间较大的数组中"><a href="#88-合并已排序数组，要求合并到其中一个空间较大的数组中" class="headerlink" title="88 合并已排序数组，要求合并到其中一个空间较大的数组中"></a>88 合并已排序数组，要求合并到其中一个空间较大的数组中</h2><p>对于这种要求 in-place 的算法，从后往前往往可以解决</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>* nums1, <span class="type">int</span> m, <span class="type">int</span>* nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = m + n - <span class="number">1</span>;</span><br><span class="line">    m--, n--;</span><br><span class="line">    <span class="keyword">while</span> (m &gt;= <span class="number">0</span> &amp;&amp; n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[m] &gt; nums2[n]) &#123;</span><br><span class="line">            nums1[len--] = nums1[m--];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums1[len--] = nums2[n--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        nums1[n] = nums2[n];</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="89-生成格雷码-Gray-Code"><a href="#89-生成格雷码-Gray-Code" class="headerlink" title="89 生成格雷码 (Gray Code)"></a>89 生成格雷码 (Gray Code)</h2><p>记住格雷码的生成规则</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">grayCode</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++) &#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>((i &gt;&gt; <span class="number">1</span>) ^ i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="90-由给定元素生成子集，可能包含重复元素"><a href="#90-由给定元素生成子集，可能包含重复元素" class="headerlink" title="90 由给定元素生成子集，可能包含重复元素"></a>90 由给定元素生成子集，可能包含重复元素</h2><p>使用了和手机键盘生成字符串号码类似的迭代算法，注意其中对重复元素的处理，当然也可以用 DFS 来做</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; sets;</span><br><span class="line">    sets.<span class="built_in">push_back</span>(&#123;&#125;);</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 处理包含重复元素的一半需要预排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ) &#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// dup count</span></span><br><span class="line">        <span class="keyword">while</span> (count + i &lt; nums.<span class="built_in">size</span>() &amp;&amp; nums[count+i] == nums[i])</span><br><span class="line">            count++;</span><br><span class="line">        <span class="type">int</span> prev_n = sets.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; prev_n; j++) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; instance = sets[j];</span><br><span class="line">            <span class="comment">// put dup element `count` times</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; count; k++) &#123;</span><br><span class="line">                instance.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                sets.<span class="built_in">push_back</span>(instance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i += count;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="91-给定一个数组只包含-1-9，可以用-1-26-代表字母，求出从其中能都得到多少字符串"><a href="#91-给定一个数组只包含-1-9，可以用-1-26-代表字母，求出从其中能都得到多少字符串" class="headerlink" title="91 给定一个数组只包含 1-9，可以用 1-26 代表字母，求出从其中能都得到多少字符串"></a>91 给定一个数组只包含 1-9，可以用 1-26 代表字母，求出从其中能都得到多少字符串</h2><p>使用动态规划，但是注意其中 0 的处理，很玄妙</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">numDecodings</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!s || <span class="built_in">strlen</span>(s) == <span class="number">0</span> || s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> r1 = <span class="number">1</span>, r2 = <span class="number">1</span>; <span class="comment">// r1: 前一个字符， r2：前两个字符</span></span><br><span class="line">    <span class="type">char</span>* p = s++; <span class="comment">// 上一个字符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*s == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">             r1 = <span class="number">0</span>; <span class="comment">// 0 不能单独构成字母</span></span><br><span class="line">        <span class="keyword">if</span> (*p == <span class="string">&#x27;1&#x27;</span> || *p == <span class="string">&#x27;2&#x27;</span> &amp;&amp; *s &lt; <span class="string">&#x27;7&#x27;</span>) &#123; <span class="comment">// 形成两种可能</span></span><br><span class="line">            <span class="type">int</span> t = r1;</span><br><span class="line">            r1 = r2 + r1;</span><br><span class="line">            r2 = t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r2 = r1; <span class="comment">// 新加入的数字只能单独构成字母</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p = s++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="92-在给定区间上翻转数组"><a href="#92-在给定区间上翻转数组" class="headerlink" title="92 在给定区间上翻转数组"></a>92 在给定区间上翻转数组</h2><p>同样是数组操作细节题</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseBetween</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (m == n) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>, *<span class="title">p</span> =</span> &amp;dummy, * small_node, * big_node; <span class="comment">// actually the prev ones</span></span><br><span class="line">    dummy.next = head;</span><br><span class="line">    n -= m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (--m) <span class="comment">// m starts from 1, so not m--</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">start</span> =</span> p-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span> =</span> start-&gt;next;</span><br><span class="line">        start-&gt;next = next-&gt;next;</span><br><span class="line">        next-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="93-恢复-IP-地址，给定一个字符串，适当插入点，一共有多少种方式构成-IP-地址"><a href="#93-恢复-IP-地址，给定一个字符串，适当插入点，一共有多少种方式构成-IP-地址" class="headerlink" title="93 恢复 IP 地址，给定一个字符串，适当插入点，一共有多少种方式构成 IP 地址"></a>93 恢复 IP 地址，给定一个字符串，适当插入点，一共有多少种方式构成 IP 地址</h2><p>又是一道 DFS 的题，注意对于字符串问题如何处理</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="built_in">restore</span>(result, s, <span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">restore</span><span class="params">(vector&lt;string&gt;&amp; result, string&amp; s, string restored, <span class="type">int</span> start, <span class="type">int</span> dots)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dots &gt; <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (dots == <span class="number">4</span> &amp;&amp; start == s.<span class="built_in">size</span>())</span><br><span class="line">        result.<span class="built_in">push_back</span>(restored);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (start + i &gt; s.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        string part = s.<span class="built_in">substr</span>(start, i);</span><br><span class="line">        <span class="keyword">if</span> (part[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; part.<span class="built_in">size</span>() &gt; <span class="number">1</span> || i == <span class="number">3</span> &amp;&amp; <span class="built_in">stoi</span>(part) &gt; <span class="number">255</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">restore</span>(result, s, restored + part + (dots==<span class="number">3</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;.&quot;</span>), start + i, dots + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="94-中序遍历二叉树"><a href="#94-中序遍历二叉树" class="headerlink" title="94 中序遍历二叉树"></a>94 中序遍历二叉树</h2><p>当然是使用栈了</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    stack&lt;TreeNode*&gt; stk;</span><br><span class="line">    TreeNode* current = root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() || current) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current) &#123;</span><br><span class="line">            stk.<span class="built_in">push</span>(current);</span><br><span class="line">            current = current-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(current-&gt;val);</span><br><span class="line">            current = current-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>递归解法</p>
<details>
    <summary>go 解答</summary>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    left := inorderTraversal(root.Left)</span><br><span class="line">    right := inorderTraversal(root.Right)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">append</span>(<span class="built_in">append</span>(left, root.Val), right...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="95-生成二叉树，同下题一样"><a href="#95-生成二叉树，同下题一样" class="headerlink" title="95 生成二叉树，同下题一样"></a>95 生成二叉树，同下题一样</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gen</span>(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;TreeNode*&gt; <span class="title">gen</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    vector&lt;TreeNode*&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> leftTrees = <span class="built_in">gen</span>(start, i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">auto</span> rightTrees = <span class="built_in">gen</span>(i + <span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; l : leftTrees) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; r : rightTrees) &#123;</span><br><span class="line">                <span class="keyword">auto</span> root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(i);</span><br><span class="line">                root-&gt;left = l;</span><br><span class="line">                root-&gt;right = r;</span><br><span class="line">                result.<span class="built_in">push_back</span>(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="96-给定数字-n，从-1-到-n-作为节点有多少种方式生成二叉树"><a href="#96-给定数字-n，从-1-到-n-作为节点有多少种方式生成二叉树" class="headerlink" title="96 给定数字 n，从 1 到 n 作为节点有多少种方式生成二叉树"></a>96 给定数字 n，从 1 到 n 作为节点有多少种方式生成二叉树</h2><p>这道题看似是树，实际上是一个动态规划问题。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* dp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * (n+<span class="number">1</span>));</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++) <span class="comment">// 依次选取第 k 个点作为根</span></span><br><span class="line">            num += dp[j - <span class="number">1</span>] * dp[i - j];</span><br><span class="line">        dp[i] = num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="97-给定两个字符串交叉是否能够构成第三个字符串"><a href="#97-给定两个字符串交叉是否能够构成第三个字符串" class="headerlink" title="97 给定两个字符串交叉是否能够构成第三个字符串"></a>97 给定两个字符串交叉是否能够构成第三个字符串</h2><p>这道题是一道二维的 DP 问题，因为需要对于每个字符串的每个位置用另一个字符串尝试匹配</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isInterleave</span><span class="params">(<span class="type">char</span>* s1, <span class="type">char</span>* s2, <span class="type">char</span>* s3)</span> &#123;</span><br><span class="line">    <span class="type">int</span> l1 = <span class="built_in">strlen</span>(s1), l2 = <span class="built_in">strlen</span>(s2), l3 = <span class="built_in">strlen</span>(s3);</span><br><span class="line">    <span class="keyword">if</span> (l1 + l2 != l3) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 在 i+j 位置 s1[i] s2[j] 是否能够构成 s[i+j]</span></span><br><span class="line">    <span class="type">bool</span>** dp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">bool</span>*) * (l1 + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= l1; i++)</span><br><span class="line">        dp[i] = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">bool</span>) * (l2 + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= l1; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= l2; j++)</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = (dp[i][j<span class="number">-1</span>] &amp;&amp; s2[j<span class="number">-1</span>] == s3[i+j<span class="number">-1</span>]); <span class="comment">// 注意：赋值的优先级更高</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = (dp[i<span class="number">-1</span>][j] &amp;&amp; s1[i<span class="number">-1</span>] == s3[i+j<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = (dp[i<span class="number">-1</span>][j] &amp;&amp; s1[i<span class="number">-1</span>] == s3[i+j<span class="number">-1</span>] || dp[i][j<span class="number">-1</span>] &amp;&amp; s2[j<span class="number">-1</span>] == s3[i+j<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">return</span> dp[l1][l2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="98-验证二叉搜索树是否合法"><a href="#98-验证二叉搜索树是否合法" class="headerlink" title="98 验证二叉搜索树是否合法"></a>98 验证二叉搜索树是否合法</h2><p>先序遍历即可</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">valid</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">long</span> left, <span class="type">long</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> root == <span class="literal">NULL</span> || root-&gt;val &gt; left &amp;&amp; root-&gt;val &lt; right &amp;&amp;</span><br><span class="line">        valid(root-&gt;left, left, root-&gt;val) &amp;&amp;</span><br><span class="line">        valid(root-&gt;right, root-&gt;val, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isValidBST</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> valid(root, INT_MIN - <span class="number">1l</span>, INT_MAX + <span class="number">1l</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="99-在二叉搜索树中有两个节点被调换了，找出这两个节点，并恢复该二叉树"><a href="#99-在二叉搜索树中有两个节点被调换了，找出这两个节点，并恢复该二叉树" class="headerlink" title="99 在二叉搜索树中有两个节点被调换了，找出这两个节点，并恢复该二叉树"></a>99 在二叉搜索树中有两个节点被调换了，找出这两个节点，并恢复该二叉树</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">prev</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">first</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">second</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    traverse(root-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (prev &amp;&amp; prev-&gt;val &gt; root-&gt;val) &#123;</span><br><span class="line">         <span class="keyword">if</span> (!first) first = prev;</span><br><span class="line">         second = root;</span><br><span class="line">    &#125;</span><br><span class="line">    prev = root;</span><br><span class="line">    traverse(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">recoverTree</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> &#123;</span><br><span class="line">    prev = first = second = <span class="literal">NULL</span>;</span><br><span class="line">    traverse(root);</span><br><span class="line">    <span class="keyword">if</span> (!first) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> temp = first-&gt;val;</span><br><span class="line">    first-&gt;val = second-&gt;val;</span><br><span class="line">    second-&gt;val = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="100-判断是否是相同的树"><a href="#100-判断是否是相同的树" class="headerlink" title="100 判断是否是相同的树"></a>100 判断是否是相同的树</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isSameTree</span><span class="params">(<span class="keyword">struct</span> TreeNode *p, <span class="keyword">struct</span> TreeNode *q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || q == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> p == q;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;val == q-&gt;val</span><br><span class="line">            &amp;&amp; isSameTree(p-&gt;left, q-&gt;left)</span><br><span class="line">            &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="101-判断是不是左右对称的树"><a href="#101-判断是不是左右对称的树" class="headerlink" title="101 判断是不是左右对称的树"></a>101 判断是不是左右对称的树</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">sym</span><span class="params">(<span class="keyword">struct</span> TreeNode* left, <span class="keyword">struct</span> TreeNode* right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &amp;&amp; !right || !left &amp;&amp; right)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> !left &amp;&amp; !right ||</span><br><span class="line">        left-&gt;val == right-&gt;val &amp;&amp;</span><br><span class="line">        sym(left-&gt;left, right-&gt;right) &amp;&amp;</span><br><span class="line">        sym(right-&gt;left, left-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isSymmetric</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> sym(root-&gt;left, root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="102-二叉树层序遍历"><a href="#102-二叉树层序遍历" class="headerlink" title="102 二叉树层序遍历"></a>102 二叉树层序遍历</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line">    vector&lt;TreeNode*&gt; current, next;</span><br><span class="line">    current.<span class="built_in">push_back</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!current.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        next.<span class="built_in">resize</span>(<span class="number">0</span>);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vals;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; current.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current[i]-&gt;left)</span><br><span class="line">                next.<span class="built_in">push_back</span>(current[i]-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (current[i]-&gt;right)</span><br><span class="line">                next.<span class="built_in">push_back</span>(current[i]-&gt;right);</span><br><span class="line">            vals.<span class="built_in">push_back</span>(current[i]-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="built_in">push_back</span>(vals);</span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="103-二叉树-ZigZag-层序遍历"><a href="#103-二叉树-ZigZag-层序遍历" class="headerlink" title="103 二叉树 ZigZag 层序遍历"></a>103 二叉树 ZigZag 层序遍历</h2><p>这道题更好的做法是使用一个栈，从而使得每行的顺序都是上一行的翻转</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line">    vector&lt;TreeNode*&gt; current, next;</span><br><span class="line">    current.<span class="built_in">push_back</span>(root);</span><br><span class="line">    <span class="type">bool</span> odd = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!current.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        next.<span class="built_in">resize</span>(<span class="number">0</span>);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vals;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; current.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current[i]-&gt;left)</span><br><span class="line">                next.<span class="built_in">push_back</span>(current[i]-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (current[i]-&gt;right)</span><br><span class="line">                next.<span class="built_in">push_back</span>(current[i]-&gt;right);</span><br><span class="line">            vals.<span class="built_in">push_back</span>(current[i]-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!odd) <span class="built_in">reverse</span>(vals.<span class="built_in">begin</span>(), vals.<span class="built_in">end</span>());</span><br><span class="line">        odd = !odd;</span><br><span class="line">        result.<span class="built_in">push_back</span>(vals);</span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="104-树的最大深度"><a href="#104-树的最大深度" class="headerlink" title="104 树的最大深度"></a>104 树的最大深度</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left = maxDepth(root-&gt;left), right = maxDepth(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> (left &gt; right ?left : right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="105-从前序遍历和中序遍历生成生二叉树"><a href="#105-从前序遍历和中序遍历生成生二叉树" class="headerlink" title="105 从前序遍历和中序遍历生成生二叉树"></a>105 从前序遍历和中序遍历生成生二叉树</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">build</span><span class="params">(<span class="type">int</span>* prestart, <span class="type">int</span>* preend, <span class="type">int</span>* instart, <span class="type">int</span>* inend)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">root</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    root-&gt;val = *prestart;</span><br><span class="line">    root-&gt;left = root-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prestart == preend)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* root_inorder = instart;</span><br><span class="line">    <span class="keyword">while</span> (root_inorder &lt;= inend &amp;&amp; *root_inorder != *prestart)</span><br><span class="line">        root_inorder++;</span><br><span class="line">    <span class="type">int</span> left_len = root_inorder - instart;</span><br><span class="line">    <span class="type">int</span> right_len = inend - root_inorder;</span><br><span class="line">    <span class="keyword">if</span> (left_len &gt; <span class="number">0</span>)</span><br><span class="line">        root-&gt;left = build(prestart + <span class="number">1</span>, prestart + left_len, instart, root_inorder - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (right_len &gt; <span class="number">0</span>)</span><br><span class="line">        root-&gt;right = build(prestart + left_len + <span class="number">1</span>, preend, root_inorder + <span class="number">1</span>, inend);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// m always equals n, otherwise it&#x27;s bad input</span></span><br><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>* preorder, <span class="type">int</span> m, <span class="type">int</span>* inorder, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> build(preorder, preorder + n - <span class="number">1</span>, inorder, inorder + n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="106-从中序遍历和后序遍历生成二叉树"><a href="#106-从中序遍历和后序遍历生成二叉树" class="headerlink" title="106 从中序遍历和后序遍历生成二叉树"></a>106 从中序遍历和后序遍历生成二叉树</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">build</span><span class="params">(<span class="type">int</span>* instart, <span class="type">int</span>* inend, <span class="type">int</span>* poststart, <span class="type">int</span>* postend)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">root</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    root-&gt;val = *postend;</span><br><span class="line">    root-&gt;left = root-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (poststart == postend)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* root_inorder = instart;</span><br><span class="line">    <span class="keyword">while</span> (root_inorder &lt;= inend &amp;&amp; *root_inorder != *postend)</span><br><span class="line">        root_inorder++;</span><br><span class="line">    <span class="type">int</span> left_len = root_inorder - instart;</span><br><span class="line">    <span class="type">int</span> right_len = inend - root_inorder;</span><br><span class="line">    <span class="keyword">if</span> (left_len &gt; <span class="number">0</span>)</span><br><span class="line">        root-&gt;left = build(instart, root_inorder - <span class="number">1</span>, poststart, poststart + left_len - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (right_len &gt; <span class="number">0</span>)</span><br><span class="line">        root-&gt;right = build(root_inorder + <span class="number">1</span>, inend, poststart + left_len, postend - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>* inorder, <span class="type">int</span> m, <span class="type">int</span>* postorder, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> build(inorder, inorder + n - <span class="number">1</span>, postorder, postorder +n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="107-二叉树层序遍历，但要生成翻转的遍历序列"><a href="#107-二叉树层序遍历，但要生成翻转的遍历序列" class="headerlink" title="107 二叉树层序遍历，但要生成翻转的遍历序列"></a>107 二叉树层序遍历，但要生成翻转的遍历序列</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrderBottom</span>(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line">    vector&lt;TreeNode*&gt; current, next;</span><br><span class="line">    current.<span class="built_in">push_back</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!current.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        next.<span class="built_in">resize</span>(<span class="number">0</span>);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vals;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; current.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current[i]-&gt;left)</span><br><span class="line">                next.<span class="built_in">push_back</span>(current[i]-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (current[i]-&gt;right)</span><br><span class="line">                next.<span class="built_in">push_back</span>(current[i]-&gt;right);</span><br><span class="line">            vals.<span class="built_in">push_back</span>(current[i]-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="built_in">push_back</span>(vals);</span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="108-把排序数组转化为二叉树"><a href="#108-把排序数组转化为二叉树" class="headerlink" title="108 把排序数组转化为二叉树"></a>108 把排序数组转化为二叉树</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">struct</span> TreeNode* <span class="title function_">bst</span><span class="params">(<span class="type">int</span>* left, <span class="type">int</span>* right)</span> &#123;</span><br><span class="line">    <span class="type">int</span>* mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">root</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    root-&gt;val = *mid;</span><br><span class="line">    root-&gt;left = root-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; mid)</span><br><span class="line">        root-&gt;left = bst(left, mid<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; right)</span><br><span class="line">        root-&gt;right = bst(mid+<span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> bst(nums, nums + n <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="109-把排序列表转化为二叉树"><a href="#109-把排序列表转化为二叉树" class="headerlink" title="109 把排序列表转化为二叉树"></a>109 把排序列表转化为二叉树</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">list</span>;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">len</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (head)</span><br><span class="line">        head = head-&gt;next, l++;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">bst</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">root</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    root-&gt;left = bst(n/<span class="number">2</span>);</span><br><span class="line">    root-&gt;val = <span class="built_in">list</span>-&gt;val;</span><br><span class="line">    <span class="built_in">list</span> = <span class="built_in">list</span>-&gt;next;</span><br><span class="line">    root-&gt;right = bst(n - n / <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">sortedListToBST</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span> = head;</span><br><span class="line">    <span class="keyword">return</span> bst(len(head));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110 平衡二叉树"></a>110 平衡二叉树</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">height</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left = height(root-&gt;left);</span><br><span class="line">    <span class="type">int</span> right = height(root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right + <span class="number">1</span> || right &gt; left + <span class="number">1</span> || left == <span class="number">-1</span> || right == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> (left &gt; right ? left : right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isBalanced</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> height(root) != <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="111-二叉树最小高度"><a href="#111-二叉树最小高度" class="headerlink" title="111 二叉树最小高度"></a>111 二叉树最小高度</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left = minDepth(root-&gt;left);</span><br><span class="line">    <span class="type">int</span> right = minDepth(root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span> (!right) <span class="keyword">return</span> left + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!left) <span class="keyword">return</span> right + <span class="number">1</span>; <span class="comment">// tricky here, 当有空节点时，不能返回 0，而是返回另一个值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (left &lt; right ? left : right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="112-二叉树中是否存在和为某个数的路径"><a href="#112-二叉树中是否存在和为某个数的路径" class="headerlink" title="112 二叉树中是否存在和为某个数的路径"></a>112 二叉树中是否存在和为某个数的路径</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">hasPathSum</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> sum == root-&gt;val;</span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root-&gt;left, sum - root-&gt;val) ||</span><br><span class="line">        hasPathSum(root-&gt;right, sum - root-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="113-接上题，把这个路径找出来"><a href="#113-接上题，把这个路径找出来" class="headerlink" title="113 接上题，把这个路径找出来"></a>113 接上题，把这个路径找出来</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="type">int</span> sum) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="built_in">getPaths</span>(result, path, root, sum);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getPaths</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result, vector&lt;<span class="type">int</span>&gt; path, TreeNode* root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; sum == root-&gt;val) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">getPaths</span>(result, path, root-&gt;left, sum - root-&gt;val);</span><br><span class="line">    <span class="built_in">getPaths</span>(result, path, root-&gt;right, sum - root-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="114-把二叉树扁平成列表"><a href="#114-把二叉树扁平成列表" class="headerlink" title="114 把二叉树扁平成列表"></a>114 把二叉树扁平成列表</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* prev;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">flatten</span>(root-&gt;right);</span><br><span class="line">    <span class="built_in">flatten</span>(root-&gt;left);</span><br><span class="line">    root-&gt;right = prev;</span><br><span class="line">    root-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    prev = root; <span class="comment">// last flattened element</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="115-通过删掉一些字母得到子序列，问有多少种方法能够得到子序列呢"><a href="#115-通过删掉一些字母得到子序列，问有多少种方法能够得到子序列呢" class="headerlink" title="115 通过删掉一些字母得到子序列，问有多少种方法能够得到子序列呢"></a>115 通过删掉一些字母得到子序列，问有多少种方法能够得到子序列呢</h2><p>使用 DP，</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Solution (DP):</span></span><br><span class="line"><span class="comment"> * 我们扫描字符串 s</span></span><br><span class="line"><span class="comment"> * Path[i][j] 代表 T.substr(1...i) 在 S(1...j) 不同的子序列的数量</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Path[i][j] = Path[i][j-1]            (discard S[j])</span></span><br><span class="line"><span class="comment"> *              +     Path[i-1][j-1]    (S[j] == T[i] and we are going to use S[j])</span></span><br><span class="line"><span class="comment"> *                 or 0                 (S[j] != T[i] so we could not use S[j])</span></span><br><span class="line"><span class="comment"> * while Path[0][j] = 1 and Path[i][0] = 0.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numDistinct</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m &gt; n)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">path</span>(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">            path[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) <span class="comment">// S</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="comment">// T</span></span><br><span class="line">                path[i][j] = path[i][j<span class="number">-1</span>] + (t[i<span class="number">-1</span>] == s[j<span class="number">-1</span>] ? path[i<span class="number">-1</span>][j<span class="number">-1</span>] : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> path[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="116-完全二叉树中把每个节点指向他这一层的右面的节点"><a href="#116-完全二叉树中把每个节点指向他这一层的右面的节点" class="headerlink" title="116 完全二叉树中把每个节点指向他这一层的右面的节点"></a>116 完全二叉树中把每个节点指向他这一层的右面的节点</h2><p>显然左节点的下一个节点是父节点的右节点，右节点的下一个节点是父节点下一个节点的左节点。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">connect</span><span class="params">(<span class="keyword">struct</span> TreeLinkNode *root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left)</span><br><span class="line">        root-&gt;left-&gt;next = root-&gt;right;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right)</span><br><span class="line">        root-&gt;right-&gt;next = root-&gt;next ? root-&gt;next-&gt;left : <span class="literal">NULL</span>;</span><br><span class="line">    connect(root-&gt;left);</span><br><span class="line">    connect(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="117-同上题，但是是任意的🌲"><a href="#117-同上题，但是是任意的🌲" class="headerlink" title="117 同上题，但是是任意的🌲"></a>117 同上题，但是是任意的🌲</h2><p>通过上一层已经被连接的 next 指针，顺序层序访问，从而连接下一层。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">connect</span><span class="params">(<span class="keyword">struct</span> TreeLinkNode *root)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeLinkNode</span>* <span class="title">head</span> =</span> root, * prev = <span class="literal">NULL</span>, *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (head) &#123; <span class="comment">// head 是每层的开始</span></span><br><span class="line">        p = head;</span><br><span class="line">        prev = head = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;left) &#123;</span><br><span class="line">                <span class="keyword">if</span> (prev)</span><br><span class="line">                    prev-&gt;next = p-&gt;left;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    head = p-&gt;left;</span><br><span class="line">                prev = p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (prev)</span><br><span class="line">                    prev-&gt;next = p-&gt;right;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    head = p-&gt;right;</span><br><span class="line">                prev = p-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118 杨辉三角"></a>118 杨辉三角</h2><p>注意坐标关系，不要被骗了</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generate</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">result</span>(n);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        result[i].<span class="built_in">resize</span>(i+<span class="number">1</span>);</span><br><span class="line">        result[i][<span class="number">0</span>] = result[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">            result[i][j] = result[i<span class="number">-1</span>][j<span class="number">-1</span>] + result[i<span class="number">-1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="119-返回杨辉三角的第-k-行"><a href="#119-返回杨辉三角的第-k-行" class="headerlink" title="119 返回杨辉三角的第 k 行"></a>119 返回杨辉三角的第 k 行</h2><p>要求只能使用 O(k) 的额外空间，比较蛋疼的是这里的 k 是从 0 计数的。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getRow</span><span class="params">(<span class="type">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">    rowIndex++;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; row;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rowIndex; i++) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">newRow</span><span class="params">(i+<span class="number">1</span>)</span></span>;</span><br><span class="line">        newRow[<span class="number">0</span>] = newRow[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">            newRow[j] = row[j<span class="number">-1</span>] + row[j];</span><br><span class="line">        <span class="built_in">swap</span>(row, newRow);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> row;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="120-给定一个类似杨辉三角形状的数组，求从顶部到底部的最短路径"><a href="#120-给定一个类似杨辉三角形状的数组，求从顶部到底部的最短路径" class="headerlink" title="120 给定一个类似杨辉三角形状的数组，求从顶部到底部的最短路径"></a>120 给定一个类似杨辉三角形状的数组，求从顶部到底部的最短路径</h2><p>显然是使用 DP，但是有一个问题，如果是 top down 的话，最后还需要遍历一下，而如果是 bottom up 就只需要返回 dp[0] 就好了。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minimumTotal</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(triangle.back())</span></span>; <span class="comment">// 复制最后一行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> layer = triangle.<span class="built_in">size</span>() - <span class="number">2</span>; layer &gt;= <span class="number">0</span>; layer--)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= layer; i++)</span><br><span class="line">            dp[i] = triangle[layer][i] + <span class="built_in">min</span>(dp[i], dp[i+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="121-买卖股票最佳时机，只能交易一次"><a href="#121-买卖股票最佳时机，只能交易一次" class="headerlink" title="121 买卖股票最佳时机，只能交易一次"></a>121 买卖股票最佳时机，只能交易一次</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>* prices, <span class="type">int</span> pricesSize)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pricesSize &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> profit = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> min = prices[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 从前到后依次遍历，如果有更好的收益更新，或者更新 min，限制条件是先出现最小值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pricesSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &gt; min) &#123;</span><br><span class="line">                profit = max(profit, prices[i] - min);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            min = prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="122-买卖股票的最佳时机，可以做任意多比交易"><a href="#122-买卖股票的最佳时机，可以做任意多比交易" class="headerlink" title="122 买卖股票的最佳时机，可以做任意多比交易"></a>122 买卖股票的最佳时机，可以做任意多比交易</h2><p>有两种解法，一种是不断做交易，完全不考虑交易次数，这种做法不符合实际情况。<br>另一种做法是模拟交易，这样会生成最少的交易次数，结果也是对的。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>* prices, <span class="type">int</span> pricesSize)</span></span><br><span class="line">    <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt; pricesSize<span class="number">-1</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> (prices[i+<span class="number">1</span>]&gt;prices[i])</span><br><span class="line">            total += prices[i+<span class="number">1</span>]-prices[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>* prices, <span class="type">int</span> pricesSize)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!prices) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> profit = <span class="number">0</span>;<span class="type">bool</span> buy = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> min = prices[<span class="number">0</span>], max = prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pricesSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &lt; min &amp;&amp; buy) &#123;</span><br><span class="line">            min = prices[i];</span><br><span class="line">            max = prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &gt; min &amp;&amp; buy)</span><br><span class="line">            buy = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &gt; max &amp;&amp; !buy)</span><br><span class="line">            max = prices[i];</span><br><span class="line">        <span class="keyword">if</span> ((prices[i] &lt; max || i == pricesSize - <span class="number">1</span>) &amp;&amp; !buy)&#123;</span><br><span class="line">            profit += max - min;</span><br><span class="line">            min = prices[i];</span><br><span class="line">            max = prices[i];</span><br><span class="line">            buy = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> profit;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="123-股票交易，限制只能交易两股"><a href="#123-股票交易，限制只能交易两股" class="headerlink" title="123 股票交易，限制只能交易两股"></a>123 股票交易，限制只能交易两股</h2><p>每次求解的是：卖出两股以后的最大值，刚刚买入第二股的最大值，卖出第一股时候的最大值，买入第一股时候的最大值。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> hold1 = INT_MIN, hold2 = INT_MIN;</span><br><span class="line">    <span class="type">int</span> release1 = <span class="number">0</span>, release2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : prices) &#123;</span><br><span class="line">        release2 = <span class="built_in">max</span>(release2, hold2 + i);</span><br><span class="line">        hold2 = <span class="built_in">max</span>(hold2, release1 - i);</span><br><span class="line">        release1 = <span class="built_in">max</span>(release1, hold1 + i);</span><br><span class="line">        hold1 = <span class="built_in">max</span>(hold1, -i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> release2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="124-二叉树路径最大和，路径可以从任意一个节点开始到任意一个节点结束"><a href="#124-二叉树路径最大和，路径可以从任意一个节点开始到任意一个节点结束" class="headerlink" title="124 二叉树路径最大和，路径可以从任意一个节点开始到任意一个节点结束"></a>124 二叉树路径最大和，路径可以从任意一个节点开始到任意一个节点结束</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">doSum</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span>* sum)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left = max(<span class="number">0</span>, doSum(root-&gt;left, sum));</span><br><span class="line">    <span class="type">int</span> right = max(<span class="number">0</span>, doSum(root-&gt;right, sum));</span><br><span class="line">    *sum = max(*sum, left+right+root-&gt;val);</span><br><span class="line">    <span class="keyword">return</span> max(left, right) + root-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum = INT_MIN;</span><br><span class="line">    doSum(root, &amp;sum);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>这道题是把最终答案放在了全局变量中，并采用了辅助函数的方法。全局变量中存储两条路径的和，<br>而返回值中存储当前子树中最长的单边。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.ans = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_maxPathSum</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 注意这里要取 max，以防添加了负路径</span></span><br><span class="line">        left = <span class="built_in">max</span>(<span class="number">0</span>, self._maxPathSum(root.left))</span><br><span class="line">        right = <span class="built_in">max</span>(<span class="number">0</span>, self._maxPathSum(root.right))</span><br><span class="line">        self.ans = <span class="built_in">max</span>(self.ans, left + right + root.val)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + root.val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxPathSum</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        self._maxPathSum(root)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br></pre></td></tr></table></figure>
</details>



<h2 id="125-给定一个字符串，只考虑字母和数字，忽略大小写，判断是否是回文字符串"><a href="#125-给定一个字符串，只考虑字母和数字，忽略大小写，判断是否是回文字符串" class="headerlink" title="125 给定一个字符串，只考虑字母和数字，忽略大小写，判断是否是回文字符串"></a>125 给定一个字符串，只考虑字母和数字，忽略大小写，判断是否是回文字符串</h2><p>太简单了，没啥可说的</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">char</span> l = s[left], r = s[right];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isalnum</span>(l) &amp;&amp; <span class="built_in">isalnum</span>(r)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">tolower</span>(l) != <span class="built_in">tolower</span>(r))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            left++, right--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isalnum</span>(l))</span><br><span class="line">                left++;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isalnum</span>(r))</span><br><span class="line">                right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="127-单词梯子"><a href="#127-单词梯子" class="headerlink" title="127 单词梯子"></a>127 单词梯子</h2><p>给定梯子，和开始单词和结束单词，最少需要多少个中间单词，才能变化过去，每次只能变化一个字母</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ladderLength</span><span class="params">(string beginWord, string endWord, unordered_set&lt;string&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">    unordered_set&lt;string&gt; beginSet, endSet, *set1, * set2;</span><br><span class="line">    beginSet.<span class="built_in">insert</span>(beginWord);</span><br><span class="line">    endSet.<span class="built_in">insert</span>(endWord);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dist = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (!beginSet.<span class="built_in">empty</span>() &amp;&amp; !endSet.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (beginSet.<span class="built_in">size</span>() &lt; endSet.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            set1 = &amp;beginSet;</span><br><span class="line">            set2 = &amp;endSet;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            set1 = &amp;endSet;</span><br><span class="line">            set2 = &amp;beginSet;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        unordered_set&lt;string&gt; temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> word : *set1) &#123; <span class="comment">// notice word in not ref</span></span><br><span class="line">            wordList.<span class="built_in">erase</span>(word);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; letter : word) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                    <span class="type">char</span> oldLetter = letter;</span><br><span class="line">                    letter = <span class="string">&#x27;a&#x27;</span> + i;</span><br><span class="line">                    <span class="keyword">if</span> (set2-&gt;<span class="built_in">find</span>(word) != set2-&gt;<span class="built_in">end</span>())</span><br><span class="line">                        <span class="keyword">return</span> dist;</span><br><span class="line">                    <span class="keyword">if</span> (wordList.<span class="built_in">find</span>(word) != wordList.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                        temp.<span class="built_in">insert</span>(word);</span><br><span class="line">                        wordList.<span class="built_in">erase</span>(word);</span><br><span class="line">                    &#125;</span><br><span class="line">                    letter = oldLetter;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dist++;</span><br><span class="line">        <span class="built_in">swap</span>(*set1, temp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="128-最长递增子序列"><a href="#128-最长递增子序列" class="headerlink" title="128 最长递增子序列"></a>128 最长递增子序列</h2><p>使用动态规划</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash; <span class="comment">// 每个元素和它们所在序列的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hash.<span class="built_in">find</span>(n) == hash.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="comment">// 查找两边的元素，如果找到，把新元素合并进去</span></span><br><span class="line">            <span class="type">int</span> left = hash.<span class="built_in">find</span>(n<span class="number">-1</span>) != hash.<span class="built_in">end</span>() ? hash[n<span class="number">-1</span>] : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> right = hash.<span class="built_in">find</span>(n+<span class="number">1</span>) != hash.<span class="built_in">end</span>() ? hash[n+<span class="number">1</span>] : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> sum = left + right + <span class="number">1</span>;</span><br><span class="line">            hash[n] = hash[n-left] = hash[n+right] = sum; <span class="comment">// 注意此处的更新，并不需要更新区间内的每个值，只需要更新边界即可</span></span><br><span class="line">            result = <span class="built_in">max</span>(result, sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="129-二叉树中只有-0-9-找出所有根节点到子节点的和"><a href="#129-二叉树中只有-0-9-找出所有根节点到子节点的和" class="headerlink" title="129 二叉树中只有 0-9 找出所有根节点到子节点的和"></a>129 二叉树中只有 0-9 找出所有根节点到子节点的和</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">        <span class="keyword">return</span> x * <span class="number">10</span> + root-&gt;val;</span><br><span class="line">    <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left)</span><br><span class="line">        val += sum(root-&gt;left, x * <span class="number">10</span> + root-&gt;val);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right)</span><br><span class="line">        val += sum(root-&gt;right, x * <span class="number">10</span> + root-&gt;val);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sumNumbers</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> sum(root, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="130-把所有被包围的-O-置为-X"><a href="#130-把所有被包围的-O-置为-X" class="headerlink" title="130 把所有被包围的 O 置为 X"></a>130 把所有被包围的 O 置为 X</h2><p>使用并查集</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; m_father, m_rank;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="type">int</span> n): <span class="built_in">m_father</span>(n), <span class="built_in">m_rank</span>(n, <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_father.<span class="built_in">size</span>(); i++)</span><br><span class="line">            m_father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x != m_father[x])</span><br><span class="line">            m_father[x] = <span class="built_in">find</span>(m_father[x]);</span><br><span class="line">        <span class="keyword">return</span> m_father[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unionify</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = <span class="built_in">find</span>(x);</span><br><span class="line">        y = <span class="built_in">find</span>(y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x == y) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_rank[x] &gt; m_rank[y]) &#123;</span><br><span class="line">            m_father[y] = x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_rank[x] == m_rank[y])</span><br><span class="line">                m_rank[y]++;</span><br><span class="line">            m_father[x] = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> m = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">UnionFind <span class="title">uf</span><span class="params">(n*m+<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((i == <span class="number">0</span> || j == <span class="number">0</span> || i == n<span class="number">-1</span> || j == m<span class="number">-1</span>) &amp;&amp; board[i][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                    uf.<span class="built_in">unionify</span>(i * m + j, n * m);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (board[i<span class="number">-1</span>][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                        uf.<span class="built_in">unionify</span>(i * m + j, (i - <span class="number">1</span>) * m + j);</span><br><span class="line">                    <span class="keyword">if</span> (board[i+<span class="number">1</span>][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                        uf.<span class="built_in">unionify</span>(i*m+j, (i+<span class="number">1</span>)*m+j);</span><br><span class="line">                    <span class="keyword">if</span> (board[i][j<span class="number">-1</span>] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                        uf.<span class="built_in">unionify</span>(i*m+j, i*m+j<span class="number">-1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (board[i][j+<span class="number">1</span>] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                        uf.<span class="built_in">unionify</span>(i*m+j, i*m+j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">                <span class="keyword">if</span> (uf.<span class="built_in">find</span>(i*m+j) != uf.<span class="built_in">find</span>(n*m))</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="131-对字符串分组，是的每个字串都是回文，返回所有可能的分组"><a href="#131-对字符串分组，是的每个字串都是回文，返回所有可能的分组" class="headerlink" title="131 对字符串分组，是的每个字串都是回文，返回所有可能的分组"></a>131 对字符串分组，是的每个字串都是回文，返回所有可能的分组</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line">    vector&lt;string&gt; group;</span><br><span class="line">    <span class="built_in">dfs</span>(result, s, group, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; result, <span class="type">const</span> string&amp; s, vector&lt;string&gt;&amp; group, <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start == s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(group);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isPalindrome</span>(s, start, i)) &#123;</span><br><span class="line">            group.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(start, i - start + <span class="number">1</span>));</span><br><span class="line">            <span class="built_in">dfs</span>(result, s, group, i + <span class="number">1</span>);</span><br><span class="line">            group.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[left++] != s[right--])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="132-如上题，找出最少需要分组几次"><a href="#132-如上题，找出最少需要分组几次" class="headerlink" title="132 如上题，找出最少需要分组几次"></a>132 如上题，找出最少需要分组几次</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minCut</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cut</span><span class="params">(s.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>() + <span class="number">1</span>; i++)</span><br><span class="line">        cut[i] = i - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; i - j &gt;= <span class="number">0</span> &amp;&amp; i + j &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i+j] == s[i-j]; j++)</span><br><span class="line">            cut[i+j+<span class="number">1</span>] = <span class="built_in">min</span>(cut[i+j+<span class="number">1</span>], cut[i-j] + <span class="number">1</span>); <span class="comment">// i-j -&gt; i+j 是 palindrome，所以只需要 cut[i-j] 在加上这一段就好了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; i - j + <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; i + j &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i+j] == s[i-j+<span class="number">1</span>]; j++)</span><br><span class="line">            cut[i+j+<span class="number">1</span>] = <span class="built_in">min</span>(cut[i+j+<span class="number">1</span>], cut[i - j + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cut[s.<span class="built_in">size</span>()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="133-复制有向图"><a href="#133-复制有向图" class="headerlink" title="133 复制有向图"></a>133 复制有向图</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;UndirectedGraphNode*, UndirectedGraphNode*&gt; hash; <span class="comment">// old -&gt; new pair</span></span><br><span class="line"><span class="function">UndirectedGraphNode *<span class="title">cloneGraph</span><span class="params">(UndirectedGraphNode *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (hash.<span class="built_in">find</span>(node) == hash.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        hash[node] = <span class="keyword">new</span> <span class="built_in">UndirectedGraphNode</span>(node-&gt;label);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> n : node-&gt;neighbors)</span><br><span class="line">            hash[node]-&gt;neighbors.<span class="built_in">push_back</span>(<span class="built_in">cloneGraph</span>(n));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hash[node];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134 加油站"></a>134 加油站</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>* gas, <span class="type">int</span> gasSize, <span class="type">int</span>* cost, <span class="type">int</span> costSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, sum = <span class="number">0</span>; i &lt; gasSize; ++i) &#123;</span><br><span class="line">        sum += gas[i] - cost[i]; <span class="comment">// 从此处经过能够净增多少汽油</span></span><br><span class="line">        total += gas[i] - cost[i]; <span class="comment">// 记录总的汽油量是否是正的</span></span><br><span class="line">        <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123; <span class="comment">// 如果当前汽油量已经小于 0，说明之前的节点都是不行的，到下一个节点</span></span><br><span class="line">            j = i;</span><br><span class="line">            sum = <span class="number">0</span>; <span class="comment">// 同时重新开始计数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total &gt;= <span class="number">0</span> ? j + <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="135-糖块，成绩高的需要比他身边成绩低的获得更多的糖"><a href="#135-糖块，成绩高的需要比他身边成绩低的获得更多的糖" class="headerlink" title="135 糖块，成绩高的需要比他身边成绩低的获得更多的糖"></a>135 糖块，成绩高的需要比他身边成绩低的获得更多的糖</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">candy</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = ratings.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">candies</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (ratings[i] &gt; ratings[i<span class="number">-1</span>])</span><br><span class="line">            candies[i] = candies[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (ratings[i<span class="number">-1</span>] &gt; ratings[i])</span><br><span class="line">            candies[i<span class="number">-1</span>] = <span class="built_in">max</span>(candies[i] + <span class="number">1</span>, candies[i<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : candies)</span><br><span class="line">        result += i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="136-找出数组中只出现一次的数字"><a href="#136-找出数组中只出现一次的数字" class="headerlink" title="136 找出数组中只出现一次的数字"></a>136 找出数组中只出现一次的数字</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; numsSize; i++)</span><br><span class="line">        result ^= nums[i];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="137-一个数组中，所有数字都出现三次，除了一个数字以外，找出这个数字"><a href="#137-一个数组中，所有数字都出现三次，除了一个数字以外，找出这个数字" class="headerlink" title="137 一个数组中，所有数字都出现三次，除了一个数字以外，找出这个数字"></a>137 一个数组中，所有数字都出现三次，除了一个数字以外，找出这个数字</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用二进制计算</span></span><br><span class="line"><span class="comment">// 00-&gt;10-&gt;01-&gt;00(0-&gt;1-&gt;2-&gt;3/0)</span></span><br><span class="line"><span class="comment">// ones = ones ^ A[i]; if (twos == 1) then ones = 0</span></span><br><span class="line"><span class="comment">// twos = twos ^ A[i]; if (ones* == 1) then twos = 0</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ones = <span class="number">0</span>, twos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        ones = (ones ^ nums[i]) &amp; ~twos;</span><br><span class="line">        twos = (twos ^ nums[i]) &amp; ~ones;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ones;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="138-复制复杂结构链表"><a href="#138-复制复杂结构链表" class="headerlink" title="138 复制复杂结构链表"></a>138 复制复杂结构链表</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list with a random pointer.</span></span><br><span class="line"><span class="comment"> * struct RandomListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int label;</span></span><br><span class="line"><span class="comment"> *     struct RandomListNode *next;</span></span><br><span class="line"><span class="comment"> *     struct RandomListNode *random;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> RandomListNode *<span class="title function_">copyRandomList</span><span class="params">(<span class="keyword">struct</span> RandomListNode *head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">RandomListNode</span>* <span class="title">p</span>;</span></span><br><span class="line">    p = head;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">RandomListNode</span>* <span class="title">node</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> RandomListNode));</span><br><span class="line">        node-&gt;next = node-&gt;random = <span class="literal">NULL</span>; <span class="comment">// spicial notice to struct initialization in c</span></span><br><span class="line">        node-&gt;label = p-&gt;label;</span><br><span class="line">        node-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = node;</span><br><span class="line">        p = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p = head;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;random)</span><br><span class="line">            p-&gt;next-&gt;random = p-&gt;random-&gt;next;</span><br><span class="line">        p = p-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">RandomListNode</span> <span class="title">dummy</span>, *<span class="title">q</span> =</span> &amp;dummy;</span><br><span class="line">    dummy.next = dummy.random = <span class="literal">NULL</span>;</span><br><span class="line">    p = head;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        q-&gt;next = p-&gt;next;</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">        p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="139-查找单词是否能组成句子"><a href="#139-查找单词是否能组成句子" class="headerlink" title="139 查找单词是否能组成句子"></a>139 查找单词是否能组成句子</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, unordered_set&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (wordDict.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(s.size() + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 动态规划，假设前 i 个字符已经匹配到了，尝试匹配 i 到 i+j，如果找到了，就匹配到了 i+j</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[j]) &#123;</span><br><span class="line">                string word = s.<span class="built_in">substr</span>(j, i-j);</span><br><span class="line">                <span class="keyword">if</span> (wordDict.<span class="built_in">find</span>(word) != wordDict.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="141-列表是否有环"><a href="#141-列表是否有环" class="headerlink" title="141 列表是否有环"></a>141 列表是否有环</h2><p>slow 每次走一步，而 fast 每次走两步，因此在进入环之后，两者一定会相遇</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">hasCycle</span><span class="params">(<span class="keyword">struct</span> ListNode *head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">slow</span> =</span> head, * fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="142-列表是否有环？如果有找到环的开始"><a href="#142-列表是否有环？如果有找到环的开始" class="headerlink" title="142 列表是否有环？如果有找到环的开始"></a>142 列表是否有环？如果有找到环的开始</h2><p>从两者出发，到两者相遇，slow 指针走了 p 步，而 fast 指针走了 2p 步，显然 fast 多走了一圈（或者多圈）。<br>设 p &#x3D; k + x, 2p &#x3D; k + x + loop -&gt; 2k + 2x &#x3D; k + x + loop -&gt; k + x &#x3D; loop -&gt; k &#x3D; loop - x，剩下的长度正好也是 k。<br>假设入口处距离起点的距离是 k，那么发生碰撞的点距离环的入口处距离也是 k，所以两个指针分别从开始和碰撞点出发匀速一定会在环的入口相遇。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode *<span class="title function_">detectCycle</span><span class="params">(<span class="keyword">struct</span> ListNode *head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">slow</span> =</span> head, * fast = head, *entry = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!found &amp;&amp; fast &amp;&amp; fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast)</span><br><span class="line">            found = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!found) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    slow = head;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="144-前序遍历"><a href="#144-前序遍历" class="headerlink" title="144 前序遍历"></a>144 前序遍历</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    stack&lt;TreeNode*&gt; stk;</span><br><span class="line">    stk.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* node  = stk.<span class="built_in">top</span>();</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">            stk.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">            stk.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145 二叉树的后序遍历"></a>145 二叉树的后序遍历</h2><p>参见<a href="tree.md">树的遍历</a></p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line">    stack&lt;TreeNode*&gt; stk, output;</span><br><span class="line">    stk.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> node = stk.<span class="built_in">top</span>();</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        output.<span class="built_in">push</span>(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">            stk.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">            stk.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!output.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(output.<span class="built_in">top</span>()-&gt;val);</span><br><span class="line">        output.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146 LRU 缓存"></a>146 LRU 缓存</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> unordered_map&lt;<span class="type">int</span>, pair&lt;<span class="type">int</span>, list&lt;<span class="type">int</span>&gt;::iterator&gt;&gt; <span class="type">cache_t</span>; <span class="comment">// k: v, iter</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) : <span class="built_in">m_capacity</span>(capacity) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = m_cache.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it == m_cache.<span class="built_in">end</span>())</span><br><span class="line">             <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">touch</span>(it);</span><br><span class="line">        <span class="keyword">return</span> it-&gt;second.first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = m_cache.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it != m_cache.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="built_in">touch</span>(it);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_cache.<span class="built_in">size</span>() == m_capacity) &#123;</span><br><span class="line">                m_cache.<span class="built_in">erase</span>(m_used.<span class="built_in">back</span>());</span><br><span class="line">                m_used.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            m_used.<span class="built_in">push_front</span>(key);</span><br><span class="line">        &#125;</span><br><span class="line">        m_cache[key] = &#123;value, m_used.<span class="built_in">begin</span>()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">touch</span><span class="params">(<span class="type">cache_t</span>::iterator it)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> key = it-&gt;first;</span><br><span class="line">        m_used.<span class="built_in">erase</span>(it-&gt;second.second);</span><br><span class="line">        m_used.<span class="built_in">push_front</span>(key);</span><br><span class="line">        it-&gt;second.second = m_used.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">cache_t</span> m_cache;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; m_used;</span><br><span class="line">    <span class="type">int</span> m_capacity;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="147-链表插入排序"><a href="#147-链表插入排序" class="headerlink" title="147 链表插入排序"></a>147 链表插入排序</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">insertionSortList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>, *<span class="title">p</span> =</span> head;</span><br><span class="line">    dummy.val = INT_MIN;</span><br><span class="line">    dummy.next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">iter</span> =</span> &amp;dummy;</span><br><span class="line">        <span class="keyword">while</span> (iter-&gt;next &amp;&amp; iter-&gt;next-&gt;val &lt; p-&gt;val)</span><br><span class="line">            iter = iter-&gt;next;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">pnext</span> =</span> p-&gt;next;</span><br><span class="line">        p-&gt;next = iter-&gt;next;</span><br><span class="line">        iter-&gt;next = p;</span><br><span class="line">        p = pnext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="148-排序链表，要求达到-O-nlogn-时间复杂度"><a href="#148-排序链表，要求达到-O-nlogn-时间复杂度" class="headerlink" title="148 排序链表，要求达到 O(nlogn) 时间复杂度"></a>148 排序链表，要求达到 O(nlogn) 时间复杂度</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">split</span><span class="params">(<span class="keyword">struct</span> ListNode* source, <span class="keyword">struct</span> ListNode** frontptr, <span class="keyword">struct</span> ListNode** backptr)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">fast</span>, * <span class="title">slow</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (!source || !source-&gt;next)</span><br><span class="line">        *backptr = source;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        slow = source;</span><br><span class="line">        fast = source-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *backptr = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *frontptr = source;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">merge</span><span class="params">(<span class="keyword">struct</span> ListNode* l1, <span class="keyword">struct</span> ListNode* l2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">NULL</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="literal">NULL</span>) <span class="keyword">return</span> l1;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>;</span></span><br><span class="line">    dummy.next == <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">p</span> =</span> &amp;dummy;</span><br><span class="line">    <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            p-&gt;next = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p-&gt;next = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l1)</span><br><span class="line">        p-&gt;next = l1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l2)</span><br><span class="line">        p-&gt;next = l2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// merge sort</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">sortList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">front</span>, * <span class="title">back</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">    split(head, &amp;front, &amp;back);</span><br><span class="line">    front = sortList(front);</span><br><span class="line">    back = sortList(back);</span><br><span class="line">    head = merge(front, back);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="149-在同一条线上的点最多的线"><a href="#149-在同一条线上的点最多的线" class="headerlink" title="149 在同一条线上的点最多的线"></a>149 在同一条线上的点最多的线</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxPoints</span><span class="params">(vector&lt;Point&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (points.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> points.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于每一个点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; points.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 经过该点的直线，使用分数作为斜率，避免使用浮点数</span></span><br><span class="line">        map&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, <span class="type">int</span>&gt; lines;</span><br><span class="line">        <span class="type">int</span> localMax = <span class="number">0</span>, overlap = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; points.<span class="built_in">size</span>(); j++) &#123; <span class="comment">// 避免重复计算</span></span><br><span class="line">            <span class="keyword">if</span> (points[j].x == points[i].x &amp;&amp; points[j].y == points[i].y) &#123;</span><br><span class="line">                overlap++; <span class="comment">// 同一个点</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> x = points[j].x - points[i].x;</span><br><span class="line">                <span class="type">int</span> y = points[j].y - points[i].y;</span><br><span class="line">                <span class="type">int</span> g = <span class="built_in">gcd</span>(x, y);</span><br><span class="line">                x /= g, y /= g; <span class="comment">// verticle case: x == 0 -&gt; (0, 1)</span></span><br><span class="line">                lines[<span class="built_in">make_pair</span>(x, y)]++;</span><br><span class="line">                localMax = <span class="built_in">max</span>(localMax, lines[<span class="built_in">make_pair</span>(x, y)]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// overlap 算在任意条线上</span></span><br><span class="line">        result = <span class="built_in">max</span>(result, localMax + overlap + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (y == <span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">gcd</span>(y, x % y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="150-后缀表达式求值"><a href="#150-后缀表达式求值" class="headerlink" title="150 后缀表达式求值"></a>150 后缀表达式求值</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_operator</span><span class="params">(<span class="type">char</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t == <span class="string">&#x27;+&#x27;</span> || t == <span class="string">&#x27;-&#x27;</span> || t == <span class="string">&#x27;*&#x27;</span> || t == <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> left, <span class="type">char</span> op, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(op) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="keyword">return</span> left + right;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="keyword">return</span> left - right;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: <span class="keyword">return</span> left * right;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: <span class="keyword">return</span> left / right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; token : tokens) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">is_operator</span>(token[<span class="number">0</span>]) &amp;&amp; token.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">char</span> op = token[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> right_num = nums.<span class="built_in">top</span>();</span><br><span class="line">            nums.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> left_num = nums.<span class="built_in">top</span>();</span><br><span class="line">            nums.<span class="built_in">pop</span>();</span><br><span class="line">            nums.<span class="built_in">push</span>(<span class="built_in">calc</span>(left_num, op, right_num));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums.<span class="built_in">push</span>(<span class="built_in">stoi</span>(token));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="151-反转句子中的单词顺序"><a href="#151-反转句子中的单词顺序" class="headerlink" title="151 反转句子中的单词顺序"></a>151 反转句子中的单词顺序</h2><p>一般面试的时候会假定没有多余字符的，解法是</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">&lt;/details&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LeetCode 需要处理多余空格：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;details&gt;</span><br><span class="line">    &lt;summary&gt;C 解答&lt;/summary&gt;</span><br><span class="line"></span><br><span class="line">```C</span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">char</span> *a, <span class="type">char</span> *b)</span> &#123;</span><br><span class="line">    <span class="type">char</span> tmp = *a; *a = *b; *b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>* start, <span class="type">char</span>* end)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(start &lt; end)</span><br><span class="line">        swap(start++, end--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">trim</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* fast, *slow;</span><br><span class="line">    <span class="keyword">for</span> (fast = s; *fast !=<span class="string">&#x27;\0&#x27;</span>; fast++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(*fast)) &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">isspace</span>(*(fast + <span class="number">1</span>)) &amp;&amp; *(fast + <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">                fast++;</span><br><span class="line">            <span class="keyword">if</span>(*(fast+<span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(slow == s)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(fast, slow++);</span><br><span class="line">    &#125;</span><br><span class="line">    *slow = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reverseWords</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    trim(s);</span><br><span class="line">    len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    reverse(s, s + len - <span class="number">1</span>);</span><br><span class="line">    <span class="type">char</span>* head = s, * tail =s ;</span><br><span class="line">    <span class="keyword">while</span> (*(tail + <span class="number">1</span>) != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        tail = head;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isspace</span>(*(tail + <span class="number">1</span>)) &amp;&amp; *(tail + <span class="number">1</span>) != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            tail++;</span><br><span class="line">        reverse(head, tail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="152-最大子序列乘积"><a href="#152-最大子序列乘积" class="headerlink" title="152 最大子序列乘积"></a>152 最大子序列乘积</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; A)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = A.size();</span><br><span class="line">    <span class="type">int</span> r = A[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, imax = r, imin = r; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] &lt; <span class="number">0</span>)</span><br><span class="line">            swap(imax, imin);</span><br><span class="line"></span><br><span class="line">        imax = max(A[i], imax * A[i]);</span><br><span class="line">        imin = min(A[i], imin * A[i]);</span><br><span class="line"></span><br><span class="line">        r = max(r, imax);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="153-在旋转数组中查找最小值"><a href="#153-在旋转数组中查找最小值" class="headerlink" title="153 在旋转数组中查找最小值"></a>153 在旋转数组中查找最小值</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>* A, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>; <span class="type">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (A[left] &gt; A[mid])</span><br><span class="line">            right = mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A[right] &lt; A[mid])</span><br><span class="line">            left = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A[left] &lt; A[right] ? A[left] : A[right];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="154-在旋转数组中查找最小值，可能有重复"><a href="#154-在旋转数组中查找最小值，可能有重复" class="headerlink" title="154 在旋转数组中查找最小值，可能有重复"></a>154 在旋转数组中查找最小值，可能有重复</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>* A, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (A[mid] &gt; A[right]) &#123; <span class="comment">// 当需要找的是 left，也就是较小的数字，使用 right 比较不需要等于号</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (A[right] &lt; A[mid]) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A[left];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="155-设计一个栈，在普通栈的基础上支持-getmin-操作"><a href="#155-设计一个栈，在普通栈的基础上支持-getmin-操作" class="headerlink" title="155 设计一个栈，在普通栈的基础上支持 getmin 操作"></a>155 设计一个栈，在普通栈的基础上支持 getmin 操作</h2><p>解法 1: 使用额外的栈，每个值都记录一个当前最小值，浪费空间</p>
<p>解法 2: 也是使用额外的栈，但是惰性记录，只有当需要更新的时候才去记录</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; m_stk;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; m_min;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= <span class="built_in">getMin</span>())</span><br><span class="line">            m_min.<span class="built_in">push</span>(x);</span><br><span class="line">        m_stk.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_stk.<span class="built_in">top</span>() == <span class="built_in">getMin</span>())</span><br><span class="line">            m_min.<span class="built_in">pop</span>();</span><br><span class="line">        m_stk.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_stk.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_min.<span class="built_in">empty</span>() ? INT_MAX : m_min.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<p>156-159 Locked</p>
<h2 id="160-求两个链表的交叉点"><a href="#160-求两个链表的交叉点" class="headerlink" title="160 求两个链表的交叉点"></a>160 求两个链表的交叉点</h2><p>分析题目可知，如果有一个交叉点，那么在这之后的所有点都是交叉的。这里有一个非常巧妙<br>的做法。使用两个指针，如果到达结尾就指向另一个链表，会产生一下三种情况：</p>
<ol>
<li>如果交叉点前面的节点数目相同，显然会返回正确节点。</li>
<li>如果不同假设 A 的节点为 a + c，B 的节点为 b + c，则在下一次遍历时：<br> a + c + b &#x3D;&#x3D; b + c + a，恰好到达相同部分的第一个顶点 C1</li>
<li>如果两个列表不相交，那么经过 a + b, b + a 距离后，恰好都等于 NULL</li>
</ol>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode *<span class="title function_">getIntersectionNode</span><span class="params">(<span class="keyword">struct</span> ListNode *headA, <span class="keyword">struct</span> ListNode *headB)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!headA || !headB) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p1</span> =</span> headA, *p2=headB;</span><br><span class="line">    <span class="keyword">while</span> (p1 != p2) &#123;</span><br><span class="line">        <span class="comment">// 两个列表手尾相接，如果有一个点相同，一定会返回</span></span><br><span class="line">        <span class="comment">// a + c + b == b + c + a   --&gt; C1</span></span><br><span class="line">        <span class="comment">// a + b == b + a    --&gt; NULL</span></span><br><span class="line">        p1 = p1 ? p1-&gt;next : headB;</span><br><span class="line">        p2 = p2 ? p2-&gt;next : headA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>161 Locked</p>
<h2 id="162-找到极大值，给定一个数组，可能有多个极大值，找到任意一个即可，给定数组中-A-i-x3D-A-i-1"><a href="#162-找到极大值，给定一个数组，可能有多个极大值，找到任意一个即可，给定数组中-A-i-x3D-A-i-1" class="headerlink" title="162  找到极大值，给定一个数组，可能有多个极大值，找到任意一个即可，给定数组中 A[i] !&#x3D; A[i+1]"></a>162  找到极大值，给定一个数组，可能有多个极大值，找到任意一个即可，给定数组中 A[i] !&#x3D; A[i+1]</h2><p>题目要求在对数时间内做出来，二分搜索，如果中间的数在左半部分，就向右找。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findPeakElement</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = numsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; nums[mid + <span class="number">1</span>]) <span class="comment">// mid in left part of summit</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>                           <span class="comment">// mid in right part of summit</span></span><br><span class="line">            right= mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>163 Locked</p>
<h2 id="164-未排序数组中相差最大的两个数之间的差"><a href="#164-未排序数组中相差最大的两个数之间的差" class="headerlink" title="164 未排序数组中相差最大的两个数之间的差"></a>164 未排序数组中相差最大的两个数之间的差</h2><p>根据抽屉原理，最大差不可能小于 (max - min) &#x2F; (n - 1)。证明：如果小于，那么整个数组的大小就会小于 max - min。<br>因此我们把</p>
<h2 id="165-比较版本号大小"><a href="#165-比较版本号大小" class="headerlink" title="165 比较版本号大小"></a>165 比较版本号大小</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ver</span><span class="params">(<span class="type">const</span> string&amp; version)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : version) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            num = num * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(num);</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对于所有这种分割符中读取数字的都需要注意最后一个</span></span><br><span class="line">    result.<span class="built_in">push_back</span>(num); <span class="comment">// notice here</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compareVersion</span><span class="params">(string version1, string version2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> v1 = <span class="built_in">ver</span>(version1);</span><br><span class="line">    <span class="keyword">auto</span> v2 = <span class="built_in">ver</span>(version2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>() || i &lt; v2.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> a = i &lt; v1.<span class="built_in">size</span>() ? v1[i] : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> b = i &lt; v2.<span class="built_in">size</span>() ? v2[i] : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (a != b)</span><br><span class="line">            <span class="keyword">return</span> a &gt; b ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="166-分数生成小数"><a href="#166-分数生成小数" class="headerlink" title="166 分数生成小数"></a>166 分数生成小数</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">fractionToDecimal</span><span class="params">(<span class="type">long</span> numerator, <span class="type">long</span> denominator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numerator == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    string result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 符号</span></span><br><span class="line">    <span class="keyword">if</span> (numerator &lt; <span class="number">0</span> ^ denominator &lt; <span class="number">0</span>)</span><br><span class="line">        result += <span class="string">&quot;-&quot;</span>;</span><br><span class="line">    <span class="type">long</span> n = <span class="built_in">abs</span>(numerator), d = <span class="built_in">abs</span>(denominator);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 整数部分</span></span><br><span class="line">    result += <span class="built_in">to_string</span>(n / d);</span><br><span class="line">    <span class="keyword">if</span> (n % d == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小数部分</span></span><br><span class="line">    result+= <span class="string">&quot;.&quot;</span>;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> r = n % d; r != <span class="number">0</span>; r %= d) &#123; <span class="comment">// 模拟手工除法</span></span><br><span class="line">        <span class="keyword">if</span> (map.<span class="built_in">count</span>(r) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result.<span class="built_in">insert</span>(map[r], <span class="number">1</span>, <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            result += <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        map[r] = result.<span class="built_in">size</span>(); <span class="comment">// 记录对应的位置，以便插入括号</span></span><br><span class="line">        r *= <span class="number">10</span>; <span class="comment">// 从上借位</span></span><br><span class="line">        result += <span class="built_in">to_string</span>(r / d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>167 Locked</p>
<h2 id="168-生成-Excel-表格标题"><a href="#168-生成-Excel-表格标题" class="headerlink" title="168 生成 Excel 表格标题"></a>168 生成 Excel 表格标题</h2><p>注意 A 对应的是 1 而不是 0，而且数字也是从 1 开始的</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">convertToTitle</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    string title;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        <span class="type">char</span> c = (n<span class="number">-1</span>) % <span class="number">26</span> + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        n = (n<span class="number">-1</span>) / <span class="number">26</span>;</span><br><span class="line">        title = c + title;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> title;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="169-给定一个数组，有一个数字的出现频率超过了一半，找出这个数字"><a href="#169-给定一个数组，有一个数字的出现频率超过了一半，找出这个数字" class="headerlink" title="169 给定一个数组，有一个数字的出现频率超过了一半，找出这个数字"></a>169 给定一个数组，有一个数字的出现频率超过了一半，找出这个数字</h2><p>非常经典的一道题，首先我们假设拿到的数字就是目标，并记录他出现的次数，如果下一个<br>数字和他不一样，那么我们减一，当次数为 0 的时候，我们知道这个数字在已经遍历过的数字<br>中出现小于一半了，这时候我们换下一个数字，最后剩下的一定是超过一半的数字。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> candidate, count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span> || candidate == i) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            candidate = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>170 Locked</p>
<h2 id="171-Excel-标题转换为数字"><a href="#171-Excel-标题转换为数字" class="headerlink" title="171 Excel 标题转换为数字"></a>171 Excel 标题转换为数字</h2><p>同样，我们需要注意 A 对应的是 1，而不是 0</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">titleToNumber</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (*s)</span><br><span class="line">        result = result * <span class="number">26</span> + *s++ - <span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="172-阶乘中能有几个-0"><a href="#172-阶乘中能有几个-0" class="headerlink" title="172 阶乘中能有几个 0"></a>172 阶乘中能有几个 0</h2><p>显然先算出阶乘数字是会溢出的，而有 0 的话，就是需要 10，也就是就需要 2 和 5，<br>显然 2 是比 5 多的。那么我们只要考虑 5 的个数就行了， 这时候需要注意，5&#x2F;15 等是算一个 5，<br>而 25&#x2F;75 包含了两个 5，所以我们计算的时候，数一遍包含 5 的（这时 25 等也被计算了），<br>然后再数一遍包含 25 的就像当于数了两次了。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">trailingZeroes</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> fives = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">5</span>; n / i &gt; <span class="number">0</span>; i *= <span class="number">5</span>)</span><br><span class="line">        fives += n / i;</span><br><span class="line">    <span class="keyword">return</span> fives;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="173-二叉树中序遍历迭代器"><a href="#173-二叉树中序遍历迭代器" class="headerlink" title="173 二叉树中序遍历迭代器"></a>173 二叉树中序遍历迭代器</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    BSTIterator(TreeNode *root) &#123;</span><br><span class="line">        pushAll(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @return whether we have a next smallest number */</span></span><br><span class="line">    <span class="type">bool</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !m_stack.empty();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @return the next smallest number */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        TreeNode* temp = m_stack.top();</span><br><span class="line">        m_stack.pop();</span><br><span class="line">        pushAll(temp-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> temp-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; m_stack;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">pushAll</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (root) &#123;</span><br><span class="line">            m_stack.push(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your BSTIterator will be called like this:</span></span><br><span class="line"><span class="comment"> * BSTIterator i = BSTIterator(root);</span></span><br><span class="line"><span class="comment"> * while (i.hasNext()) cout &lt;&lt; i.next();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</details>


<h2 id="174-地下城游戏"><a href="#174-地下城游戏" class="headerlink" title="174 地下城游戏"></a>174 地下城游戏</h2><p>王子在格子的左上角，需要到右下角去救公主，在过程中王子不能死掉，和机器人走路一样，使用动态规划</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">calculateMinimumHP</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; dungeon)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> row = dungeon.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> col = dungeon[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">bloods</span>(row + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (col + <span class="number">1</span>, INT_MAX));</span><br><span class="line">    bloods[row][col<span class="number">-1</span>] = bloods[row<span class="number">-1</span>][col] = <span class="number">1</span>; <span class="comment">// 公主的两边</span></span><br><span class="line">    <span class="comment">// 从公主那里逆向推</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = row<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = col<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">             <span class="type">int</span> need = <span class="built_in">min</span>(bloods[i+<span class="number">1</span>][j], bloods[i][j+<span class="number">1</span>]) - dungeon[i][j]; <span class="comment">// 缺乏的血量 = 到达下一步最少的血量 - 这一步消耗的血量</span></span><br><span class="line">             bloods[i][j] = need &gt; <span class="number">0</span> ? need : <span class="number">1</span>; <span class="comment">// 王子的血量至少为 1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bloods[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="175-178-Missing"><a href="#175-178-Missing" class="headerlink" title="175-178 Missing"></a>175-178 Missing</h2><h2 id="179-最大的数字"><a href="#179-最大的数字" class="headerlink" title="179 最大的数字"></a>179 最大的数字</h2><p>神奇的排序方法</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">largestNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">num_strings</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        num_strings[i] = <span class="built_in">to_string</span>(nums[i]);</span><br><span class="line">    <span class="keyword">auto</span> comparator = [] (string&amp; s1, string&amp; s2) &#123;</span><br><span class="line">        <span class="keyword">return</span> s1 + s2 &gt; s2 + s1;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">sort</span>(num_strings.<span class="built_in">begin</span>(), num_strings.<span class="built_in">end</span>(), comparator);</span><br><span class="line">    string result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; num_string: num_strings)</span><br><span class="line">        result += num_string;</span><br><span class="line">    <span class="type">int</span> start = result.<span class="built_in">find_first_not_of</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (start == string::npos) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> result.<span class="built_in">substr</span>(start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="180-185-Missing"><a href="#180-185-Missing" class="headerlink" title="180-185 Missing"></a>180-185 Missing</h2><p>186 Locked</p>
<h2 id="187-找到所有-10-个字母唱的重复-DNA-序列"><a href="#187-找到所有-10-个字母唱的重复-DNA-序列" class="headerlink" title="187 找到所有 10 个字母唱的重复 DNA 序列"></a>187 找到所有 10 个字母唱的重复 DNA 序列</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// naive 的做法从前往后，记录字符串</span></span><br><span class="line"><span class="comment">// 观察 ATCG 四个字符的特征，并把他们编码为一个 int</span></span><br><span class="line"><span class="comment">// 十个字符正好编码在 32bit 的 int 中</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">findRepeatedDnaSequences</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">0</span>, i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="comment">// 左移弹出老元素，求交为了只使用 30bit，求或添加新元素。</span></span><br><span class="line">        <span class="keyword">if</span> (hash[t = t &lt;&lt; <span class="number">3</span> &amp; <span class="number">0x3FFFFFFF</span> | s[i] &amp; <span class="number">0b111</span>]++ == <span class="number">1</span>) <span class="comment">// 等于 1 为了避免重复</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(i - <span class="number">9</span>, <span class="number">10</span>));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="189-翻转树组"><a href="#189-翻转树组" class="headerlink" title="189 翻转树组"></a>189 翻转树组</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> temp = nums[left];</span><br><span class="line">        nums[left] = nums[right];</span><br><span class="line">        nums[right] = temp;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= numsSize) k %= numsSize;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    reverse(nums, <span class="number">0</span>, numsSize - k - <span class="number">1</span>);</span><br><span class="line">    reverse(nums, numsSize - k, numsSize - <span class="number">1</span>);</span><br><span class="line">    reverse(nums, <span class="number">0</span>, numsSize - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="190-翻转二进制表示"><a href="#190-翻转二进制表示" class="headerlink" title="190 翻转二进制表示"></a>190 翻转二进制表示</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">reverseBits</span><span class="params">(<span class="type">uint32_t</span> n)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(n) * <span class="number">8</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (len--) &#123; <span class="comment">// 31 times shift</span></span><br><span class="line">        r |= n &amp; <span class="number">0x1</span>;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        r &lt;&lt;= <span class="number">1</span>; <span class="comment">// only shift 31 times</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r |= n &amp; <span class="number">0x1</span>;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="191-数字二进制表示中-1-的个数"><a href="#191-数字二进制表示中-1-的个数" class="headerlink" title="191 数字二进制表示中 1 的个数"></a>191 数字二进制表示中 1 的个数</h2><p>我们知道 n&amp;(n-1) 会把 n 中的最后一个 1 去掉，所以循环直到 n 为 0 即可</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        n &amp;= n - <span class="number">1</span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>还可以采用查表法，对于表我们可以预先构造，或者利用上一个方法生成，对于长度过大的，我们可以分块查表。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> counts[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _get_count(n) &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        n &amp;= n<span class="number">-1</span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">init_counts</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">        counts[i] = _get_count(i);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_count</span><span class="params">(n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        <span class="type">int</span> index = n &amp; <span class="number">0xF</span>;</span><br><span class="line">        count += counts[index];</span><br><span class="line">        n &gt;&gt;= <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    init_counts();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: %d\n&quot;</span>, _get_count(i), get_count(i));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>192-197 Missing</p>
<h2 id="198-有一排房子，每个房子中都有一定财产，但是不能偷相邻的两个房子，求能偷到的最大值"><a href="#198-有一排房子，每个房子中都有一定财产，但是不能偷相邻的两个房子，求能偷到的最大值" class="headerlink" title="198  有一排房子，每个房子中都有一定财产，但是不能偷相邻的两个房子，求能偷到的最大值"></a>198  有一排房子，每个房子中都有一定财产，但是不能偷相邻的两个房子，求能偷到的最大值</h2><p>使用 DP，对于每个房子，可以选择不偷或者前 i-1 个房子加上偷当前房子，即<code>dp[i+1] = max(dp[i], dp[i-1] + A[i])</code></p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!nums) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 因为不能相邻，所以可以从相隔一个的取值</span></span><br><span class="line">    <span class="comment">// dp[n] = max(dp[n-1], dp[n-2] + A[n])</span></span><br><span class="line">    <span class="type">int</span> temp, m = <span class="number">0</span>, n = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        temp = n;</span><br><span class="line">        <span class="keyword">if</span> (m + nums[i] &gt; n)</span><br><span class="line">            n = m + nums[i];</span><br><span class="line">        m = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="199-从右边看二叉树的效果"><a href="#199-从右边看二叉树的效果" class="headerlink" title="199 从右边看二叉树的效果"></a>199 从右边看二叉树的效果</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// level order 遍历</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* node;</span><br><span class="line">        <span class="type">int</span> len = q.<span class="built_in">size</span>(); <span class="comment">// 保存为了获得最后一个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123; <span class="comment">// 当前数组的最后一个元素就是最右边的元素</span></span><br><span class="line">            node = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">                q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">                q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="200-找出小岛的数量"><a href="#200-找出小岛的数量" class="headerlink" title="200 找出小岛的数量"></a>200 找出小岛的数量</h2><p>采用并查集，找到最后集合的数量</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; m_father, m_rank;</span><br><span class="line">    <span class="type">int</span> m_count; <span class="comment">// sets count</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="type">int</span> n): <span class="built_in">m_father</span>(n), <span class="built_in">m_rank</span>(n, <span class="number">0</span>), <span class="built_in">m_count</span>(n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_father.<span class="built_in">size</span>(); i++)</span><br><span class="line">            m_father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x != m_father[x])</span><br><span class="line">            m_father[x] = <span class="built_in">find</span>(m_father[x]);</span><br><span class="line">        <span class="keyword">return</span> m_father[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unionify</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = <span class="built_in">find</span>(x);</span><br><span class="line">        y = <span class="built_in">find</span>(y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x == y) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_rank[x] &gt; m_rank[y]) &#123;</span><br><span class="line">            m_father[y] = x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_rank[x] == m_rank[y])</span><br><span class="line">                m_rank[y]++;</span><br><span class="line">            m_father[x] = y;</span><br><span class="line">        &#125;</span><br><span class="line">        m_count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="type">const</span> <span class="type">static</span> <span class="type">char</span> LAND = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">static</span> <span class="type">char</span> WATER = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid.<span class="built_in">empty</span>() || grid[<span class="number">0</span>].<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = grid.<span class="built_in">size</span>(), c = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">UnionFind <span class="title">uf</span><span class="params">(r * c + <span class="number">1</span>)</span></span>; <span class="comment">// extra element is for water</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; r; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; c; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == LAND) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i != r - <span class="number">1</span> &amp;&amp; grid[i+<span class="number">1</span>][j] == LAND)</span><br><span class="line">                         uf.<span class="built_in">unionify</span>(i*c+j, (i+<span class="number">1</span>)*c+j);</span><br><span class="line">                    <span class="keyword">if</span> (j != c - <span class="number">1</span> &amp;&amp; grid[i][j+<span class="number">1</span>] == LAND)</span><br><span class="line">                         uf .<span class="built_in">unionify</span>(i*c+j, i*c+j+<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    uf.<span class="built_in">unionify</span>(i*c+j, c*r);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uf.<span class="built_in">getCount</span>() - <span class="number">1</span>; <span class="comment">// islands + water - 1;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, count</span>):</span><br><span class="line">        self.count = count</span><br><span class="line">        self.parents = <span class="built_in">list</span>(<span class="built_in">range</span>(count))  <span class="comment"># 初始化时 parent 指针指向自己</span></span><br><span class="line">        self.ranks = [<span class="number">1</span>] * count  <span class="comment"># 记录每棵树的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">self, p, q</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;把 p, q 两个节点连通起来&quot;&quot;&quot;</span></span><br><span class="line">        p_root = self.find(p)</span><br><span class="line">        q_root = self.find(q)</span><br><span class="line">        <span class="keyword">if</span> p_root == q_root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> self.ranks[p_root] &gt; self.ranks[q_root]:</span><br><span class="line">            self.parents[q_root] = p_root</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> self.ranks[p_root] == self.ranks[q_root]:</span><br><span class="line">                self.ranks[q_root] += <span class="number">1</span></span><br><span class="line">            self.parents[p_root] = q_root</span><br><span class="line">        self.count -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;找到 p 节点的根节点&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> self.parents[p] != p:</span><br><span class="line">            <span class="comment"># 神奇的路径压缩</span></span><br><span class="line">            self.parents[p] = self.parents[self.parents[p]]</span><br><span class="line">            p = self.parents[p]</span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_connected</span>(<span class="params">self, p, q</span>):</span><br><span class="line">        p_root = self.find(p)</span><br><span class="line">        q_root = self.find(q)</span><br><span class="line">        <span class="keyword">return</span> p_root == q_root</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numIslands</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid <span class="keyword">or</span> <span class="keyword">not</span> grid[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        m = <span class="built_in">len</span>(grid)</span><br><span class="line">        n = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        uf = UnionFind(m * n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                    up = <span class="built_in">max</span>(i - <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">if</span> grid[up][j] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                        uf.union(i * n + j, up * n + j)</span><br><span class="line">                    left = <span class="built_in">max</span>(j - <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">if</span> grid[i][j - <span class="number">1</span>] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                        uf.union(i * n + j, i * n + left)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    uf.union(i * n + j, m * n)</span><br><span class="line">        <span class="keyword">return</span> uf.count - <span class="number">1</span></span><br></pre></td></tr></table></figure>
</details>


<h2 id="201-给定区间内，所有数字-AND-的结果"><a href="#201-给定区间内，所有数字-AND-的结果" class="headerlink" title="201 给定区间内，所有数字 AND 的结果"></a>201 给定区间内，所有数字 AND 的结果</h2><p>显然直接过一遍是会超时的，那么分析可知</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果两个数不相等，一定是有不同的位，那么这一位一定为 0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rangeBitwiseAnd</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (m != n) &#123;</span><br><span class="line">        t++;</span><br><span class="line">        m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m &lt;&lt; t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="202-快乐数字，各位数字平方相加得到下一个数字，如果最后等于-1"><a href="#202-快乐数字，各位数字平方相加得到下一个数字，如果最后等于-1" class="headerlink" title="202 快乐数字，各位数字平方相加得到下一个数字，如果最后等于 1"></a>202 快乐数字，各位数字平方相加得到下一个数字，如果最后等于 1</h2><p>没啥，一直算就可以了。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="type">int</span> next = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            next += (n%<span class="number">10</span>) * (n%<span class="number">10</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="203-删除链表中给定的值"><a href="#203-删除链表中给定的值" class="headerlink" title="203 删除链表中给定的值"></a>203 删除链表中给定的值</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">removeElements</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>, *<span class="title">p</span> =</span> &amp;dummy;</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next &amp;&amp; p-&gt;next-&gt;val == val) &#123; <span class="comment">// not forward here</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span> =</span> p-&gt;next;</span><br><span class="line">            p-&gt;next = next-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="204-找出素数"><a href="#204-找出素数" class="headerlink" title="204 找出素数"></a>204 找出素数</h2><p>什么筛子，忘了</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">countPrimes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">primes</span><span class="params">(n, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    primes[<span class="number">0</span>] = primes[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt; n; i++) <span class="comment">// 注意，只到 sqrt(n)</span></span><br><span class="line">        <span class="keyword">if</span> (primes[i])</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i * i; j &lt; n; j += i) <span class="comment">// 从 i * i 开始，因为 i* i-- 已经被杀过了</span></span><br><span class="line">                primes[j] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (primes[i])</span><br><span class="line">            count++;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="205-同构字符串，可以看作-word-pattern-的简化"><a href="#205-同构字符串，可以看作-word-pattern-的简化" class="headerlink" title="205 同构字符串，可以看作 word pattern 的简化"></a>205 同构字符串，可以看作 word pattern 的简化</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isIsomorphic</span><span class="params">(<span class="type">char</span>* s, <span class="type">char</span>* t)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ss[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">int</span> ts[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(s) != <span class="built_in">strlen</span>(t))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (s[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ss[s[i]] != ts[t[i]])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ss[s[i]] = ts[t[i]] = i + <span class="number">1</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206 反转链表"></a>206 反转链表</h2><p>tags: #pointers</p>
<p>最最基础的指针操作题目了</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        prev = <span class="literal">None</span></span><br><span class="line">        curr = head</span><br><span class="line">        <span class="keyword">while</span> curr:</span><br><span class="line">            <span class="built_in">next</span> = curr.<span class="built_in">next</span></span><br><span class="line">            curr.<span class="built_in">next</span> = prev</span><br><span class="line">            prev = curr</span><br><span class="line">            curr = <span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> prev  <span class="comment"># 关键在这里</span></span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span> =</span> <span class="literal">NULL</span>, *cur = head, *next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        next = cur-&gt;next; <span class="comment">// cache</span></span><br><span class="line">        cur-&gt;next = p; <span class="comment">// reverse pointing</span></span><br><span class="line">        p = cur; <span class="comment">// moves forwards</span></span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// recursive</span></span><br></pre></td></tr></table></figure>
</details>


<h2 id="207-标准的拓扑排序"><a href="#207-标准的拓扑排序" class="headerlink" title="207 标准的拓扑排序"></a>207 标准的拓扑排序</h2><p>给定边这种方法表示图也是醉了</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123; <span class="comment">// next -&gt; before</span></span><br><span class="line">    vector&lt;unordered_set&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(numCourses); <span class="comment">// 每条边和他的下一步，临接表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : prerequisites)</span><br><span class="line">        graph[p.second].<span class="built_in">insert</span>(p.first);</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">d</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>; <span class="comment">// in degree</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; nexts : graph)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> next : nexts)</span><br><span class="line">            d[next]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        <span class="type">int</span> nondep; <span class="comment">// in degree == 0</span></span><br><span class="line">        <span class="keyword">for</span> (nondep = <span class="number">0</span>; nondep &lt; numCourses &amp;&amp; d[nondep] != <span class="number">0</span>; nondep++)</span><br><span class="line">            ;</span><br><span class="line">        <span class="keyword">if</span> (nondep == numCourses)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        d[nondep] = <span class="number">-1</span>; <span class="comment">// remove</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> next : graph[nondep]) <span class="comment">// 所有下一步都 －1</span></span><br><span class="line">            d[next]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<h2 id="208-实现前缀树"><a href="#208-实现前缀树" class="headerlink" title="208 实现前缀树"></a>208 实现前缀树</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> branchCount = <span class="number">26</span>;</span><br><span class="line">    <span class="type">bool</span> isWord;</span><br><span class="line">    TrieNode* next[branchCount];</span><br><span class="line">    <span class="comment">// Initialize your data structure here.</span></span><br><span class="line">    <span class="built_in">TrieNode</span>() : <span class="built_in">isWord</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; branchCount; i++)</span><br><span class="line">            next[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inserts a word into the trie.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        TrieNode* location = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : word) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!location-&gt;next[c - <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">                location-&gt;next[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> TrieNode;</span><br><span class="line">            location = location-&gt;next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        location-&gt;isWord = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if the word is in the trie.</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        TrieNode* location = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : word) &#123;</span><br><span class="line">            location = location-&gt;next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (!location)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> location-&gt;isWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if there is any word in the trie</span></span><br><span class="line">    <span class="comment">// that starts with the given prefix.</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode* location = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : prefix) &#123;</span><br><span class="line">            location = location-&gt;next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (!location)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode* root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Trie trie;</span></span><br><span class="line"><span class="comment">// trie.insert(&quot;somestring&quot;);</span></span><br><span class="line"><span class="comment">// trie.search(&quot;key&quot;);</span></span><br></pre></td></tr></table></figure>
</details>


<h2 id="209-最短子数组使得和大于某个数"><a href="#209-最短子数组使得和大于某个数" class="headerlink" title="209 最短子数组使得和大于某个数"></a>209 最短子数组使得和大于某个数</h2><p>双指针，超过和之后再尝试从开始处减去元素</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> s, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>, sum = <span class="number">0</span>, len = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="keyword">while</span> (sum &gt;= s) &#123;</span><br><span class="line">            len = <span class="built_in">min</span>(len, i - start + <span class="number">1</span>);</span><br><span class="line">            sum -= nums[start++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len == INT_MAX? <span class="number">0</span> : len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="210-Course-Schedule-II"><a href="#210-Course-Schedule-II" class="headerlink" title="210 Course Schedule II"></a>210 Course Schedule II</h2><p>BFS</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        vector&lt;unordered_set&lt;<span class="type">int</span>&gt;&gt; graph = <span class="built_in">make_graph</span>(numCourses, prerequisites);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; degrees = <span class="built_in">compute_indegree</span>(graph);</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; zeros;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)</span><br><span class="line">            <span class="keyword">if</span> (!degrees[i]) zeros.<span class="built_in">push</span>(i);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; toposort;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (zeros.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">            <span class="type">int</span> zero = zeros.<span class="built_in">front</span>();</span><br><span class="line">            zeros.<span class="built_in">pop</span>();</span><br><span class="line">            toposort.<span class="built_in">push_back</span>(zero);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> neigh : graph[zero]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!--degrees[neigh])</span><br><span class="line">                    zeros.<span class="built_in">push</span>(neigh);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> toposort;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;unordered_set&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">make_graph</span>(<span class="type">int</span> numCourses, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&amp; prerequisites) &#123;</span><br><span class="line">        vector&lt;unordered_set&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(numCourses);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> pre : prerequisites)</span><br><span class="line">            graph[pre.second].<span class="built_in">insert</span>(pre.first);</span><br><span class="line">        <span class="keyword">return</span> graph;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">compute_indegree</span><span class="params">(vector&lt;unordered_set&lt;<span class="type">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">degrees</span><span class="params">(graph.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> neighbors : graph)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> neigh : neighbors)</span><br><span class="line">                degrees[neigh]++;</span><br><span class="line">        <span class="keyword">return</span> degrees;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="211-添加和搜索字符串"><a href="#211-添加和搜索字符串" class="headerlink" title="211 添加和搜索字符串"></a>211 添加和搜索字符串</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> branchCount = <span class="number">26</span>;</span><br><span class="line">    <span class="type">bool</span> isWord;</span><br><span class="line">    TrieNode* next[branchCount];</span><br><span class="line">    <span class="comment">// Initialize your data structure here.</span></span><br><span class="line">    <span class="built_in">TrieNode</span>() : <span class="built_in">isWord</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; branchCount; i++)</span><br><span class="line">            next[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inserts a word into the trie.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        TrieNode* location = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : word) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!location-&gt;next[c - <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">                location-&gt;next[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> TrieNode;</span><br><span class="line">            location = location-&gt;next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        location-&gt;isWord = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if the word is in the trie.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        TrieNode* location = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : word) &#123;</span><br><span class="line">            location = location-&gt;next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (!location)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> location-&gt;isWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if there is any word in the trie</span></span><br><span class="line">    <span class="comment">// that starts with the given prefix.</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode* location = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : prefix) &#123;</span><br><span class="line">            location = location-&gt;next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (!location)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TrieNode* <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode* root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WordDictionary</span> : <span class="keyword">public</span> Trie&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WordDictionary</span>() : <span class="built_in">Trie</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Adds a word into the data structure.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addWord</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">insert</span>(word);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if the word is in the data structure. A word could</span></span><br><span class="line">    <span class="comment">// contain the dot character &#x27;.&#x27; to represent any one letter.</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search</span>(word.<span class="built_in">c_str</span>(), <span class="built_in">getRoot</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* word, TrieNode* root)</span> </span>&#123;</span><br><span class="line">        TrieNode* run = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; word[i]; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (run &amp;&amp; word[i] != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                run = run-&gt;next[word[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (run &amp;&amp; word[i] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// skip checking this char</span></span><br><span class="line">                TrieNode* tmp = run;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line">                    run = tmp-&gt;next[j];</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">search</span>(word + i + <span class="number">1</span>, run))</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> run &amp;&amp; run-&gt;isWord;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your WordDictionary object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// WordDictionary wordDictionary;</span></span><br><span class="line"><span class="comment">// wordDictionary.addWord(&quot;word&quot;);</span></span><br><span class="line"><span class="comment">// wordDictionary.search(&quot;pattern&quot;);</span></span><br></pre></td></tr></table></figure>
</details>


<h2 id="212-单词搜索"><a href="#212-单词搜索" class="headerlink" title="212 单词搜索"></a>212 单词搜索</h2><p>Trie 结构见前面，注意要记录 visited，还有边界的问题，另外集合的使用</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Trie m_trie;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findWords</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; word : words)</span><br><span class="line">            m_trie.<span class="built_in">insert</span>(word);</span><br><span class="line">        <span class="type">int</span> row = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> col = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        unordered_set&lt;string&gt; result_set;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(row, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(col, <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">                <span class="built_in">find</span>(result_set, board, visited, <span class="string">&quot;&quot;</span>, i, j);</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; r : result_set)</span><br><span class="line">            result.<span class="built_in">push_back</span>(r);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(unordered_set&lt;string&gt;&amp; r, vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, string word, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.<span class="built_in">size</span>() || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].<span class="built_in">size</span>() || visited[i][j])</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        word += board[i][j];</span><br><span class="line">        <span class="keyword">if</span> (!m_trie.<span class="built_in">startsWith</span>(word))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (m_trie.<span class="built_in">search</span>(word))</span><br><span class="line">            r.<span class="built_in">insert</span>(word);</span><br><span class="line"></span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">find</span>(r, board, visited, word, i<span class="number">-1</span>, j);</span><br><span class="line">        <span class="built_in">find</span>(r, board, visited, word, i+<span class="number">1</span>, j);</span><br><span class="line">        <span class="built_in">find</span>(r, board, visited, word, i, j<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">find</span>(r, board, visited, word, i, j+<span class="number">1</span>);</span><br><span class="line">        visited[i][j] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="213-小偷偷环状数组"><a href="#213-小偷偷环状数组" class="headerlink" title="213 小偷偷环状数组"></a>213 小偷偷环状数组</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">robNonCyclic</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!nums) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 因为不能相邻，所以可以从相隔一个的取值</span></span><br><span class="line">    <span class="comment">// dp[n] = max(dp[n-1], dp[n-2] + A[n])</span></span><br><span class="line">    <span class="type">int</span> temp, m = <span class="number">0</span>, n = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        temp = n;</span><br><span class="line">        <span class="keyword">if</span> (m + nums[i] &gt; n)</span><br><span class="line">            n = m + nums[i];</span><br><span class="line">        m = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> max(robNonCyclic(nums, numsSize - <span class="number">1</span>), robNonCyclic(nums + <span class="number">1</span>, numsSize - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<h2 id="214-最短回文字符串，给指定的字符串添加字母获得回文"><a href="#214-最短回文字符串，给指定的字符串添加字母获得回文" class="headerlink" title="214 最短回文字符串，给指定的字符串添加字母获得回文"></a>214 最短回文字符串，给指定的字符串添加字母获得回文</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// based on kmp next array</span></span><br><span class="line"><span class="function">string <span class="title">shortestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    string rev_s = s;</span><br><span class="line">    <span class="built_in">reverse</span>(rev_s.<span class="built_in">begin</span>(), rev_s.<span class="built_in">end</span>());</span><br><span class="line">    string l = s + <span class="string">&quot;#&quot;</span> + rev_s;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(l.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; l.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> j = p[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; l[i] != l[j])</span><br><span class="line">            j = p[j - <span class="number">1</span>];</span><br><span class="line">        p[i] = (j += l[i] == l[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rev_s.<span class="built_in">substr</span>(<span class="number">0</span>, s.<span class="built_in">size</span>() - p[l.<span class="built_in">size</span>() - <span class="number">1</span>]) + s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="215-数组中第-k-大的数字"><a href="#215-数组中第-k-大的数字" class="headerlink" title="215 数组中第 k 大的数字"></a>215 数组中第 k 大的数字</h2><p>实际上这道题更可能的题目是找到前 k 大的所有数字。<br>首先，设计到数组排序的问题一定向面试官要问清楚数据量的大小，这影响到接下来的实现，<br>同时和面试官探讨数据量大小对实现的影响，有助于更好的把握局面。</p>
<p>我们先假设数据量是比较小的，也就是能够放到内存中。</p>
<ol start="0">
<li>使用排序就实在是 naive 了，不过面试官非要问的话，当然是使用选择排序更好了。</li>
<li>使用快排中的 partition 算法，时间复杂度 O(n*logk)。</li>
<li>使用 size 为 k 的堆，时间复杂度也是 O(n*logk)，不管数字多大，都只需要遍历一遍。</li>
<li>使用类似插入排序的方法，保持数组大小不变，这样的时间复杂度是 O(n*k)。</li>
<li>数据的范围有限时候，使用计数排序。</li>
</ol>
<p>当数据过大的时候，我们可以想通过哈希取模之后把文件分组，找出每个文件中最大的 k 个数字</p>
<p>如果数字中有重复呢？使用计数排序，计数强制按一算<br>如果既有重复又是浮点数呢？</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> t = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="type">int</span> small = start - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> pivot = nums[end];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; end; i++)</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; pivot)</span><br><span class="line">            swap(&amp;nums[++small], &amp;nums[i]);</span><br><span class="line">    swap(&amp;nums[++small], &amp;nums[end]);</span><br><span class="line">    <span class="keyword">return</span> small;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = numsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> index = partition(nums, left, right);</span><br><span class="line">        <span class="keyword">if</span> (index == numsSize - k)</span><br><span class="line">            <span class="keyword">return</span> nums[index];</span><br><span class="line">        <span class="keyword">if</span> (index &gt; numsSize - k)</span><br><span class="line">            right = index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = index + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="216-找到-k-个数字-1…9-，使得他们的和是-n"><a href="#216-找到-k-个数字-1…9-，使得他们的和是-n" class="headerlink" title="216 找到 k 个数字 [1…9]，使得他们的和是 n"></a>216 找到 k 个数字 [1…9]，使得他们的和是 n</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">dfs</span>(result, &#123;&#125;, n, k);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result, vector&lt;<span class="type">int</span>&gt; combination, <span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (combination.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            result.<span class="built_in">push_back</span>(combination);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i = combination.<span class="built_in">empty</span>() ? <span class="number">1</span> : combination.<span class="built_in">back</span>() + <span class="number">1</span>; <span class="comment">// 保证不重复切实递增序列</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n &amp;&amp; i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        combination.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="built_in">dfs</span>(result, combination, n-i, k);</span><br><span class="line">        combination.<span class="built_in">pop_back</span>();</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="217-包含重复数字"><a href="#217-包含重复数字" class="headerlink" title="217 包含重复数字"></a>217 包含重复数字</h2><p>这道题太简单了，也没有什么精妙的解法，可以使用排序，Hash 等多种解法</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">containsDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; n : nums)</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">find</span>(n) != s.<span class="built_in">end</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            s.<span class="built_in">insert</span>(n);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="218-获得矩形重合部分的拐点"><a href="#218-获得矩形重合部分的拐点" class="headerlink" title="218 获得矩形重合部分的拐点"></a>218 获得矩形重合部分的拐点</h2><p>抄过来的，还没仔细研究</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">getSkyline</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; buildings) &#123;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="type">int</span> cur=<span class="number">0</span>, cur_X, cur_H =<span class="number">-1</span>,  len = buildings.<span class="built_in">size</span>();</span><br><span class="line">    priority_queue&lt; pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; liveBlg; <span class="comment">// first: height, second, end time</span></span><br><span class="line">    <span class="keyword">while</span>(cur&lt;len || !liveBlg.<span class="built_in">empty</span>()) &#123; <span class="comment">// if either some new building is not processed or live building queue is not empty</span></span><br><span class="line">        cur_X = liveBlg.<span class="built_in">empty</span>()? buildings[cur][<span class="number">0</span>]:liveBlg.<span class="built_in">top</span>().second; <span class="comment">// next timing point to process</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cur&gt;=len || buildings[cur][<span class="number">0</span>] &gt; cur_X) &#123; <span class="comment">//first check if the current tallest building will end before the next timing point</span></span><br><span class="line">              <span class="comment">// pop up the processed buildings, i.e. those  have height no larger than cur_H and end before the top one</span></span><br><span class="line">            <span class="keyword">while</span>(!liveBlg.<span class="built_in">empty</span>() &amp;&amp; ( liveBlg.<span class="built_in">top</span>().second &lt;= cur_X) ) liveBlg.<span class="built_in">pop</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// if the next new building starts before the top one ends, process the new building in the vector</span></span><br><span class="line">            cur_X = buildings[cur][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">while</span>(cur&lt;len &amp;&amp; buildings[cur][<span class="number">0</span>]== cur_X)  <span class="comment">// go through all the new buildings that starts at the same point</span></span><br><span class="line">            &#123;  <span class="comment">// just push them in the queue</span></span><br><span class="line">                liveBlg.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(buildings[cur][<span class="number">2</span>], buildings[cur][<span class="number">1</span>]));</span><br><span class="line">                cur++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur_H = liveBlg.<span class="built_in">empty</span>()?<span class="number">0</span>:liveBlg.<span class="built_in">top</span>().first; <span class="comment">// outut the top one</span></span><br><span class="line">        <span class="keyword">if</span>(res.<span class="built_in">empty</span>() || (res.<span class="built_in">back</span>().second != cur_H) ) res.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(cur_X, cur_H));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="219-包含重复数字，并且两个的坐标不超过-k"><a href="#219-包含重复数字，并且两个的坐标不超过-k" class="headerlink" title="219 包含重复数字，并且两个的坐标不超过 k"></a>219 包含重复数字，并且两个的坐标不超过 k</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滑动窗口保存前 k 个值，如果有重复的就返回</span></span><br><span class="line"><span class="comment">// num[i-k] num[i-1]，如果滑过了，就删除该元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= nums.<span class="built_in">size</span>()) <span class="comment">// notice here</span></span><br><span class="line">        k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; k)</span><br><span class="line">            s.<span class="built_in">erase</span>(nums[i - k - <span class="number">1</span>]); <span class="comment">// delete first note</span></span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">find</span>(nums[i]) != s.<span class="built_in">end</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        s.<span class="built_in">insert</span>(nums[i]); <span class="comment">// insert</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="220-同上一题，同时保证两个数字之间小于-t"><a href="#220-同上一题，同时保证两个数字之间小于-t" class="headerlink" title="220 同上一题，同时保证两个数字之间小于 t"></a>220 同上一题，同时保证两个数字之间小于 t</h2><p>保证两个数字之差小于 t</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; window; <span class="comment">// 注意不能使用 unordered</span></span><br><span class="line">    <span class="keyword">if</span> (k &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= nums.<span class="built_in">size</span>()) <span class="comment">// notice here</span></span><br><span class="line">        k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; k)</span><br><span class="line">            window.<span class="built_in">erase</span>(nums[i - k - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">auto</span> pos = window.<span class="built_in">lower_bound</span>(nums[i] - t); <span class="comment">// notice set.lower_bound</span></span><br><span class="line">        <span class="keyword">if</span> (pos != window.<span class="built_in">end</span>() &amp;&amp; *pos - nums[i] &lt;= t)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        window.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="221-找到最大的正方形"><a href="#221-找到最大的正方形" class="headerlink" title="221 找到最大的正方形"></a>221 找到最大的正方形</h2><p>使用动态规划 <a target="_blank" rel="noopener" href="https://leetcode.com/discuss/38489/easy-solution-with-detailed-explanations-8ms-time-and-space">https://leetcode.com/discuss/38489/easy-solution-with-detailed-explanations-8ms-time-and-space</a></p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maximalSquare</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(m + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> maxsize = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123; <span class="comment">// 每一列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123; <span class="comment">// notice i range</span></span><br><span class="line">            <span class="type">int</span> temp = dp[i];</span><br><span class="line">            <span class="keyword">if</span> (matrix[i - <span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i], <span class="built_in">min</span>(dp[i - <span class="number">1</span>], pre)) + <span class="number">1</span>;</span><br><span class="line">                maxsize = <span class="built_in">max</span>(maxsize, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> dp[i] = <span class="number">0</span>;</span><br><span class="line">            pre = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxsize * maxsize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<h2 id="222-给定一个完全树，计算节点的数量。"><a href="#222-给定一个完全树，计算节点的数量。" class="headerlink" title="222 给定一个完全树，计算节点的数量。"></a>222 给定一个完全树，计算节点的数量。</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">             <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left_height = <span class="number">0</span>, right_height = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span>* left = root, *right = root;</span><br><span class="line">    <span class="keyword">while</span> (left) &#123;</span><br><span class="line">        left = left-&gt;left;</span><br><span class="line">        left_height++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (right) &#123;</span><br><span class="line">        right = right-&gt;right;</span><br><span class="line">        right_height++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left_height == right_height) <span class="comment">// 满树 2^h - 1</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; left_height) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">countNodes</span>(root-&gt;left) + <span class="built_in">countNodes</span>(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="223-找出两个长方形覆盖的面积"><a href="#223-找出两个长方形覆盖的面积" class="headerlink" title="223 找出两个长方形覆盖的面积"></a>223 找出两个长方形覆盖的面积</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">computeArea</span><span class="params">(<span class="type">int</span> left1, <span class="type">int</span> down1, <span class="type">int</span> right1, <span class="type">int</span> up1, <span class="type">int</span> left2, <span class="type">int</span> down2, <span class="type">int</span> right2, <span class="type">int</span> up2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = max(left1, left2); <span class="comment">// 靠右的</span></span><br><span class="line">    <span class="type">int</span> right = max(min(right1, right2), left);<span class="comment">// 靠左的，但是比左边大</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> down = max(down1, down2);</span><br><span class="line">    <span class="type">int</span> up = max(min(up1, up2), down);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不小心写反了。</span></span><br><span class="line">    <span class="keyword">return</span> -((left1 - right1) * (up1 - down1) + (left2 - right2) * (up2 - down2) - (left - right) * (up - down));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="224-给定一个字符串，包含加减和括号，计算值"><a href="#224-给定一个字符串，包含加减和括号，计算值" class="headerlink" title="224 给定一个字符串，包含加减和括号，计算值"></a>224 给定一个字符串，包含加减和括号，计算值</h2><p>难点是对括号的处理，注意每次都要和 signs.top() 相乘</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; signs; <span class="comment">// signs before braces</span></span><br><span class="line">    <span class="type">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    signs.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">            num = <span class="number">10</span> * num + (c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            result += signs.<span class="built_in">top</span>() * sign * num;</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">            sign = c == <span class="string">&#x27;+&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            signs.<span class="built_in">push</span>(sign * signs.<span class="built_in">top</span>()); <span class="comment">// tricky</span></span><br><span class="line">            sign = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            result += signs.<span class="built_in">top</span>() * sign * num;</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">            signs.<span class="built_in">pop</span>();</span><br><span class="line">            sign = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result += signs.<span class="built_in">top</span>() * sign * num; <span class="comment">// tricky</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="225-使用队列模拟栈"><a href="#225-使用队列模拟栈" class="headerlink" title="225 使用队列模拟栈"></a>225 使用队列模拟栈</h2><p>其实有两种做法，一种是在 push 的时候，把队列清空，把 x 放到最底下。<br>另一种是在 pop 的时候，把队列清空到 1，然后弹出。应当询问面试官究竟是 push 居多还是 pop 居多</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Push element x onto stack.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!nums.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            temp.<span class="built_in">push</span>(nums.<span class="built_in">front</span>());</span><br><span class="line">            nums.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        nums.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">while</span> (!temp.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            nums.<span class="built_in">push</span>(temp.<span class="built_in">front</span>());</span><br><span class="line">            temp.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Removes the element on top of the stack.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        nums.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the top element.</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return whether the stack is empty.</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="226-反转二叉树"><a href="#226-反转二叉树" class="headerlink" title="226 反转二叉树"></a>226 反转二叉树</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">invertTree</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">temp</span> =</span> root-&gt;left;</span><br><span class="line">    root-&gt;left = invertTree(root-&gt;right);</span><br><span class="line">    root-&gt;right = invertTree(temp);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="227-给定一个字符串包含-计算他的值"><a href="#227-给定一个字符串包含-计算他的值" class="headerlink" title="227 给定一个字符串包含 +-*/ 计算他的值"></a>227 给定一个字符串包含 <code>+-*/</code> 计算他的值</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; stk; <span class="comment">// 使用 vector 便于统计最后的值</span></span><br><span class="line">    <span class="type">char</span> token = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i]))</span><br><span class="line">            num = num * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="comment">// 这里不是 else if</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;+&#x27;</span> || s[i] == <span class="string">&#x27;-&#x27;</span> || s[i] == <span class="string">&#x27;*&#x27;</span> || s[i] == <span class="string">&#x27;/&#x27;</span> || i == s.<span class="built_in">size</span>() - <span class="number">1</span>) &#123; <span class="comment">// 注意最后一步还需要把最后的值计算</span></span><br><span class="line">            <span class="type">int</span> a;</span><br><span class="line">            <span class="keyword">switch</span> (token) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                stk.<span class="built_in">push_back</span>(num);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                stk.<span class="built_in">push_back</span>(-num);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                a = stk.<span class="built_in">back</span>();</span><br><span class="line">                stk.<span class="built_in">pop_back</span>();</span><br><span class="line">                stk.<span class="built_in">push_back</span>(a * num);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                a = stk.<span class="built_in">back</span>();</span><br><span class="line">                stk.<span class="built_in">pop_back</span>();</span><br><span class="line">                stk.<span class="built_in">push_back</span>(a / num);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">            token = s[i];</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : stk)</span><br><span class="line">        result += i;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="228-聚合区间，给定一排序数组，把相邻的数字用区间表示"><a href="#228-聚合区间，给定一排序数组，把相邻的数字用区间表示" class="headerlink" title="228 聚合区间，给定一排序数组，把相邻的数字用区间表示"></a>228 聚合区间，给定一排序数组，把相邻的数字用区间表示</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">summaryRanges</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ) &#123;</span><br><span class="line">        <span class="type">int</span> start = i, end = i;</span><br><span class="line">        <span class="keyword">while</span> (end + <span class="number">1</span> &lt; n &amp;&amp; nums[end + <span class="number">1</span>] == nums[end] + <span class="number">1</span>)</span><br><span class="line">            end++;</span><br><span class="line">        <span class="keyword">if</span> (end &gt; start)</span><br><span class="line">            result.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(nums[start]) + <span class="string">&quot;-&gt;&quot;</span> + <span class="built_in">to_string</span>(nums[end]));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(nums[start]));</span><br><span class="line">        i = end + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="229-找出超过三分之一的元素"><a href="#229-找出超过三分之一的元素" class="headerlink" title="229 找出超过三分之一的元素"></a>229 找出超过三分之一的元素</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count1 = <span class="number">0</span>, count2 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count1 == <span class="number">0</span> || n == a) &#123;</span><br><span class="line">            count1++;</span><br><span class="line">            a = n;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count2 == <span class="number">0</span> || n == b) &#123;</span><br><span class="line">            count2++;</span><br><span class="line">            b = n;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count1--;</span><br><span class="line">            count2--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    count1 = count2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == a) count1++;</span><br><span class="line">        <span class="keyword">if</span> (n == b) count2++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count1 &gt; nums.<span class="built_in">size</span>() / <span class="number">3</span>) <span class="comment">// verify a</span></span><br><span class="line">        result.<span class="built_in">push_back</span>(a);</span><br><span class="line">    <span class="keyword">if</span> (count2 &gt; nums.<span class="built_in">size</span>() / <span class="number">3</span> &amp;&amp; a != b) <span class="comment">// verify b</span></span><br><span class="line">        result.<span class="built_in">push_back</span>(b);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="230-二叉树中第-k-小的数字"><a href="#230-二叉树中第-k-小的数字" class="headerlink" title="230 二叉树中第 k 小的数字"></a>230 二叉树中第 k 小的数字</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传递指针</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inorder</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span>* k, <span class="type">int</span>* number)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    inorder(root-&gt;left, k, number);</span><br><span class="line">    (*k)--;</span><br><span class="line">    <span class="keyword">if</span> (*k == <span class="number">0</span>) &#123;</span><br><span class="line">        *number = root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(root-&gt;right, k, number);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    inorder(root, &amp;k, &amp;number);</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="231-2-的次方"><a href="#231-2-的次方" class="headerlink" title="231 2 的次方"></a>231 2 的次方</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>Rust 解答</summary>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">is_power_of_two</span>(n: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        (n &amp; (n-<span class="number">1</span>)) == <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="232-使用栈模拟队列"><a href="#232-使用栈模拟队列" class="headerlink" title="232 使用栈模拟队列"></a>232 使用栈模拟队列</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Push element x to the back of queue.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        in.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Removes the element from in front of queue.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (out.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="built_in">transfer</span>();</span><br><span class="line">        out.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the front element.</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> INT_MIN;</span><br><span class="line">        <span class="keyword">if</span> (out.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="built_in">transfer</span>();</span><br><span class="line">        <span class="keyword">return</span> out.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return whether the queue is empty.</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> in.<span class="built_in">empty</span>() &amp;&amp; out.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">transfer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!in.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            out.<span class="built_in">push</span>(in.<span class="built_in">top</span>());</span><br><span class="line">            in.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; in;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; out;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="233-小于-n-的数字中-1-的个数"><a href="#233-小于-n-的数字中-1-的个数" class="headerlink" title="233 小于 n 的数字中 1 的个数"></a>233 小于 n 的数字中 1 的个数</h2><p>对于每一位，有三种情况：</p>
<ol>
<li>当是数字 0 的时候，可能出先 1 的情况完全由高位出现决定，因为这一位不能贡献 1</li>
<li>当是数字 1 的时候，同上，但是这一位和低位一起可以贡献一个 1</li>
<li>当时数字 2-9 的时候，相当于这一位的 1 可以任意出现，因此高位＋1</li>
</ol>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">countDigitOne</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ones = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">1</span>; m &lt;= n; m *= <span class="number">10</span>) &#123; <span class="comment">// m is the factor</span></span><br><span class="line">        <span class="type">int</span> a = n/m, b = n%m;  <span class="comment">// a is left half, b is right half</span></span><br><span class="line">        <span class="keyword">if</span> (a % <span class="number">10</span> &gt;= <span class="number">2</span>)</span><br><span class="line">            ones += (a / <span class="number">10</span> + <span class="number">1</span>) * m;</span><br><span class="line">        <span class="keyword">if</span> (a % <span class="number">10</span> == <span class="number">1</span>)</span><br><span class="line">            ones += (a / <span class="number">10</span>) * m + b + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a % <span class="number">10</span> == <span class="number">0</span>)</span><br><span class="line">            ones += (a / <span class="number">10</span>) * m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ones;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>二进制呢</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">countDigitOneBinary</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ones = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">1</span>; m &lt;= n; m &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> a = n / m, b = n % m;</span><br><span class="line">        <span class="keyword">if</span> (a &amp; <span class="number">0x01</span>)</span><br><span class="line">            ones += (a &gt;&gt; <span class="number">1</span>) * m + b + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ones += (a &gt;&gt; <span class="number">1</span>) * m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>求最大的 countDigitOne(n) &#x3D;&#x3D; n</p>
<pre><code>9    1
99   20
999  300
...
99999999  10000000
</code></pre>
<h2 id="234-判断一个链表是否是回文"><a href="#234-判断一个链表是否是回文" class="headerlink" title="234 判断一个链表是否是回文"></a>234 判断一个链表是否是回文</h2><p>解法 1: 如果链表是可以改变的，不妨反转它的前半部分，然后再与后半部分比较</p>
<p>解法 2: 如果是只读的，复制一份也可以，但是不如使用堆栈</p>
<p>注意对奇数偶数的处理</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    ListNode* temp = head;</span><br><span class="line">    <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">        len++;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    temp = head;</span><br><span class="line">    <span class="type">int</span> mid = len / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (mid--) &#123;</span><br><span class="line">        stk.<span class="built_in">push</span>(temp-&gt;val);</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &amp; <span class="number">0x01</span>)</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">NULL</span> &amp;&amp; !stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> a = stk.<span class="built_in">top</span>();</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> b = temp-&gt;val;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (a != b) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="235-二叉搜索树公共祖先"><a href="#235-二叉搜索树公共祖先" class="headerlink" title="235 二叉搜索树公共祖先"></a>235 二叉搜索树公共祖先</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">lowestCommonAncestor</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="keyword">struct</span> TreeNode* p, <span class="keyword">struct</span> TreeNode* q)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val)</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val)</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="236-二叉树公共祖先"><a href="#236-二叉树公共祖先" class="headerlink" title="236 二叉树公共祖先"></a>236 二叉树公共祖先</h2><p>如果二叉树的根就是其中一个节点，那显然是这个。<br>在两颗子树中分别查找，如果找到了，返回一个非 NULL 值，如果都找到了，则这个节点就是 LCA</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">lowestCommonAncestor</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="keyword">struct</span> TreeNode* p, <span class="keyword">struct</span> TreeNode* q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root || root == p || root == q)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">left</span> =</span> lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">right</span> =</span> lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!left) <span class="comment">// not in left subtree</span></span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">if</span> (!right)</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">return</span> root; <span class="comment">// both left and right are found!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="237-删除链表中的元素"><a href="#237-删除链表中的元素" class="headerlink" title="237 删除链表中的元素"></a>237 删除链表中的元素</h2><p>直接将后继节点的值复制到当前节点</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">deleteNode</span><span class="params">(<span class="keyword">struct</span> ListNode* node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node || !node-&gt;next)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span> =</span> node-&gt;next;</span><br><span class="line">    node-&gt;val = next-&gt;val;</span><br><span class="line">    node-&gt;next = next-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="238-数组除了自己以外的乘积，规定不能用除法"><a href="#238-数组除了自己以外的乘积，规定不能用除法" class="headerlink" title="238 数组除了自己以外的乘积，规定不能用除法"></a>238 数组除了自己以外的乘积，规定不能用除法</h2><p>首先从前往后乘，错开一位元素，这样每个元素都乘到了他之前的所有元素，最后一个元素已经是结果了。<br>然后从后往前乘，同样错开一位，这样每个元素又把他之后的元素都得到了。</p>
<h2 id="239-滑动窗口最大值，给定一个滑动窗口，返回它移动过程中的最大值"><a href="#239-滑动窗口最大值，给定一个滑动窗口，返回它移动过程中的最大值" class="headerlink" title="239 滑动窗口最大值，给定一个滑动窗口，返回它移动过程中的最大值"></a>239 滑动窗口最大值，给定一个滑动窗口，返回它移动过程中的最大值</h2><p>单调队列的应用，复杂度是 O(n) 的。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MonoQueue</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.q = deque()  <span class="comment"># 实际储存数据</span></span><br><span class="line">        self.m = deque()  <span class="comment"># 维护单调关系，队首元素总是最大值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.q.append(x)</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(self.m) &gt; <span class="number">0</span> <span class="keyword">and</span> self.m[-<span class="number">1</span>] &lt; x:</span><br><span class="line">            self.m.pop()</span><br><span class="line">        self.m.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        x = self.q.popleft()</span><br><span class="line">        <span class="keyword">if</span> self.m[<span class="number">0</span>] == x:</span><br><span class="line">            self.m.popleft()</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.q)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.m[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        q = MonoQueue()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            q.push(nums[i])</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, <span class="built_in">len</span>(nums)):</span><br><span class="line">            ans.append(q.top())</span><br><span class="line">            q.pop()</span><br><span class="line">            q.push(nums[i])</span><br><span class="line">        ans.append(q.top())</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>


<p>另一种现在我已经看不懂的做法</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 题目给定 k 一定是有效地</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>() || k &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; dq; <span class="comment">// 存储的是索引，front 存储最大值，保证递减</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!dq.<span class="built_in">empty</span>() &amp;&amp; dq.<span class="built_in">front</span>() &lt; i - k + <span class="number">1</span>) <span class="comment">// 弹出滑过的窗口</span></span><br><span class="line">            dq.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">while</span> (!dq.<span class="built_in">empty</span>() &amp;&amp; nums[dq.<span class="built_in">back</span>()] &lt; nums[i]) <span class="comment">// 弹出小的</span></span><br><span class="line">            dq.<span class="built_in">pop_back</span>();</span><br><span class="line">        dq.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>)</span><br><span class="line">            result.<span class="built_in">push_back</span>(nums[dq.<span class="built_in">front</span>()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="240-给定一个矩阵，每行从左到右都是增大的，每一列从上到下都是增大的，找出给定数字是否存在"><a href="#240-给定一个矩阵，每行从左到右都是增大的，每一列从上到下都是增大的，找出给定数字是否存在" class="headerlink" title="240 给定一个矩阵，每行从左到右都是增大的，每一列从上到下都是增大的，找出给定数字是否存在"></a>240 给定一个矩阵，每行从左到右都是增大的，每一列从上到下都是增大的，找出给定数字是否存在</h2><p>我们考虑右上角的元素</p>
<ol>
<li>如果这个元素比 taget 大，那么整列都比 target 大，我们可以 c–</li>
<li>如果这个元素比 target 小，那么正行都比 target 小，我们可以 r++</li>
</ol>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>** matrix, <span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>, c = col - <span class="number">1</span>; <span class="comment">// 右上角</span></span><br><span class="line">    <span class="keyword">while</span> (r &lt; row &amp;&amp; c &gt; <span class="number">-1</span>) <span class="comment">// 向左下角</span></span><br><span class="line">        <span class="keyword">if</span> (matrix[r][c] == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (matrix[r][c] &gt; target)</span><br><span class="line">            c--;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="241-添加括号得到不同的结果"><a href="#241-添加括号得到不同的结果" class="headerlink" title="241 添加括号得到不同的结果"></a>241 添加括号得到不同的结果</h2><p>对每一个符号，在他的两边添加括号的好的不同结果再计算。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">diffWaysToCompute</span><span class="params">(string input)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; output;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; input.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">char</span> token = input[i];</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(token)) <span class="comment">// not digit</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> a : <span class="built_in">diffWaysToCompute</span>(input.<span class="built_in">substr</span>(<span class="number">0</span>, i))) <span class="comment">// 左半部分</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> b : <span class="built_in">diffWaysToCompute</span>(input.<span class="built_in">substr</span>(i+<span class="number">1</span>))) <span class="comment">// 右半部分</span></span><br><span class="line">                    output.<span class="built_in">push_back</span>(token == <span class="string">&#x27;+&#x27;</span> ? a + b : token == <span class="string">&#x27;-&#x27;</span>? a - b: a *b); <span class="comment">// 两半部分之和</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (output.<span class="built_in">empty</span>())</span><br><span class="line">        output.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(input));</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="242-一个单词是否能由另一个变幻而来"><a href="#242-一个单词是否能由另一个变幻而来" class="headerlink" title="242 一个单词是否能由另一个变幻而来"></a>242 一个单词是否能由另一个变幻而来</h2><p>还是，对于 ASCII 字符，直接用数组代替字典</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isAnagram</span><span class="params">(<span class="type">char</span>* s, <span class="type">char</span>* t)</span> &#123;</span><br><span class="line">    <span class="type">char</span> ss[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> ts[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (*s) &#123;</span><br><span class="line">        ss[*s - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        s++;</span><br><span class="line">        ts[*t - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        t++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (*t) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">memcmp</span>(ss, ts, <span class="keyword">sizeof</span>(ss)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>243-256 Locked</p>
<h2 id="257-二叉树左右路径"><a href="#257-二叉树左右路径" class="headerlink" title="257 二叉树左右路径"></a>257 二叉树左右路径</h2><p>典型的 DFS，发挥所有从根节点到叶节点的路径</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line">    <span class="built_in">paths</span>(result, <span class="string">&quot;&quot;</span>, root);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">paths</span><span class="params">(vector&lt;string&gt;&amp; result, string path, TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (path.<span class="built_in">empty</span>())</span><br><span class="line">        path += <span class="built_in">to_string</span>(root-&gt;val);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        path += <span class="string">&quot;-&gt;&quot;</span> + <span class="built_in">to_string</span>(root-&gt;val);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left)</span><br><span class="line">        <span class="built_in">paths</span>(result, path, root-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right)</span><br><span class="line">        <span class="built_in">paths</span>(result, path, root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="258-把数字的每一位加起来，直到变成一个一位的数字"><a href="#258-把数字的每一位加起来，直到变成一个一位的数字" class="headerlink" title="258 把数字的每一位加起来，直到变成一个一位的数字"></a>258 把数字的每一位加起来，直到变成一个一位的数字</h2><p>这完全是一道数学题，对于每个进制的数字都有规律 <code>(n - 1) % (x - 1) + 1</code>。实际上是把 10 进制的转化为 9 进制数字</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">addDigits</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (num - <span class="number">1</span>) % <span class="number">9</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>259 Locked</p>
<h2 id="260-给定一个数组，每个数字都是重复的，只有两个数字不是，找出这两个数字"><a href="#260-给定一个数组，每个数字都是重复的，只有两个数字不是，找出这两个数字" class="headerlink" title="260 给定一个数组，每个数字都是重复的，只有两个数字不是，找出这两个数字"></a>260 给定一个数组，每个数字都是重复的，只有两个数字不是，找出这两个数字</h2><p>这道题很奇妙，依然可以使用 XOR 来解，首先遍历一遍，这时候由于有两个数字是不同的，那么一定结果不为 0，那么其中一个 bit 位一定是一个数字有，另一个数字没有。<br>在遍历一遍，同时把数字分两组，一组是有这个 bit 位，一组没有。就得出了结果。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; n : nums)</span><br><span class="line">        r ^= n;</span><br><span class="line">    <span class="type">int</span> bit = r &amp; -r; <span class="comment">// last sig bit</span></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; n : nums)</span><br><span class="line">        <span class="keyword">if</span> (n &amp; bit)</span><br><span class="line">            result[<span class="number">0</span>] ^= n;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            result[<span class="number">1</span>] ^= n;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>261 262 Locked</p>
<h2 id="263-丑陋的数字，质数因子只含有-2-3-5-的数字"><a href="#263-丑陋的数字，质数因子只含有-2-3-5-的数字" class="headerlink" title="263 丑陋的数字，质数因子只含有 2,3,5 的数字"></a>263 丑陋的数字，质数因子只含有 2,3,5 的数字</h2><p>按定义做就好了</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isUgly</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            n /= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">            n /= <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">            n /= <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="264-找出第-n-个丑陋数字"><a href="#264-找出第-n-个丑陋数字" class="headerlink" title="264 找出第 n 个丑陋数字"></a>264 找出第 n 个丑陋数字</h2><p>使用数列记录 n 个丑陋数字，每一个丑陋数字肯定是之前数字乘以 235 得到的，然后用三个指针分别指向上一个做乘法的数字，每次找出最小的一个</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a,b) ((a)&lt;(b)?(a):(b))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">nthUglyNumber</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">6</span>) <span class="comment">// 1..6 恰好都是</span></span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="type">int</span> s2 = <span class="number">0</span>, s3 = <span class="number">0</span>, s5 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>* uglies[n];</span><br><span class="line">    uglies[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> c2 = uglies[s2] * <span class="number">2</span>, c3 = uglies[s3] * <span class="number">3</span>, c5 = uglies[s5] * <span class="number">5</span>;</span><br><span class="line">        uglies[i] = MIN(c2, MIN(c3, c5));</span><br><span class="line">        <span class="keyword">if</span> (uglies[i] == c2) s2++;</span><br><span class="line">        <span class="keyword">if</span> (uglies[i] == c3) s3++;</span><br><span class="line">        <span class="keyword">if</span> (uglies[i] == c5) s5++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uglies[n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="268-丢失的数字，给定-0…n，丢失了一个，然后放在长度为-n-的数组之中，找出这个数字"><a href="#268-丢失的数字，给定-0…n，丢失了一个，然后放在长度为-n-的数组之中，找出这个数字" class="headerlink" title="268 丢失的数字，给定 0…n，丢失了一个，然后放在长度为 n 的数组之中，找出这个数字"></a>268 丢失的数字，给定 0…n，丢失了一个，然后放在长度为 n 的数组之中，找出这个数字</h2><p>显然还是使用异或，注意 0 ^ x &#x3D;&#x3D; x，所以直接把 0 忽略就行了。把每个数字都和 i 异或，丢失的数字就出来了</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">missingNumber</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        result = result ^ (i + <span class="number">1</span>) ^ nums[i];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>269-272 Locked</p>
<h2 id="273-数字转换为英语单词"><a href="#273-数字转换为英语单词" class="headerlink" title="273 数字转换为英语单词"></a>273 数字转换为英语单词</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; digits = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;One&quot;</span>, <span class="string">&quot;Two&quot;</span>, <span class="string">&quot;Three&quot;</span>, <span class="string">&quot;Four&quot;</span>, <span class="string">&quot;Five&quot;</span>, <span class="string">&quot;Six&quot;</span>, <span class="string">&quot;Seven&quot;</span>, <span class="string">&quot;Eight&quot;</span>, <span class="string">&quot;Nine&quot;</span>, <span class="string">&quot;Ten&quot;</span>, <span class="string">&quot;Eleven&quot;</span>, <span class="string">&quot;Twelve&quot;</span>, <span class="string">&quot;Thirteen&quot;</span>, <span class="string">&quot;Fourteen&quot;</span>, <span class="string">&quot;Fifteen&quot;</span>, <span class="string">&quot;Sixteen&quot;</span>, <span class="string">&quot;Seventeen&quot;</span>, <span class="string">&quot;Eighteen&quot;</span>, <span class="string">&quot;Nineteen&quot;</span>&#125;;</span><br><span class="line">    vector&lt;string&gt; tens = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Twenty&quot;</span>, <span class="string">&quot;Thirty&quot;</span>, <span class="string">&quot;Forty&quot;</span>, <span class="string">&quot;Fifty&quot;</span>, <span class="string">&quot;Sixty&quot;</span>, <span class="string">&quot;Seventy&quot;</span>, <span class="string">&quot;Eighty&quot;</span>, <span class="string">&quot;Ninety&quot;</span>&#125;;</span><br><span class="line">    vector&lt;string&gt; seps = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot; Thousand &quot;</span>, <span class="string">&quot; Million &quot;</span>, <span class="string">&quot; Billion &quot;</span>&#125;; <span class="comment">// notice the trailing spaces</span></span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">numberToWords</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Zero&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Negative &quot;</span> + <span class="built_in">numberToWords</span>(-num);</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        string result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (num) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">1000</span> != <span class="number">0</span>)</span><br><span class="line">                result = <span class="built_in">s2word</span>(num % <span class="number">1000</span>) + seps[count] + result;</span><br><span class="line">            num /= <span class="number">1000</span>;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// removw unnecessary tailing space</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(result.<span class="built_in">back</span>()))</span><br><span class="line">            result.<span class="built_in">resize</span>(result.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">s2word</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        string result;</span><br><span class="line">        <span class="keyword">if</span> (num &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">            result += digits[num/<span class="number">100</span>] + <span class="string">&quot; Hundred &quot;</span>;</span><br><span class="line">            num %= <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (num &gt;= <span class="number">20</span>) &#123;</span><br><span class="line">            result += tens[num / <span class="number">10</span>] + <span class="string">&quot; &quot;</span>;</span><br><span class="line">            num %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (num &gt;= <span class="number">1</span> &amp;&amp; num &lt;= <span class="number">19</span>)</span><br><span class="line">            result += digits[num];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// remove tailing spaces</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(result.<span class="built_in">back</span>()))</span><br><span class="line">            result.<span class="built_in">resize</span>(result.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="274-H-Index"><a href="#274-H-Index" class="headerlink" title="274 H-Index"></a>274 H-Index</h2><p>H-Index 的定义：一个科学家的 N 篇论文 h 个至少有 h 个引用，而且剩下的 N-h 篇论文都没有超过 h 个引用。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hIndex</span><span class="params">(<span class="type">int</span>* cites, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> hs[n+<span class="number">1</span>]; <span class="comment">// Hindex 不可能大于 N</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        hs[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cites[i] &gt; n)</span><br><span class="line">            hs[n]++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            hs[cites[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n, papers = <span class="number">0</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 从后往前，如果有符合条件的，那么就是 Hindex</span></span><br><span class="line">        papers += hs[i];</span><br><span class="line">        <span class="keyword">if</span> (papers &gt;= i)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="275-H-index-II，论文已经按照引用数量排序"><a href="#275-H-index-II，论文已经按照引用数量排序" class="headerlink" title="275 H-index II，论文已经按照引用数量排序"></a>275 H-index II，论文已经按照引用数量排序</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hIndex</span><span class="params">(<span class="type">int</span>* citations, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123; <span class="comment">// 二分查找是小于等于</span></span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (citations[mid] == n - mid)</span><br><span class="line">            <span class="keyword">return</span> citations[mid];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (citations[mid] &lt; n - mid)</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n - right - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>276-277 Locked</p>
<h2 id="278-第一个坏版本"><a href="#278-第一个坏版本" class="headerlink" title="278 第一个坏版本"></a>278 第一个坏版本</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际上是 lower_bound 函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">firstBadVersion</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = n; <span class="comment">// 记住 lower_bound 的 right 是 n</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;   <span class="comment">// 使用小于号</span></span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (!isBadVersion(mid))</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="279-分解为平方数的和"><a href="#279-分解为平方数的和" class="headerlink" title="279 分解为平方数的和"></a>279 分解为平方数的和</h2><p>最多 4 个即可，尝试在三个以内是否可以。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ub = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a=<span class="number">0</span>; a&lt;=ub; ++a) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> b=a; b&lt;=ub; ++b) &#123;</span><br><span class="line">            <span class="type">int</span> c = <span class="built_in">sqrt</span>(n - a*a - b*b);</span><br><span class="line">            <span class="keyword">if</span> (a*a + b*b + c*c == n)</span><br><span class="line">                <span class="keyword">return</span> !!a + !!b + !!c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="282-添加运算符使得算式成立"><a href="#282-添加运算符使得算式成立" class="headerlink" title="282 添加运算符使得算式成立"></a>282 添加运算符使得算式成立</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">addOperators</span><span class="params">(string num, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (num.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    <span class="built_in">dfs</span>(num, target, result, num[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>, num.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">1</span>), <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string num, <span class="type">int</span> target, vector&lt;string&gt; &amp; v, <span class="type">long</span> <span class="type">long</span> last, string s, <span class="type">int</span> idx, <span class="type">int</span> left)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (idx == num.<span class="built_in">length</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == last*left)</span><br><span class="line">            v.<span class="built_in">push_back</span>(s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(last!=<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">dfs</span>(num, target,         v, last * <span class="number">10</span> + num[idx] - <span class="string">&#x27;0&#x27;</span>, s + num.<span class="built_in">substr</span>(idx, <span class="number">1</span>), idx + <span class="number">1</span>, left); <span class="comment">// 尝试拼成 10</span></span><br><span class="line">        <span class="built_in">dfs</span>(num, target,             v, num[idx] - <span class="string">&#x27;0&#x27;</span>, s + <span class="string">&#x27;*&#x27;</span> + num.<span class="built_in">substr</span>(idx, <span class="number">1</span>), idx + <span class="number">1</span>, last*left);</span><br><span class="line">        <span class="built_in">dfs</span>(num, target - left*last, v, num[idx] - <span class="string">&#x27;0&#x27;</span>, s + <span class="string">&#x27;+&#x27;</span> + num.<span class="built_in">substr</span>(idx, <span class="number">1</span>), idx + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(num, target - left*last, v, num[idx] - <span class="string">&#x27;0&#x27;</span>, s + <span class="string">&#x27;-&#x27;</span> + num.<span class="built_in">substr</span>(idx, <span class="number">1</span>), idx + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="283-移动-0"><a href="#283-移动-0" class="headerlink" title="283 移动 0"></a>283 移动 0</h2><p>注意 swap 的使用</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">swap</span>(nums[n++], nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="284-Peek-Iterator"><a href="#284-Peek-Iterator" class="headerlink" title="284 Peek Iterator"></a>284 Peek Iterator</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Below is the interface for Iterator, which is already defined for you.</span></span><br><span class="line"><span class="comment">// **DO NOT** modify the interface for Iterator.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Data</span>;</span><br><span class="line">    Data* data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Iterator</span>(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums);</span><br><span class="line">    <span class="built_in">Iterator</span>(<span class="type">const</span> Iterator&amp; iter);</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Iterator</span>();</span><br><span class="line">    <span class="comment">// Returns the next element in the iteration.</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// Returns true if the iteration has more elements.</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasNext</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PeekingIterator</span> : <span class="keyword">public</span> Iterator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PeekingIterator</span>(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums) : <span class="built_in">Iterator</span>(nums) &#123;</span><br><span class="line">        <span class="comment">// Initialize any member here.</span></span><br><span class="line">        <span class="comment">// **DO NOT** save a copy of nums and manipulate it directly.</span></span><br><span class="line">        <span class="comment">// You should only use the Iterator interface methods.</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns the next element in the iteration without advancing the iterator.</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Iterator</span>(*<span class="keyword">this</span>).<span class="built_in">next</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hasNext() and next() should behave the same as in the Iterator interface.</span></span><br><span class="line">    <span class="comment">// Override them if needed.</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Iterator::<span class="built_in">next</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasNext</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Iterator::<span class="built_in">hasNext</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="285-286-Locked"><a href="#285-286-Locked" class="headerlink" title="285 ~ 286 Locked"></a>285 ~ 286 Locked</h2><h2 id="287-一个-n-的数组包含了-1…n-1-中的这些数字，证明一定存在重复，并找出这个重复"><a href="#287-一个-n-的数组包含了-1…n-1-中的这些数字，证明一定存在重复，并找出这个重复" class="headerlink" title="287 一个 n 的数组包含了 1…n-1 中的这些数字，证明一定存在重复，并找出这个重复"></a>287 一个 n 的数组包含了 1…n-1 中的这些数字，证明一定存在重复，并找出这个重复</h2><p>使用抽屉原理可以证明一定存在重复。据说高纳德解这个问题花了四个小时。</p>
<p>我们把这个数组看做一个变幻方程 <code>f(i) = A[i]</code>，把一些数字变幻到另一些，那么存在一个 <code>i != j s.t. f(i) == f(j)</code>.<br>那么这个问题变成了链表求环的问题。对于链表，我们有 n &#x3D; n-&gt;next 遍历列表，对于这个序列，则是<code> n = f(n)</code></p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findDuplicate</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 从 n-1 开始</span></span><br><span class="line">    <span class="type">int</span> fast = n - <span class="number">1</span>, slow = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        slow = nums[slow] - <span class="number">1</span>; <span class="comment">// 减一是为了转化为坐标</span></span><br><span class="line">        fast = nums[nums[fast] - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (slow != fast);</span><br><span class="line"></span><br><span class="line">    fast = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        slow = nums[slow] - <span class="number">1</span>;</span><br><span class="line">        fast = nums[fast] - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (slow != fast);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow + <span class="number">1</span>; <span class="comment">// 从坐标到数字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="288-Locked"><a href="#288-Locked" class="headerlink" title="288 Locked"></a>288 Locked</h2><h2 id="289-Conway’s-Game-of-Life"><a href="#289-Conway’s-Game-of-Life" class="headerlink" title="289 Conway’s Game of Life"></a>289 Conway’s Game of Life</h2><p>哈哈，机智，使用没有使用的第二个位存储下一代</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;<span class="keyword">return</span> a &gt; b ? a :b;&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;<span class="keyword">return</span> a &lt; b ? a :b;&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">gameOfLife</span><span class="params">(<span class="type">int</span>** board, <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">            <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> m=max(i<span class="number">-1</span>, <span class="number">0</span>); m&lt;min(i+<span class="number">2</span>, row); m++) <span class="comment">// 这里的 min，max 使用的太屌了</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> n=max(j<span class="number">-1</span>, <span class="number">0</span>); n&lt;min(j+<span class="number">2</span>, col); n++)</span><br><span class="line">                    count += (board[m][n] &amp; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">3</span> || count - board[i][j] == <span class="number">3</span>) <span class="comment">// 当前为 0，周围为 3；or 当前为 1，周围为 2/3 here</span></span><br><span class="line">                board[i][j] |= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">            board[i][j] &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="290-单词模式，给定一个模式-abba-等，判断单词是否是这个模式的。"><a href="#290-单词模式，给定一个模式-abba-等，判断单词是否是这个模式的。" class="headerlink" title="290 单词模式，给定一个模式 abba 等，判断单词是否是这个模式的。"></a>290 单词模式，给定一个模式 abba 等，判断单词是否是这个模式的。</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wordPattern</span><span class="params">(string pattern, string str)</span> </span>&#123;</span><br><span class="line">    map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; chars;  <span class="comment">// 使用两个 map 纪录</span></span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; words;</span><br><span class="line">    <span class="function">istringstream <span class="title">in</span><span class="params">(str)</span></span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, n = pattern.<span class="built_in">size</span>(); <span class="comment">// `i` is word count</span></span><br><span class="line">    <span class="keyword">for</span> (string word; in &gt;&gt; word; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n || chars[pattern[i]] != words[word]) <span class="comment">// 检查是否相等</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        chars[pattern[i]] = words[word] = i + <span class="number">1</span>; <span class="comment">// distinct non zero</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i == n; <span class="comment">// 检查长度是否相等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="291-Locked"><a href="#291-Locked" class="headerlink" title="291 Locked"></a>291 Locked</h2><h2 id="292-Nim-游戏，每个人可以选择丢掉-1，2，3，最后一个操作者获胜"><a href="#292-Nim-游戏，每个人可以选择丢掉-1，2，3，最后一个操作者获胜" class="headerlink" title="292 Nim 游戏，每个人可以选择丢掉 1，2，3，最后一个操作者获胜"></a>292 Nim 游戏，每个人可以选择丢掉 1，2，3，最后一个操作者获胜</h2><p>显然，当我们遇到 4 的时候会输，其他情况都可以赢。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">canWinNim</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n % <span class="number">4</span> != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300 最长递增子序列"></a>300 最长递增子序列</h2><p>最经典的动态规划题目</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLIS</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        dp = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(*dp)</span><br></pre></td></tr></table></figure>
</details>


<h2 id="344-翻转字符串"><a href="#344-翻转字符串" class="headerlink" title="344 翻转字符串"></a>344 翻转字符串</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="type">char</span>* start = s;</span><br><span class="line">    <span class="type">char</span>* e = s;</span><br><span class="line">    <span class="keyword">while</span> (*e) ++e;</span><br><span class="line">    e--;</span><br><span class="line">    <span class="type">char</span> t;</span><br><span class="line">    <span class="keyword">while</span> (s &lt; e) &#123;</span><br><span class="line">        t = *s;</span><br><span class="line">        *s = *e;</span><br><span class="line">        *e = t;</span><br><span class="line">        s++;</span><br><span class="line">        e--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="347-出现最多的几个数字"><a href="#347-出现最多的几个数字" class="headerlink" title="347 出现最多的几个数字"></a>347 出现最多的几个数字</h2><p>C 实在缺乏相关的基础数据结构，这道题用 JS 做了</p>
<details>
    <summary>JavaScript 解答</summary>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> topKFrequent = <span class="keyword">function</span>(<span class="params">nums, k</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> counter = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num <span class="keyword">in</span> counter) &#123;</span><br><span class="line">            counter[num]++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            counter[num] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> bucket = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">in</span> counter) &#123;</span><br><span class="line">        <span class="keyword">let</span> rev_freq = nums.<span class="property">length</span> - counter[num] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (rev_freq <span class="keyword">in</span> bucket) &#123;</span><br><span class="line">            bucket[rev_freq].<span class="title function_">push</span>(num);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            bucket[rev_freq] = [num];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> rv = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> bc <span class="keyword">of</span> bucket) &#123;</span><br><span class="line">        <span class="keyword">if</span> (! <span class="title class_">Array</span>.<span class="title function_">isArray</span>(bc)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> bc) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rv.<span class="property">length</span> == k)</span><br><span class="line">                <span class="keyword">return</span> rv;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                rv.<span class="title function_">push</span>(<span class="built_in">parseInt</span>(num))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="349-两个数组中都出现的元素"><a href="#349-两个数组中都出现的元素" class="headerlink" title="349 两个数组中都出现的元素"></a>349 两个数组中都出现的元素</h2><p>先排序，降低复杂度</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a, <span class="type">const</span> <span class="type">void</span>* b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">int</span>*)a - *(<span class="type">int</span>*)b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>* <span class="title function_">intersection</span><span class="params">(<span class="type">int</span>* A, <span class="type">int</span> m, <span class="type">int</span>* B, <span class="type">int</span> n, <span class="type">int</span>* k)</span> &#123;</span><br><span class="line">    qsort(A, m, <span class="keyword">sizeof</span>(<span class="type">int</span>), compare);</span><br><span class="line">    qsort(B, n, <span class="keyword">sizeof</span>(<span class="type">int</span>), compare);</span><br><span class="line">    <span class="type">int</span>* C = <span class="built_in">malloc</span>((m + n) * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *k = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; m &amp;&amp; j &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] == B[j]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*k == <span class="number">0</span>)</span><br><span class="line">                C[(*k)++] = A[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (C[*k - <span class="number">1</span>] != A[i])</span><br><span class="line">                C[(*k)++] = A[i];</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (A[i] &lt; B[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<h2 id="345-翻转一个字符串里面的元音字母"><a href="#345-翻转一个字符串里面的元音字母" class="headerlink" title="345 翻转一个字符串里面的元音字母"></a>345 翻转一个字符串里面的元音字母</h2><p>使用两个指针，不过需要注意元音字母包括了大小写</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseVowels</span>(<span class="params">self, s</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        vowels = <span class="built_in">set</span>(<span class="string">&quot;AEIOUaeiou&quot;</span>)</span><br><span class="line">        s = <span class="built_in">list</span>(s)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">while</span> s[i] <span class="keyword">not</span> <span class="keyword">in</span> vowels <span class="keyword">and</span> i &lt; j:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> s[j] <span class="keyword">not</span> <span class="keyword">in</span> vowels <span class="keyword">and</span> i &lt; j:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= j:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            s[i], s[j] = s[j], s[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(s)</span><br></pre></td></tr></table></figure>
</details>


<h2 id="371-两个数之和"><a href="#371-两个数之和" class="headerlink" title="371 两个数之和"></a>371 两个数之和</h2><p>这道题要求不用 + 和 - 来计算出两个数之和，显然应该使用位运算，使用异或计算每一位的值，在使用或计算是否需要进位</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> rv = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> last_bit_of_a = a &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> last_bit_of_b = b &amp; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        rv |= (last_bit_of_a ^ last_bit_of_b ^ carry) &lt;&lt; i;</span><br><span class="line">        carry = (carry &amp; last_bit_of_a) | (carry &amp; last_bit_of_b) | (last_bit_of_a &amp; last_bit_of_b);</span><br><span class="line"></span><br><span class="line">        a &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="388"><a href="#388" class="headerlink" title="388"></a>388</h2><p>使用栈的一道简单题目, 其实计算长度部分还可以优化</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthLongestPath</span>(<span class="params">self, <span class="built_in">input</span>: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        path = []</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> <span class="built_in">input</span>.split(<span class="string">&quot;\n&quot;</span>):</span><br><span class="line">            l = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> name:</span><br><span class="line">                <span class="keyword">if</span> c == <span class="string">&quot;\t&quot;</span>:</span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) &gt; l:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(path) - l):</span><br><span class="line">                    path.pop()</span><br><span class="line">            path.append(name.strip(<span class="string">&quot;\t&quot;</span>))</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;.&quot;</span> <span class="keyword">in</span> name:</span><br><span class="line">                length = <span class="built_in">sum</span>([<span class="built_in">len</span>(p) <span class="keyword">for</span> p <span class="keyword">in</span> path]) + <span class="built_in">len</span>(path) - <span class="number">1</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, length)</span><br><span class="line">                <span class="built_in">print</span>(path)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>


<h2 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435 无重叠区间"></a>435 无重叠区间</h2><p>不要被题目迷惑，从反面开始思考，求去除多少个区间其实就是求最多有多少个有效区间</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eraseOverlapIntervals</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        intervals.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line">        max_intervals = <span class="number">0</span></span><br><span class="line">        end = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> interval <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="keyword">if</span> interval[<span class="number">0</span>] &gt;= end:</span><br><span class="line">                max_intervals += <span class="number">1</span></span><br><span class="line">                end = interval[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(intervals) - max_intervals</span><br></pre></td></tr></table></figure>
</details>


<h2 id="482-注册码格式化"><a href="#482-注册码格式化" class="headerlink" title="482 注册码格式化"></a>482 注册码格式化</h2><p>要求每 K 个字符添加一个 “-“, 如果不够的话，第一个分组可以不全。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">licenseKeyFormatting</span>(<span class="params">self, S: <span class="built_in">str</span>, K: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        key = []</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">reversed</span>(S):</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            key.append(c.upper())</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i % K == <span class="number">0</span>:</span><br><span class="line">                key.append(<span class="string">&quot;-&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">and</span> key[-<span class="number">1</span>] == <span class="string">&quot;-&quot;</span>:</span><br><span class="line">            key = key[:-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(<span class="built_in">reversed</span>(key))</span><br></pre></td></tr></table></figure>
</details>


<h2 id="547-朋友圈"><a href="#547-朋友圈" class="headerlink" title="547 朋友圈"></a>547 朋友圈</h2><p>UnionFind 的定义见第 200 题</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findCircleNum</span>(<span class="params">self, M: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(M)</span><br><span class="line">        uf = UnionFind(n)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                <span class="keyword">if</span> M[i][j] == <span class="number">1</span>:</span><br><span class="line">                    uf.union(i, j)</span><br><span class="line">        <span class="keyword">return</span> uf.count</span><br></pre></td></tr></table></figure>
</details>


<h2 id="739"><a href="#739" class="headerlink" title="739"></a>739</h2><p>单调栈的简单应用</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dailyTemperatures</span>(<span class="params">self, T: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        stack = []</span><br><span class="line">        ans = [<span class="number">0</span>] * <span class="built_in">len</span>(T)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(T)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 如果当前温度大于当前最低温度</span></span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> T[i] &gt;= T[stack[-<span class="number">1</span>]]:</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">if</span> stack:</span><br><span class="line">                ans[i] = stack[-<span class="number">1</span>] - i</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>


<h2 id="864-矩形重叠"><a href="#864-矩形重叠" class="headerlink" title="864 矩形重叠"></a>864 矩形重叠</h2><details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isRectangleOverlap</span>(<span class="params">self, rec1: <span class="type">List</span>[<span class="built_in">int</span>], rec2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 注意要包含等于号</span></span><br><span class="line">        x_overlap = <span class="keyword">not</span>(rec1[<span class="number">0</span>] &gt;= rec2[<span class="number">2</span>] <span class="keyword">or</span> rec1[<span class="number">2</span>] &lt;= rec2[<span class="number">0</span>])</span><br><span class="line">        y_overlap = <span class="keyword">not</span>(rec1[<span class="number">1</span>] &gt;= rec2[<span class="number">3</span>] <span class="keyword">or</span> rec1[<span class="number">3</span>] &lt;= rec2[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> x_overlap <span class="keyword">and</span> y_overlap</span><br></pre></td></tr></table></figure>
</details>



<h2 id="904-找出包含了两个不同数字的最长子序列"><a href="#904-找出包含了两个不同数字的最长子序列" class="headerlink" title="904 找出包含了两个不同数字的最长子序列"></a>904 找出包含了两个不同数字的最长子序列</h2><p>这道题的题目很坑爹，但是翻译过来其实要求很明确。解题思路也很简单，存储一下当前的最长序列<br>就好了。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">&lt;/details&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;details&gt;</span><br><span class="line">    &lt;summary&gt;Rust 解答&lt;/summary&gt;</span><br><span class="line"></span><br><span class="line">```Rust</span><br><span class="line">use std::collections::HashMap;</span><br><span class="line">use std::cmp::max;</span><br><span class="line"></span><br><span class="line">impl Solution &#123;</span><br><span class="line">    <span class="function">pub fn <span class="title">total_fruit</span><span class="params">(tree: Vec&lt;i32&gt;)</span> -&gt; i32 </span>&#123;</span><br><span class="line">        let mut i = <span class="number">0</span>;</span><br><span class="line">        let mut res = <span class="number">0</span>;</span><br><span class="line">        let mut counter = HashMap::<span class="built_in">new</span>();</span><br><span class="line">        <span class="keyword">for</span> (j, el) in tree.<span class="built_in">iter</span>().<span class="built_in">enumerate</span>() &#123;</span><br><span class="line">            *counter.<span class="built_in">entry</span>(el).<span class="built_in">or_insert</span>(<span class="number">0</span>) += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> counter.<span class="built_in">len</span>() &gt; <span class="number">2</span> &#123;</span><br><span class="line">                *counter.<span class="built_in">get_mut</span>(&amp;tree[i]).<span class="built_in">unwrap</span>() -= <span class="number">1</span>;</span><br><span class="line">                <span class="function"><span class="keyword">if</span> let <span class="title">Some</span><span class="params">(x)</span> </span>= counter.<span class="built_in">get</span>(&amp;tree[i]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> *x == <span class="number">0</span> &#123;</span><br><span class="line">                        counter.<span class="built_in">remove</span>(&amp;tree[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, j - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        res as i32</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="986-区间列表的交集"><a href="#986-区间列表的交集" class="headerlink" title="986 区间列表的交集"></a>986 区间列表的交集</h2><p>tags: #interval</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intervalIntersection</span>(<span class="params">self, A: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], B: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(A) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(B):</span><br><span class="line">            lo = <span class="built_in">max</span>(A[i][<span class="number">0</span>], B[j][<span class="number">0</span>])</span><br><span class="line">            hi = <span class="built_in">min</span>(A[i][<span class="number">1</span>], B[j][<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> lo &lt;= hi:</span><br><span class="line">                ans.append((lo, hi))</span><br><span class="line">            <span class="keyword">if</span> A[i][<span class="number">1</span>] &lt; B[j][<span class="number">1</span>]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>


<h2 id="929-唯一邮件地址"><a href="#929-唯一邮件地址" class="headerlink" title="929 唯一邮件地址"></a>929 唯一邮件地址</h2><p>类似 Gmail 的规则，<code>.</code> 去掉，<code>+</code> 后面的也去掉。但是要注意域名中的 <code>.</code> 不能去掉</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">normalize</span>(<span class="params">self, username: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        username = username.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="comment"># 使用 split 更好，懒得改了</span></span><br><span class="line">        username = re.sub(<span class="string">r&quot;\+.*$&quot;</span>, <span class="string">&quot;&quot;</span>, username)</span><br><span class="line">        <span class="keyword">return</span> username</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numUniqueEmails</span>(<span class="params">self, emails: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        unique_emails = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> email <span class="keyword">in</span> emails:</span><br><span class="line">            username, domain = email.split(<span class="string">&quot;@&quot;</span>)</span><br><span class="line">            username = self.normalize(username)</span><br><span class="line">            <span class="comment"># print(username, domain)</span></span><br><span class="line">            unique_emails.add(<span class="string">f&quot;<span class="subst">&#123;username&#125;</span>@<span class="subst">&#123;domain&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(unique_emails)</span><br></pre></td></tr></table></figure>
</details>


<h2 id="970-强力数字"><a href="#970-强力数字" class="headerlink" title="970 强力数字"></a>970 强力数字</h2><p>暴力解法</p>
<details>
    <summary>python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">powerfulIntegers</span>(<span class="params">self, x: <span class="built_in">int</span>, y: <span class="built_in">int</span>, bound: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> bound &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans = <span class="built_in">set</span>()</span><br><span class="line">        limit = <span class="built_in">int</span>(math.log2(bound)) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(limit):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(limit):</span><br><span class="line">                v = x ** i + y ** j</span><br><span class="line">                <span class="keyword">if</span> v &lt;= bound:</span><br><span class="line">                    ans.add(v)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(ans)</span><br></pre></td></tr></table></figure>
</details>


<h2 id="1272-删除区间"><a href="#1272-删除区间" class="headerlink" title="1272 删除区间"></a>1272 删除区间</h2><details>
    <summary>python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeInterval</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], toBeRemoved: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        lo, hi = toBeRemoved</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="keyword">if</span> y &lt; lo <span class="keyword">or</span> x &gt; hi:</span><br><span class="line">                ans.append([x, y])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> lo &gt; x:</span><br><span class="line">                    ans.append([x, lo])</span><br><span class="line">                <span class="keyword">if</span> hi &lt; y:</span><br><span class="line">                    ans.append([hi, y])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>


<h2 id="1317-将整数转换为两个无零整数的和"><a href="#1317-将整数转换为两个无零整数的和" class="headerlink" title="1317 将整数转换为两个无零整数的和"></a>1317 将整数转换为两个无零整数的和</h2><details>
    <summary>python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getNoZeroIntegers</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            b = n - a</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;0&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">str</span>(a) <span class="keyword">and</span> <span class="string">&quot;0&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">str</span>(b):</span><br><span class="line">                <span class="keyword">return</span> [a, b]</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
</details>


<h2 id="1389-按既定顺序创建目标数组"><a href="#1389-按既定顺序创建目标数组" class="headerlink" title="1389 按既定顺序创建目标数组"></a>1389 按既定顺序创建目标数组</h2><details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">createTargetArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], index: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        target = []</span><br><span class="line">        <span class="keyword">for</span> n, i <span class="keyword">in</span> <span class="built_in">zip</span>(nums, index):</span><br><span class="line">            target = target[:i] + [n] + target[i:]</span><br><span class="line">        <span class="keyword">return</span> target</span><br></pre></td></tr></table></figure>
</details>


<h2 id="1390-四因数"><a href="#1390-四因数" class="headerlink" title="1390 四因数"></a>1390 四因数</h2><p>解释见注释，这道题还是很坑的。不过其实也很简单，四个因数就是能够分解成两个质数乘积或者是立方数。</p>
<p>比如：</p>
<ol>
<li>21 &#x3D; 3 * 7</li>
<li>8 &#x3D; 2 * 4</li>
</ol>
<details>
    <summary>py 解答</summary>

<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumFourDivisors</span>(<span class="params">self, nums</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">            upper = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            upper = <span class="built_in">max</span>(*nums)</span><br><span class="line">        <span class="comment"># 首先在这里筛选素数</span></span><br><span class="line">        isPrim = [<span class="literal">True</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(upper)]</span><br><span class="line">        i = <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> i * i &lt; upper:</span><br><span class="line">            <span class="keyword">if</span> isPrim[i]:</span><br><span class="line">                j = i * i</span><br><span class="line">                <span class="keyword">while</span> j &lt; upper:</span><br><span class="line">                    isPrim[j] = <span class="literal">False</span></span><br><span class="line">                    j += i</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 把素数都提取出来</span></span><br><span class="line">        prims = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, upper) <span class="keyword">if</span> isPrim[i]]</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">for</span> prim <span class="keyword">in</span> prims:</span><br><span class="line">                <span class="comment"># 已经不可能了，后续不算了</span></span><br><span class="line">                <span class="keyword">if</span> prim * prim &gt; num:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="comment"># 立方数是符合的，这个比较坑，开始没想到，比如 8</span></span><br><span class="line">                <span class="keyword">if</span> prim * prim * prim == num:</span><br><span class="line">                    ans += (<span class="number">1</span> + num + prim + prim * prim)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="comment"># 可以分解成两个质数乘积</span></span><br><span class="line">                <span class="keyword">if</span> num % prim == <span class="number">0</span> <span class="keyword">and</span> isPrim[num // prim] <span class="keyword">and</span> prim * prim != num:</span><br><span class="line">                    ans += (<span class="number">1</span> + num + prim + num // prim)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>




<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></h6></h6>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ezharjan.github.io/Blog/2022/03/05/Reverse-Interview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="Alexander Ezharjan">
      <meta itemprop="description" content="This blog is maintained by Alexander Ezharjan, in order to record some useful things in life.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2022/03/05/Reverse-Interview/" class="post-title-link" itemprop="url">Reverse Interview</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-05 22:34:30" itemprop="dateCreated datePublished" datetime="2022-03-05T22:34:30+08:00">2022-03-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-17 10:12:51" itemprop="dateModified" datetime="2022-10-17T10:12:51+08:00">2022-10-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Blog/categories/Job-Interview/" itemprop="url" rel="index"><span itemprop="name">Job Interview</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h6 align="center">编者：艾孜尔江<h6>


<h1 id="反向面试指南"><a href="#反向面试指南" class="headerlink" title="反向面试指南"></a>反向面试指南</h1><p>下面列表里的问题对于参加技术面试的人来说可能有些用。<br>列表里的问题并不一定适用于某个特定的职位或者工作类型，也没有排序。最开始的时候这只是我自己的问题列表，但是慢慢地添加了一些我觉得可能让我对这家公司亮红牌的问题。<br>我也注意到被我面试的人提问我的问题太少了，感觉他们挺浪费机会的。</p>
<h2 id="预期使用方式"><a href="#预期使用方式" class="headerlink" title="预期使用方式"></a>预期使用方式</h2><ul>
<li>检查一下哪些问题你感兴趣</li>
<li>检查一下哪些是你可以自己在网上找到答案的</li>
<li>找不到的话就向面试官提问</li>
</ul>
<p>绝对不要想把这个列表里的每个问题都问一遍。（尊重面试官的时间，而且你可以通过查找已经发布的答案来显示你的主动性）</p>
<p>请记住事情总是灵活的，组织的结构调整也会经常发生。拥有一个 bug 追踪系统并不会保证高效处理 bug。<br>CI&#x2F;CD （持续集成系统） 也不一定保证交付时间会很短。</p>
<h1 id="职责"><a href="#职责" class="headerlink" title="职责"></a>职责</h1><ul>
<li>On-call （电话值班）的计划或者规定是什么？值班或者遇到问题加班时候有加班费吗？</li>
<li>我的日常工作是什么？</li>
<li>有给我设定的特定目标吗？</li>
<li>团队里面初级和高级工程师的比例是多少？（有计划改变吗）</li>
<li>入职培训 (onboarding) 会是什么样的？</li>
<li>每个开发者有多大的自由来做出决定？</li>
<li>在你看来，这个工作做到什么程度算成功？</li>
<li>你期望我在最初的一个月 &#x2F; 三个月能够完成什么？</li>
<li>试用期结束的时候，你会怎么样衡量我的绩效？</li>
<li>自己单独的开发活动和按部就班工作的比例大概是怎样的？</li>
<li>一个典型的一天或者一周的工作是怎样安排的？</li>
<li>对我的申请你有什么疑虑么？</li>
<li>在这份工作上，我将会和谁紧密合作？</li>
<li>我的直接上级他们的上级都是什么样的管理风格？（事无巨细还是着眼宏观）</li>
<li>我在这个岗位上应该如何发展？会有哪些机会？</li>
<li>每天预期 &#x2F; 核心工作时间是多少小时？</li>
<li>我入职的岗位是新增还是接替之前离职的同事？（是否有技术债需要还）？(zh)</li>
<li>入职之后在哪个项目组，项目是新成立还是已有的？(zh)</li>
</ul>
<h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><ul>
<li>公司常用的技术栈是什么？</li>
<li>你们怎么使用源码控制系统？</li>
<li>你们怎么测试代码？</li>
<li>你们怎么追踪 bug?</li>
<li>你们怎样监控项目？</li>
<li>你们怎么集成和部署代码改动？是使用持续集成和持续部署吗 (CI&#x2F;CD)？</li>
<li>你们的基础设施搭建在版本管理系统里吗？或者是代码化的吗？</li>
<li>从计划到完成一项任务的工作流是什么样的？</li>
<li>你们如何准备故障恢复？</li>
<li>有标准的开发环境吗？是强制的吗？</li>
<li>你们需要花费多长时间来给产品搭建一个本地测试环境？（分钟 &#x2F; 小时 &#x2F; 天）</li>
<li>你们需要花费多长时间来响应代码或者依赖中的安全问题？</li>
<li>所有的开发者都可以使用他们电脑的本地管理员权限吗？</li>
<li>介绍一下你们的技术原则或者展望。</li>
<li>你们的代码有开发文档吗？有没有单独的供消费者阅读的文档？</li>
<li>你们有更高层次的文档吗？比如说 ER 图，数据库范式</li>
<li>你们使用静态代码分析吗？</li>
<li>你们如何管理内部和外部的数字资产？</li>
<li>你们如何管理依赖？</li>
<li>公司是否有技术分享交流活动？有的话，多久一次呢？(zh)</li>
<li>你们的数据库是怎么进行版本控制的？(zh)</li>
<li>业务需求有没有文档记录？是如何记录的？(zh)</li>
</ul>
<h1 id="团队"><a href="#团队" class="headerlink" title="团队"></a>团队</h1><ul>
<li>工作是怎么组织的？</li>
<li>团队内 &#x2F; 团队间的交流通常是怎样的？</li>
<li>你们使用什么工具来做项目组织？你的实际体会是什么？</li>
<li>如果遇到不同的意见怎样处理？</li>
<li>谁来设定优先级 &#x2F; 计划？</li>
<li>如果团队没能赶上预期发布日期怎么办？</li>
<li>每周都会开什么类型的会议？</li>
<li>会有定期的和上级的一对一谈话吗？</li>
<li>产品 &#x2F; 服务的规划是什么样的？（n 周一发布 &#x2F; 持续部署 &#x2F; 多个发布流 &#x2F; …)</li>
<li>生产环境发生事故了怎么办？是否有不批评人而分析问题的文化？</li>
<li>有没有一些团队正在经历还尚待解决的挑战？</li>
<li>你们如何跟踪进度？</li>
<li>预期和目标是如何设定的？谁来设定？</li>
<li>Code Review 如何实施？</li>
<li>给我介绍下团队里一个典型的 sprint</li>
<li>你们如何平衡技术和商业目标？</li>
<li>你们如何共享知识？</li>
<li>团队有多大？</li>
<li>公司技术团队的架构和人员组成？(zh)</li>
<li>团队内开发、产品、运营哪一方是需求的主要提出方？哪一方更强势？(zh)</li>
</ul>
<h1 id="问未来的同事"><a href="#问未来的同事" class="headerlink" title="问未来的同事"></a>问未来的同事</h1><ul>
<li>开发者倾向于从哪里学习？</li>
<li>你对在这里工作最满意的地方是？</li>
<li>最不满意的呢？</li>
<li>如果可以的话，你想改变哪里？</li>
<li>团队最老的成员在这里多久了？</li>
<li>在小团队中，有没有出现成员性格互相冲突的情况？最后是如何解决的？</li>
</ul>
<h1 id="公司"><a href="#公司" class="headerlink" title="公司"></a>公司</h1><ul>
<li>公司为什么在招人？（产品发展 &#x2F; 新产品 &#x2F; 波动…)</li>
<li>有没有会议 &#x2F; 旅行预算？使用的规定是什么？</li>
<li>晋升流程是怎样的？要求 &#x2F; 预期是怎样沟通的？</li>
<li>绩效评估流程是怎样的？</li>
<li>技术和管理两条职业路径是分开的吗？</li>
<li>对于多元化招聘的现状或者观点是什么？</li>
<li>有公司级别的学习资源吗？比如电子书订阅或者在线课程？</li>
<li>有获取证书的预算吗？</li>
<li>公司的成熟度如何？（早期寻找方向 &#x2F; 有内容的工作 &#x2F; 维护中 &#x2F; …)</li>
<li>我可以为开源项目做贡献吗？是否需要审批？</li>
<li>你认为公司未来五年或者十年会发展成什么样子？</li>
<li>公司的大多数员工是如何看待整洁代码的？</li>
<li>你上次注意到有人成长是什么时候？他们在哪方面成长了？</li>
<li>在这里成功的定义是什么？如何衡量成功？</li>
<li>有体育活动或者团建么？</li>
<li>有内部的黑客马拉松活动吗？</li>
<li>公司支持开源项目吗？</li>
<li>有竞业限制或者保密协议需要签吗？</li>
<li>你们认为公司文化中的空白是什么？</li>
<li>能够跟我说一公司处于不良情况，以及如何处理的故事吗？</li>
<li>您在这工作了多久了？您觉得体验如何？(zh)</li>
<li>大家为什么会喜欢这里？(zh)</li>
<li>公司的调薪制度是如何的？(zh)</li>
</ul>
<h1 id="社会问题"><a href="#社会问题" class="headerlink" title="社会问题"></a>社会问题</h1><ul>
<li>你们关于多元化招聘什么看法？</li>
<li>你们的公司文化如何？你认为有什么空白么？</li>
<li>这里的工作生活平衡地怎么样？</li>
<li>公司对气候变化有什么态度吗？</li>
</ul>
<h1 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h1><ul>
<li>不同的意见如何处理？</li>
<li>如果被退回了会怎样？（“这个在预计的时间内做不完”）</li>
<li>当团队有压力并且在超负荷工作的时候怎么处理？</li>
<li>如果有人注意到了在流程或者技术等其他方面又改进的地方，怎么办？</li>
<li>当管理层的预期和工程师的绩效之间有差距的时候如何处理？</li>
<li>能给我讲一个公司深处有毒环境以及如何处理的故事吗？</li>
<li>如果在公司内你的同事因涉嫌性侵犯他人而被调查，请问你会如何处理？</li>
<li>假设我自己很不幸是在公司内被性侵的受害者，在公司内部有没有争取合法权益的渠道？</li>
</ul>
<h1 id="商业"><a href="#商业" class="headerlink" title="商业"></a>商业</h1><ul>
<li>你们现在盈利吗？</li>
<li>如果没有的话，还需要多久？</li>
<li>公司的资金来源是什么？谁影响或者制定高层计划或方向？</li>
<li>你们如何挣钱？</li>
<li>什么阻止了你们挣更多的钱？</li>
<li>公司未来一年的增长计划怎样？五年呢？</li>
<li>你们认为什么是你们的竞争优势？</li>
<li>你们的竞争优势是什么？</li>
<li>公司未来的商业规划是怎样的？有上市的计划吗？(zh)</li>
</ul>
<h1 id="远程工作"><a href="#远程工作" class="headerlink" title="远程工作"></a>远程工作</h1><ul>
<li>远程工作和办公室工作的比例是多少？</li>
<li>公司提供硬件吗？更新计划如何？</li>
<li>使用自己的硬件办公可以吗？现在有政策吗？</li>
<li>额外的附件和家具可以通过公司购买吗？这方面是否有预算？</li>
<li>有共享办公或者上网的预算吗？</li>
<li>多久需要去一次办公室？</li>
<li>公司的会议室是否一直是视频会议就绪的？</li>
</ul>
<h1 id="办公室布局"><a href="#办公室布局" class="headerlink" title="办公室布局"></a>办公室布局</h1><ul>
<li>办公室的布局如何？（开放的 &#x2F; 小隔间 &#x2F; 独立办公室）</li>
<li>有没有支持 &#x2F; 市场 &#x2F; 或者其他需要大量打电话的团队在我的团队旁边办公？</li>
</ul>
<h1 id="终极问题"><a href="#终极问题" class="headerlink" title="终极问题"></a>终极问题</h1><ul>
<li>该职位为何会空缺？</li>
<li>公司如何保证人才不流失？</li>
<li>这份工作 &#x2F; 团队 &#x2F; 公司最好和最坏的方面是？</li>
<li>你最开始为什么选择了这家公司？</li>
<li>你为什么留在这家公司？</li>
</ul>
<h1 id="待遇"><a href="#待遇" class="headerlink" title="待遇"></a>待遇</h1><ul>
<li>如果有奖金计划的话，奖金如何分配？</li>
<li>如果有奖金计划的话，过去的几年里通常会发百分之多少的奖金？</li>
<li>有五险一金(zh)&#x2F;401k(us)或者其他退休养老金等福利吗？</li>
<li>五险一金中，补充公积金一般交多少比例？&#x2F;401k一般交多少比例？我可以自己选择这一比例吗？</li>
<li>有什么医疗保险吗？如果有的话何时开始？</li>
<li>有额外商业保险吗？例如人寿保险和额外的养老&#x2F;医疗保险？</li>
<li>更换工作地点，公司付费吗？</li>
</ul>
<h1 id="休假"><a href="#休假" class="headerlink" title="休假"></a>休假</h1><ul>
<li>带薪休假时间有多久？</li>
<li>病假和事假是分开的还是一起算？</li>
<li>我可以提前使用假期时间吗？也就是说应休假期是负的？</li>
<li>假期的更新策略是什么样的？也就是说未休的假期能否滚入下一周期</li>
<li>照顾小孩的政策如何？</li>
<li>无薪休假政策是什么样的？</li>
<li>学术性休假政策是怎么样的？</li>
</ul>
<h1 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h1><p>Find more inspiration for questions in:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.joelonsoftware.com/2000/08/09/the-joel-test-12-steps-to-better-code/">The Joel Test: 12 Steps to Better Code</a> by Joel Spolsky</li>
<li><a target="_blank" rel="noopener" href="https://jvns.ca/blog/2013/12/30/questions-im-asking-in-interviews/">Questions I’m asking in interviews</a> by Julia Evans</li>
</ul>
<br>
<br>
<br>
<br>
<br>

<hr>
<br>

<h1 id="Reverse-interview"><a href="#Reverse-interview" class="headerlink" title="Reverse interview"></a>Reverse interview</h1><p>This is a list of questions which may be interesting to a tech job applicant.<br>The points are not ordered and many may not apply to a given position, or work type.<br>It was started as my personal list of questions, which grew over time to include both things I’d like to see more of and red flags which I’d like to avoid.<br>I’ve also noticed how few questions were asked by people I interviewed and I think those were missed opportunities.</p>
<h2 id="Expected-usage"><a href="#Expected-usage" class="headerlink" title="Expected usage"></a>Expected usage</h2><ul>
<li>Check which questions are interesting for you specifically</li>
<li>Check which answers you can find yourself online</li>
<li>Otherwise ask</li>
</ul>
<p>Definitely don’t try to ask everything from the list. (Respect the interviewer’s time and show initiative by finding answers on your own if they’re already published)</p>
<p>Remember that things tend to be fluid, re-organizations happens often.<br>Having a bug tracking system doesn’t make bug handling efficient and CI&#x2F;CD doesn’t mean your time to deliver is necessarily short.</p>
<h1 id="The-Role"><a href="#The-Role" class="headerlink" title="The Role"></a>The Role</h1><ul>
<li>What’s the on-call plan&#x2F;schedule? (what’s the pay for standby and call-out)</li>
<li>What are the tasks I would do on a usual day?</li>
<li>Are there any specific goals for me?</li>
<li>What’s the junior&#x2F;senior balance of the team? (and are there plans to change it)</li>
<li>What does the onboarding look like?</li>
<li>How much freedom for decision making do individual developers have?</li>
<li>What are the expected&#x2F;core work hours?</li>
<li>What is your definition of success for this role?</li>
<li>What do you expect me to accomplish in the first 1 month&#x2F;3 months?</li>
<li>How will you evaluate my performance at the end of the trial period?</li>
<li>What does a typical day&#x2F;week look like in this role?</li>
<li>Do you have any concerns about my application?</li>
<li>Tell me about who I would be working most closely with.</li>
<li>What management style does my immediate manager and their manager have? (from micro- to macro-)</li>
<li>How can I develop in my new role &#x2F; what opportunities are offered?</li>
</ul>
<h1 id="Tech"><a href="#Tech" class="headerlink" title="Tech"></a>Tech</h1><ul>
<li>What are the usual stacks used at the company?</li>
<li>How do you use source control?</li>
<li>How do you test code?</li>
<li>How do you track bugs?</li>
<li>How do you monitor projects?</li>
<li>How do you integrate and deploy changes? Is it CI&#x2F;CD?</li>
<li>Is your infrastructure setup under version control &#x2F; available as code?</li>
<li>What’s the workflow from the planning to the finished task?</li>
<li>How do you prepare for disaster recovery?</li>
<li>Is there a standardised development environment? Is it enforced?</li>
<li>How quickly can you setup a new local test environment for the product? (minutes &#x2F; hours &#x2F; days)</li>
<li>How quickly can you respond to security issues in the code or dependencies?</li>
<li>Are all developers allowed to have local admin access of their computers?</li>
<li>Tell me about your technical principles or vision.</li>
<li>Do you have a developer documentation for your code? Do you have a separate documentation for customers?</li>
<li>Do you have some higher level documentation? (ER diagrams, database schema)</li>
<li>Do you employ static code analysis?</li>
<li>How do you manage internal &#x2F; external artifacts?</li>
<li>How do you manage dependencies?</li>
</ul>
<h1 id="The-Team"><a href="#The-Team" class="headerlink" title="The Team"></a>The Team</h1><ul>
<li>How is the work organised?</li>
<li>How does the intra&#x2F;inter-team communication typically work?</li>
<li>Do you use any tools for project organization? What is your experience with them?</li>
<li>How are differences of opinions resolved?</li>
<li>Who sets the priorities &#x2F; schedule?</li>
<li>What happens after pushback? (“this can’t be done in the projected time”)</li>
<li>What happens when the team misses a release target?</li>
<li>What kind of meetings happen every week?</li>
<li>Would there be a regular 1-on-1 with my manager?</li>
<li>What’s the product&#x2F;service schedule? (n-weekly releases &#x2F; continuous deployment &#x2F; multiple release streams &#x2F; …)</li>
<li>What happens after production incidents? Is there a culture of blameless analysis?</li>
<li>What are some ongoing challenges the team is experiencing that you are yet to resolve?</li>
<li>How do you track progress?</li>
<li>How are expectations and goals set, and who does the setting?</li>
<li>What does a code review look like here?</li>
<li>Walk me through a typical sprint on this team</li>
<li>How do you balance technical vs business goals?</li>
<li>How do you share knowledge?</li>
<li>How big are the teams?</li>
</ul>
<h1 id="Your-Potential-Coworkers"><a href="#Your-Potential-Coworkers" class="headerlink" title="Your Potential Coworkers"></a>Your Potential Coworkers</h1><ul>
<li>Who do developers tend to learn from?</li>
<li>What do you like best about working there?</li>
<li>What do you like least?</li>
<li>What would you change if you could?</li>
<li>How long has the longest team member been there?</li>
<li>If it’s a small team, has there been experiences of conflicting personalities and how was this dealt with?</li>
</ul>
<h1 id="The-Company"><a href="#The-Company" class="headerlink" title="The Company"></a>The Company</h1><ul>
<li>Why is the company hiring? (product growth &#x2F; new product &#x2F; fluctuation &#x2F; …)</li>
<li>Is there a conference&#x2F;travel budget and what are the rules to use it?</li>
<li>What’s the promotion process? How are requirements &#x2F; expectations communicated?</li>
<li>What is the performance review process like?</li>
<li>Is there a separate tech and management career path?</li>
<li>Are there any company-wide resources for learning available, like ebooks subscriptions, or online courses?</li>
<li>Is there a budget for getting certifications?</li>
<li>What’s the maturity stage? (early finding direction &#x2F; feature work &#x2F; maintenance &#x2F; …)</li>
<li>Can I contribute to FOSS projects? Are there any approvals needed?</li>
<li>Are there any non-compete or non-disclosure agreements I’ll be asked to sign?</li>
<li>Where do you see the company in the next 5&#x2F;10 years? </li>
<li>What does clean code mean to the majority of developers here?</li>
<li>When is the last time you noticed someone growing here, and in what way were they growing?</li>
<li>What does it mean to be successful here, and how do you measure success?</li>
<li>Is there a Sports &#x2F; Team building Activity?</li>
<li>Are there any Hackathons conducted internally?</li>
<li>Does the company support open-source projects?</li>
<li>What kind of social events does the team&#x2F;company host and are these attended by everyone?</li>
<li>Why did the company decide to hire an outsider over promoting an internal employee?</li>
</ul>
<h1 id="Social-issues"><a href="#Social-issues" class="headerlink" title="Social issues"></a>Social issues</h1><ul>
<li>What’s the status of &#x2F; view on diverse hiring?</li>
<li>What do you think are the gaps in the company culture? (and what is the company culture?)</li>
<li>What does work-life balance mean here?</li>
<li>Does the company have a stance regarding climate change?</li>
</ul>
<h1 id="Conflict"><a href="#Conflict" class="headerlink" title="Conflict"></a>Conflict</h1><ul>
<li>How are differences of opinions resolved?</li>
<li>What happens after pushback? (“this can’t be done in the projected time”)</li>
<li>What happens when the team is under pressure and commits to work over their capacity &#x2F; velocity?</li>
<li>If someone identifies areas of improvement in process &#x2F; technology &#x2F; etc, what happens?</li>
<li>When there is a gap between expectations from management and performance of an engineer or team, what happens?</li>
<li>Could you tell me a story about a toxic situation and how the company dealt with it?</li>
</ul>
<h1 id="The-Business"><a href="#The-Business" class="headerlink" title="The Business"></a>The Business</h1><ul>
<li>Are you profitable?</li>
<li>If not, how long is your runway?</li>
<li>Where does the funding come from and who influences the high level plan&#x2F;direction?</li>
<li>How do you make money?</li>
<li>What’s preventing you from making more money?</li>
<li>What is the company’s growth plan for the next 1 year? 5 years?</li>
<li>What are the big challenges you see coming up?</li>
<li>What have you identified as your competitive advantage?</li>
</ul>
<h1 id="Remote-Work"><a href="#Remote-Work" class="headerlink" title="Remote Work"></a>Remote Work</h1><ul>
<li>What’s the ratio of remote to office workers?</li>
<li>Does the company provide hardware and what’s the refresh schedule?</li>
<li>How do you feel about <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bring_your_own_device">BYOD</a>? Are there any policies around it already?</li>
<li>Are extra accessories&#x2F;furniture possible to buy through the company? Is there a budget for them?</li>
<li>Is there a budget for co-working space or internet access?</li>
<li>How often are office visits expected?</li>
<li>Are the office meeting rooms always prepared for video conferences?</li>
</ul>
<h1 id="Building-Layout"><a href="#Building-Layout" class="headerlink" title="Building Layout"></a>Building Layout</h1><ul>
<li>What’s the office layout? (open plan &#x2F; cubicles &#x2F; offices)</li>
<li>Is there a support &#x2F; marketing &#x2F; other call-heavy team close to my new team?</li>
</ul>
<h1 id="Catch-all"><a href="#Catch-all" class="headerlink" title="Catch all"></a>Catch all</h1><ul>
<li>What’s the best and what’s the worst aspect of working in this role &#x2F; team &#x2F; company?</li>
<li>What got you to choose to work for the company initially?</li>
<li>What keeps you at the company?</li>
</ul>
<h1 id="Compensation"><a href="#Compensation" class="headerlink" title="Compensation"></a>Compensation</h1><ul>
<li>If you have a bonus scheme, then how are bonuses determined?</li>
<li>If you have a bonus scheme, then what have been the typical bonus percentages over the past few years?</li>
<li>Do you have a 401k or other retirement plan? If so, does the company match additional plan contributions?</li>
<li>Are there medical benefits and if so, when do they start?</li>
<li>Do you pay for relocation?</li>
</ul>
<h1 id="Time-Off"><a href="#Time-Off" class="headerlink" title="Time Off"></a>Time Off</h1><ul>
<li>How much Paid Time Off (PTO) is offered?</li>
<li>Are sick time and vacation time separate or do they come from the same pool?</li>
<li>Can I use vacation time before it’s accrued, effectively going into a negative PTO balance?</li>
<li>What is the roll over policy is there for PTO?</li>
<li>What is the parental leave policy?</li>
<li>What is the policy on unpaid leave?</li>
<li>What is the policy for sabbatical leave?</li>
</ul>
<h1 id="Other-resources"><a href="#Other-resources" class="headerlink" title="Other resources"></a>Other resources</h1><p>Find more inspiration for questions in:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.joelonsoftware.com/2000/08/09/the-joel-test-12-steps-to-better-code/">The Joel Test: 12 Steps to Better Code</a> by Joel Spolsky</li>
<li><a target="_blank" rel="noopener" href="https://jvns.ca/blog/2013/12/30/questions-im-asking-in-interviews/">Questions I’m asking in interviews</a> by Julia Evans</li>
</ul>
<h1 id="License"><a href="#License" class="headerlink" title="License"></a>License</h1><p><a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-sa/4.0/"><img src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" alt="Creative Commons License"></a></p>
<p>This work is licensed under a <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a target="_blank" rel="noopener" href="https://github.com/viraptor/reverse-interview">中文翻译来源</a></p>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></h6></h6>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ezharjan.github.io/Blog/2022/02/13/Test-Asset-Folder/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="Alexander Ezharjan">
      <meta itemprop="description" content="This blog is maintained by Alexander Ezharjan, in order to record some useful things in life.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2022/02/13/Test-Asset-Folder/" class="post-title-link" itemprop="url">Test Asset Folder</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-13 13:52:43" itemprop="dateCreated datePublished" datetime="2022-02-13T13:52:43+08:00">2022-02-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-17 01:04:55" itemprop="dateModified" datetime="2022-10-17T01:04:55+08:00">2022-10-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Blog/categories/Hexo-Intro/" itemprop="url" rel="index"><span itemprop="name">Hexo Intro</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Asset-Folder-Test"><a href="#Asset-Folder-Test" class="headerlink" title="Asset Folder Test"></a>Asset Folder Test</h1><h1 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h1><p>The image is placed in the folder with the same name as this document.<br><br></p>
<h4 id="1-Revise-the-code-in-hexo-asset-image-index-js-to-the-code-below"><a href="#1-Revise-the-code-in-hexo-asset-image-index-js-to-the-code-below" class="headerlink" title="1. Revise the code in hexo-asset-image/index.js to the code below:"></a>1. Revise the code in <code>hexo-asset-image/index.js</code> to the code below:</h4><p><em>Pay attention to the codes on 59 line.</em></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">&#x27;cheerio&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getPosition</span>(<span class="params">str, m, i</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> str.<span class="title function_">split</span>(m, i).<span class="title function_">join</span>(m).<span class="property">length</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&#x27;after_post_render&#x27;</span>, <span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> config = hexo.<span class="property">config</span>;</span><br><span class="line">  <span class="keyword">if</span>(config.<span class="property">post_asset_folder</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> link = data.<span class="property">permalink</span>;</span><br><span class="line">    <span class="keyword">var</span> beginPos = <span class="title function_">getPosition</span>(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> appendLink = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="comment">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span></span><br><span class="line">    <span class="comment">// if not with index.html endpos = link.lastIndexOf(&#x27;.&#x27;) + 1 support hexo-abbrlink</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="regexp">/.*\/index\.html$/</span>.<span class="title function_">test</span>(link)) &#123;</span><br><span class="line">      <span class="comment">// when permalink is end with index.html, for example 2019/02/20/xxtitle/index.html</span></span><br><span class="line">      <span class="comment">// image in xxtitle/ will go to xxtitle/index/</span></span><br><span class="line">      appendLink = <span class="string">&#x27;index/&#x27;</span>;</span><br><span class="line">      <span class="keyword">var</span> endPos = link.<span class="title function_">lastIndexOf</span>(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> endPos = link.<span class="property">length</span>-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    link = link.<span class="title function_">substring</span>(beginPos, endPos) + <span class="string">&#x27;/&#x27;</span> + appendLink;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> toprocess = [<span class="string">&#x27;excerpt&#x27;</span>, <span class="string">&#x27;more&#x27;</span>, <span class="string">&#x27;content&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.<span class="property">length</span>; i++)&#123;</span><br><span class="line">      <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> $ = cheerio.<span class="title function_">load</span>(data[key], &#123;</span><br><span class="line">        <span class="attr">ignoreWhitespace</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">xmlMode</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">lowerCaseTags</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">decodeEntities</span>: <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(<span class="string">&#x27;img&#x27;</span>).<span class="title function_">each</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> ($(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&#x27;src&#x27;</span>))&#123;</span><br><span class="line">          <span class="comment">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span></span><br><span class="line">          <span class="keyword">var</span> src = $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&#x27;src&#x27;</span>).<span class="title function_">replace</span>(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">          <span class="keyword">if</span>(!(<span class="regexp">/http[s]*.*|\/\/.*/</span>.<span class="title function_">test</span>(src)</span><br><span class="line">            || <span class="regexp">/^\s+\//</span>.<span class="title function_">test</span>(src)</span><br><span class="line">            || <span class="regexp">/^\s*\/uploads|images\//</span>.<span class="title function_">test</span>(src))) &#123;</span><br><span class="line">            <span class="comment">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span></span><br><span class="line">            <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">            <span class="keyword">var</span> linkArray = link.<span class="title function_">split</span>(<span class="string">&#x27;/&#x27;</span>).<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">elem</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">var</span> srcArray = src.<span class="title function_">split</span>(<span class="string">&#x27;/&#x27;</span>).<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">elem</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span> &amp;&amp; elem != <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">if</span>(srcArray.<span class="property">length</span> &gt; <span class="number">1</span>)</span><br><span class="line">            srcArray.<span class="title function_">shift</span>();</span><br><span class="line">            src = srcArray.<span class="title function_">join</span>(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// $(this).attr(&#x27;src&#x27;, config.root + link + src); // original code</span></span><br><span class="line">            <span class="comment">// console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src);</span></span><br><span class="line">            $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&#x27;src&#x27;</span>, data.<span class="property">permalink</span> + src); <span class="comment">// new code</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="property">info</span>&amp;&amp;<span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&quot;update link as:--&gt;&quot;</span> + data.<span class="property">permalink</span> + src);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="property">info</span>&amp;&amp;<span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&quot;no src attr, skipped...&quot;</span>);</span><br><span class="line">          <span class="variable language_">console</span>.<span class="property">info</span>&amp;&amp;<span class="variable language_">console</span>.<span class="title function_">info</span>($(<span class="variable language_">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      data[key] = $.<span class="title function_">html</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-Place-the-image-you-are-gonna-use-in-your-MD-file-to-the-folder-the-same-as-your-MD-file"><a href="#2-Place-the-image-you-are-gonna-use-in-your-MD-file-to-the-folder-the-same-as-your-MD-file" class="headerlink" title="2. Place the image you are gonna use in your MD file to the folder the same as your MD file."></a>2. Place the image you are gonna use in your MD file to the folder the same as your MD file.</h4><br>

<h4 id="3-Directly-use-the-image-in-your-note-in-MD-file-like-below"><a href="#3-Directly-use-the-image-in-your-note-in-MD-file-like-below" class="headerlink" title="3. Directly use the image in your note in MD file like below."></a>3. Directly use the image in your note in MD file like below.</h4><p><img src="https://ezharjan.github.io/Blog/2022/02/13/Test-Asset-Folder/camel.jpg" alt="Local Image Test"></p>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/Blog/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/Blog/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Alexander Ezharjan</p>
  <div class="site-description" itemprop="description">This blog is maintained by Alexander Ezharjan, in order to record some useful things in life.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/Blog/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/Blog/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Alexander Ezharjan</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/Blog/lib/anime.min.js"></script>
  <script src="/Blog/lib/velocity/velocity.min.js"></script>
  <script src="/Blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/Blog/js/utils.js"></script>

<script src="/Blog/js/motion.js"></script>


<script src="/Blog/js/schemes/muse.js"></script>


<script src="/Blog/js/next-boot.js"></script>




  




  
<script src="/Blog/js/local-search.js"></script>













  

  

</body>
</html>
